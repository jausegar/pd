#!/usr/bin/wish
# Copyright (c) 1997-1999 Miller Puckette.
# For information on usage and redistribution, and for a DISCLAIMER OF ALL
# WARRANTIES, see the file, "LICENSE.txt," in this distribution.

# changed by Thomas Musil 09.2001
# between "pdtk_graph_dialog -- dialog window for graphs"
# and "pdtk_array_dialog -- dialog window for arrays"
# a new dialogbox was inserted, named:
# "pdtk_iemgui_dialog -- dialog window for iem guis"
#
# all these changes are labeled with #######iemlib########

# set pd_nt (bad name) 0 for unix, 1 for microsoft, and 2 for Mac OSX.

#May 22 2009
#GUI improvements and dynamic runtime 8.5 widget upgrade for Linux by Ivica Ico Bukvic
#http://ico.bukvic.net <ico@vt.edu>

# Mathieu's way of listing all defined procs
#rename proc proque
#proque proc {name args body} {
#  puts "proc $name"
#  uplevel 1 [list proque $name $args $body]
#}

#puts stderr [info tclversion]
##--moo: force default system and stdio encoding to UTF-8
encoding system utf-8
fconfigure stderr -encoding utf-8
fconfigure stdout -encoding utf-8
##--/moo

set appname [tk appname]
tk appname $appname-startup
#puts stderr "APPNAME [tk appname]"

if { [info tclversion] >= 8.5 } {

	# EDIT THIS PART TO CUSTOMIZE LINUX THEME
	# match gnome colors
	# Ubuntu Human
	# set linux_wm_bgcolor "#3e3d39"
	set linux_wm_bgcolor "#e5e5e5"
	# set linux_wm_hlcolor "#fdbf69"
	# set linux_wm_hlcolor "#f9ba81"
	# set linux_wm_hlcolor "#ffaa16"
	set linux_wm_hlcolor "#eb5f28"

	# ttk colors
	# -frame, -lighter, and -selectbg are automatically
	#	replaced by theme colors specified above
	variable colors
	array set colors {
		-frame 		"#e5e5e5"
		-window		"#ffffff"
		-darkest 	"#999999"
		-darker 	"#709970"
		#-dark		"#a8e6a8"
		-dark		"#bcbcbc"
		-light		"#d2ffd2"
		-lighter 	"#e5e5e5"
		-disabledfg	"#a3a3a3"
		-selectbg	"#fdbf69"
		-selectfg	"#000000"
	}
	# STOP EDITING BEYOND THIS POINT

	#sync ttk with theme choice above it
	set colors(-frame) $linux_wm_bgcolor
	set colors(-lighter) $linux_wm_bgcolor
	set colors(-selectbg) $linux_wm_hlcolor

	ttk::style theme create purty_linux -parent clam -settings {

		ttk::style configure "." \
			-background 	$colors(-frame) \
			-foreground 	black \
			-bordercolor	$colors(-darkest) \
			-selectbackground 	$colors(-selectbg) \
			-selectforeground 	$colors(-selectfg) \
			-troughcolor	$colors(-dark) \
			-arrowcolor 	$colors(-darkest) \
			-font 		TkDefaultFont \
			;

		ttk::style map "." -background \
			[list disabled $colors(-frame)  active $colors(-lighter)] ;
		ttk::style map "." -foreground [list disabled $colors(-disabledfg)] ;
		    ttk::style map "." -embossed [list disabled 0] ;

		ttk::style configure TButton \
			-anchor center -width -11 -padding "1 1" \
			-relief raised -shiftrelief 1 \
			-highlightthickness 1 -highlightcolor $colors(-selectbg)

		ttk::style map TButton -relief {
			{pressed !disabled} 	sunken
			{active !disabled} 	raised
		} -highlightcolor {alternate black}

		ttk::style configure TCheckbutton \
			-indicatorcolor $colors(-window) -padding 2
		ttk::style configure TRadiobutton \
			-indicatorcolor $colors(-window) -padding 2
		ttk::style map TCheckbutton -indicatorcolor \
			[list  disabled $colors(-frame)  pressed $colors(-frame)]
		ttk::style map TRadiobutton -indicatorcolor \
			[list  disabled $colors(-frame)  pressed $colors(-frame)]

		ttk::style configure TMenubutton \
			-width -11 -padding "3 3" -relief raised

		ttk::style configure TEntry \
			-padding 1 -fieldbackground $colors(-window) ;
		ttk::style map TEntry -fieldbackground \
			[list readonly $colors(-frame) disabled $colors(-frame)]
		ttk::style configure TCombobox \
			-padding 1 -fieldbackground $colors(-window) ;
		ttk::style map TCombobox -fieldbackground \
			[list readonly $colors(-frame) disabled $colors(-frame)]

		ttk::style configure Toolbutton -relief flat -padding 2
		ttk::style map Toolbutton -relief \
			{disabled flat selected sunken pressed sunken active raised}
		ttk::style map Toolbutton -background \
			[list pressed $colors(-dark)  active $colors(-light)]

		ttk::style configure TScrollbar -relief raised
		ttk::style configure TScale \
			-groovewidth 4 -troughrelief sunken \
			-sliderwidth raised -borderwidth 2
		ttk::style configure TProgressbar \
			-background $colors(-selectbg) -borderwidth 0

		ttk::style configure TLabelframe -relief groove -borderwidth 2

		ttk::style configure TNotebook -tabmargins {2 2 1 0}
		ttk::style configure TNotebook.Tab \
			-padding {4 2} -background $colors(-dark)
		ttk::style map TNotebook.Tab \
			-background [list selected $colors(-frame)] \
			-expand [list selected {2 2 1 0}] \
			;

		ttk::style configure Treeview -fieldbackground $colors(-window)
		ttk::style configure Heading -font TkHeadingFont -relief raised
		ttk::style configure Row -background $colors(-window)
		ttk::style map Row \
			-background [list selected $colors(-selectbg)]
		ttk::style map Item \
			-foreground [list selected $colors(-selectfg)]
		ttk::style map Cell \
			-foreground [list selected $colors(-selectfg)]
	}
}

# Automate matching of the linux wm and use ttk where possible
# As of right now it is only enabled if system is Linux/Unix using tcl >= 8.5
proc match_linux_wm {list} {
	global pd_nt linux_wm_bgcolor linux_wm_hlcolor
	if { [info tclversion] >= 8.5 && $pd_nt == 0 } {
		if {[lsearch -regexp $list ::] != 0} {
			#puts stderr [lindex $list 0]
			if {[lindex $list 0] != "button" \
				&& [lindex $list 0] != "checkbutton" \
				&& [lindex $list 0] != "radiobutton" \
				&& [lindex $list 0] != "entry" \
				&& [lindex $list 0] != "scrollbar" \
				&& [lindex $list 1] != "add"} { 
					lappend list -bg $linux_wm_bgcolor
			}
			if {[lindex $list 0] == "listbox" \
				|| [lindex $list 0] == "text"} {

				lappend list -bg white -highlightcolor $linux_wm_hlcolor
			}
			if {[lindex $list 1] == "add"} {
	
				#lappend list -background "#000000"
				set newlist [list [lindex $list 0] add command -label {} -state disabled]
			}
			if {[lindex $list 0] == "menu"} {
	
				lappend list -activebackground $linux_wm_hlcolor -bg "#3c3b37" -fg "#dddddd" -bd 0 -activeborderwidth 0 -relief flat -disabledforeground "#777777"
			}
			#convert non-ttk objects to ttk objects
			if {[lindex $list 0] == "button" \
				|| [lindex $list 0] == "checkbutton" \
				|| [lindex $list 0] == "radiobutton" \
				|| [lindex $list 0] == "entry" \
				|| [lindex $list 0] == "scrollbar"} { 
				set newlist [lreplace $list 0 0 ttk::[lindex $list 0]]
			}
		}
	}
	if {[info exists newlist]} {
		eval $newlist
	} else {
		#puts stderr "[lsearch -regexp $list ::]:::::[lindex $list 0]::::::$list"
		eval $list
	}
}

if { $tcl_platform(platform) == "windows" }  {
    set pd_nt 1
    set ctrl_key "Control"
    # fontsc
    set defaultFontFamily {DejaVu Sans Mono}
    font create menuFont -family Tahoma -size 10
    # mouse cursors
    set cursor_runmode_nothing "arrow"
    set cursor_runmode_clickme "right_ptr"
    set cursor_runmode_thicken "sb_v_double_arrow"
    set cursor_runmode_addpoint "plus"
    set cursor_editmode_nothing "hand2"
    set cursor_editmode_connect "circle"
    set cursor_editmode_disconnect "X_cursor"
	set cursor_editmode_resize "sb_h_double_arrow"
	set cursor_editmode_resize_bottom_right "bottom_right_corner"
	set cursor_scroll "fleur"
	# set file types that open/save recognize
	set filetypes {
		{{Pd Files}         {.pd}  }
		{{Max Patch Files}  {.pat} }
		{{Max Text Files}   {.mxt} }
		{{Max Binary Files} {.mxb} }
		{{Max Help Files}   {.help} }
	}
	# use CommonProgramFiles by default instead because its a lot easier to
	# find. Microsoft seems to have carefully hidden the AppData folder from
	# all but the most determined users.
	#set externalsdir "$::env(AppData)/Pd"
	set externalsdir "$::env(CommonProgramFiles)/Pd"
} elseif { $tcl_platform(os) == "Darwin" } {  
    set pd_nt 2
	set ctrl_key "Mod1"
    # fonts
    set defaultFontFamily Monaco
    # mouse cursors
    set cursor_runmode_nothing "arrow"
    set cursor_runmode_clickme "center_ptr"
    set cursor_runmode_thicken "sb_v_double_arrow"
    set cursor_runmode_addpoint "plus"
    set cursor_editmode_nothing "hand2"
    set cursor_editmode_connect "circle"
    set cursor_editmode_disconnect "X_cursor"
	set cursor_editmode_resize "sb_h_double_arrow"
	set cursor_editmode_resize_bottom_right "bottom_right_corner"
	set cursor_scroll "fleur"
	# set file types that open/save recognize
	set filetypes {
		{{Pd Files}                {.pd}  }
		{{Max Patch Files (.pat)}  {.pat} }
		{{Max Text Files (.mxt)}   {.mxt} }
		{{Max Binary Files (.mxb)} {.mxb} }
		{{Max Help Files (.help)}  {.help} }
	}
	set externalsdir "$::env(HOME)/Library/Pd"
} else { 
	# set nicer theme
	ttk::style theme use purty_linux
	clipboard clear
	set window_prefs {}
    set pd_nt 0
    set ctrl_key "Control"
	# Shift modifier
	set shift_l_down 0
	set shift_r_down 0
	# Ctrl modifier
	set ctrl_l_down 0
	set ctrl_r_down 0
    # fonts
    set defaultFontFamily {DejaVu Sans Mono}
    # mouse cursors
    set cursor_runmode_nothing "left_ptr"
    set cursor_runmode_clickme "right_ptr"
    set cursor_runmode_thicken "sb_v_double_arrow"
    set cursor_runmode_addpoint "plus"
    set cursor_editmode_nothing "hand2"
    set cursor_editmode_connect "target"
    set cursor_editmode_disconnect "X_cursor"
	set cursor_editmode_resize "sb_h_double_arrow"
	set cursor_editmode_resize_bottom_right "bottom_right_corner"
	set cursor_scroll "fleur"
	# set file types that open/save recognize
	set filetypes {
		{{pd files}         {.pd}  }
		{{max patch files}  {.pat} }
		{{max text files}   {.mxt} }
		{{max binary files} {.mxb} }
		{{max help files}   {.help} }
	}
	set externalsdir "$::env(HOME)/pd-l2ork-externals"
}   

proc bgerror {message} {
	#pdtk_post "\ntcl error: $message"
	puts "\033\[0;1;33mtcl error: $::errorInfo\033\[0m"
}     

# make sure the user folder for installing externals exists
#catch {
#	if { ! [file exists $externalsdir] && [file exists [file dirname $externalsdir]] } {
#		puts stderr "Creating folder for user-installed externals: \n\t$externalsdir"
#		file mkdir $externalsdir
#	}
#}

# make sure the user folder for settings exists
catch {
	if { ! [file exists $::env(HOME)/.pd-l2ork] } {
		puts stderr "Creating settings folder: $::env(HOME)/.pd-l2ork"
		file mkdir $::env(HOME)/.pd-l2ork
	}
}

# namespace for general-purpose functions
proc pdtk_encode { listdata } {
    set outlist {}
    foreach this_path $listdata {
        if {0==[string match "" $this_path]} {
            lappend outlist [pdtk_encodedialog $this_path]
        }
    }
    return $outlist
}


# args is a list of length 1 or 2,
# specifying optional additional x, y offsets for the window
proc center_window { w args } {
    set offx 0
    set offy 0

    if { [llength $args] >= 2 } {
        set offx [lindex $args 0]
        set offy [lindex $args 1]
    }

    set x [expr [winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
        - [winfo vrootx [winfo parent $w]] + $offx]
    set y [expr [winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
        - [winfo vrooty [winfo parent $w]] + $offy]
    wm geom $w +$x+$y
}

# backported workaround for pdsend
#proc pdsend { args } {
#	#puts stderr "===============pdsend pdtk $args"
#	pd [concat pd $args \;]
#}
proc ::pdsend {args} {
	#puts stderr "===============[join $args { }]"
	pd "[join $args { }] ;"
}

# start Pd-extended font hacks -----------------------------

# Pd-0.39.2-extended hacks to make font/box sizes the same across platform
#puts stderr "tk scaling is [tk scaling]"
tk scaling 1

# this font is for the Pd Window console text
font create console_font -family $defaultFontFamily -size 9 -weight normal
# this font is for text in Pd windows
font create text_font -family $defaultFontFamily -size 9 -weight normal
# for text in Properties Panels and other panes
font create highlight_font -family $defaultFontFamily -size 9 -weight bold
if { $pd_nt == 0 } {
	font create menufont -family $defaultFontFamily -size 9 -weight normal
}

# end Pd-extended font hacks -----------------------------

# K-12 version global variable (enabled through -k12, disabled by default)
set k12_mode 0
set k12_saveas_on_new 0

# Only can be enabled at startup (cannot be toggled afterwards)
proc pdtk_enable_k12_mode {extra_dir} {
	global k12_mode
#	global signal_cord_width
	global autotips
#	global signal_cord_highlight
#	global signal_cord
	global highlight_width

	set k12_mode 1
#	set signal_cord_width 5
	set ::pd_colors(signal_cord_width) 5
	set autotips 1
#	set signal_cord_highlight "#474"
	set ::pd_colors(signal_cord) "#2ca7d4"
	set ::pd_colors(signal_nlet) "#2ca7d4"
#	set signal_cord "#2ca7d4"
	set highlight_width 7

	image create photo i.wii_connect -file $extra_dir/K12/icons/wii_connect_on.png
	image create photo i.wii_buttons -file $extra_dir/K12/icons/wii_buttons.png
	image create photo i.wii_speed_xry -file $extra_dir/K12/icons/wii_speed_xry.png
	image create photo i.wii_speed -file $extra_dir/K12/icons/wii_speed.png
	image create photo i.wii_hit -file $extra_dir/K12/icons/wii_hit.png

	image create photo i.wii_accelerometer -file $extra_dir/K12/icons/wii_accelerometer.png
	image create photo i.wii_nunchuk_buttons -file $extra_dir/K12/icons/wii_nunchuk_buttons.png
	image create photo i.wii_nunchuk_hit -file $extra_dir/K12/icons/wii_nunchuk_hit.png
	image create photo i.wii_nunchuk_accelerometer -file $extra_dir/K12/icons/wii_nunchuk_accelerometer.png
	image create photo i.wii_nunchuk_stick -file $extra_dir/K12/icons/wii_nunchuk_stick.png

	image create photo i.arduino -file $extra_dir/K12/icons/arduino_on.png
	image create photo i.arduino_digital_in -file $extra_dir/K12/icons/arduino_digital_in.png
	image create photo i.arduino_digital_out -file $extra_dir/K12/icons/arduino_digital_out.png
	image create photo i.arduino_analog_in -file $extra_dir/K12/icons/arduino_analog_in.png
	image create photo i.arduino_analog_out -file $extra_dir/K12/icons/arduino_analog_out.png
	#image create photo i.arduino_net -file $extra_dir/K12/icons/arduino_net.png

	image create photo i.raspberry_digital -file $extra_dir/K12/icons/raspberrypi_gpio_digital_on.png
	image create photo i.raspberry_analog_out -file $extra_dir/K12/icons/raspberrypi_gpio_analog_out_on.png
	image create photo i.raspberry_analog_in -file $extra_dir/K12/icons/raspberrypi_3008_analog_in_on.png
	image create photo i.raspberry_motor -file $extra_dir/K12/icons/raspberrypi_motor_on.png
	image create photo i.raspberry_solenoid -file $extra_dir/K12/icons/raspberrypi_solenoid_on.png

	image create photo i.math_netreceive -file $extra_dir/K12/icons/math_netreceive.png
	image create photo i.math_tag -file $extra_dir/K12/icons/math_tag.png
	image create photo i.math_routebytag -file $extra_dir/K12/icons/math_routebytag.png
	image create photo i.math_average -file $extra_dir/K12/icons/math_average.png
	image create photo i.math_random -file $extra_dir/K12/icons/math_random.png

	image create photo i.math_add -file $extra_dir/K12/icons/math_add.png
	image create photo i.math_subtract -file $extra_dir/K12/icons/math_subtract.png
	image create photo i.math_multiply -file $extra_dir/K12/icons/math_multiply.png
	image create photo i.math_divide -file $extra_dir/K12/icons/math_divide.png
	image create photo i.math_scale -file $extra_dir/K12/icons/math_scale.png
	image create photo i.math_exponentiate -file $extra_dir/K12/icons/math_exponentiate.png

	image create photo i.math_number -file $extra_dir/K12/icons/math_number.png
	image create photo i.math_netsend -file $extra_dir/K12/icons/math_netsend.png
	image create photo i.logic_compare -file $extra_dir/K12/icons/logic_compare.png
	image create photo i.logic_mapper -file $extra_dir/K12/icons/logic_mapper.png
	image create photo i.logic_metronome -file $extra_dir/K12/icons/logic_metronome.png
	
	image create photo i.logic_counter -file $extra_dir/K12/icons/logic_counter.png
	image create photo i.logic_hit -file $extra_dir/K12/icons/logic_hit.png
	image create photo i.logic_sequencer -file $extra_dir/K12/icons/logic_sequencer.png
	image create photo i.preset -file $extra_dir/K12/icons/preset.png
	image create photo i.comment -file $extra_dir/K12/icons/comment.png

	image create photo i.signal_microphone -file $extra_dir/K12/icons/signal_microphone.png
	image create photo i.signal_netsend -file $extra_dir/K12/icons/signal_netsend.png
	image create photo i.signal_netreceive -file $extra_dir/K12/icons/signal_netreceive.png	
	image create photo i.signal_sampler -file $extra_dir/K12/icons/signal_sampler.png
	image create photo i.signal_player -file $extra_dir/K12/icons/signal_player.png

	image create photo i.signal_sine -file $extra_dir/K12/icons/signal_sine.png
	image create photo i.signal_saw -file $extra_dir/K12/icons/signal_saw.png
	image create photo i.signal_square -file $extra_dir/K12/icons/signal_square.png
	image create photo i.signal_triangle -file $extra_dir/K12/icons/signal_triangle.png
	image create photo i.signal_envelope -file $extra_dir/K12/icons/signal_envelope.png

	image create photo i.signal_noise -file $extra_dir/K12/icons/signal_noise.png
	image create photo i.signal_pink -file $extra_dir/K12/icons/signal_pink.png
	image create photo i.signal_add -file $extra_dir/K12/icons/signal_add.png
	image create photo i.signal_multiply -file $extra_dir/K12/icons/signal_multiply.png

	image create photo i.instr_short1 -file $extra_dir/K12/icons/instr_short1.png
	image create photo i.instr_short2 -file $extra_dir/K12/icons/instr_short2.png
	image create photo i.instr_sustained1 -file $extra_dir/K12/icons/instr_sustained1.png
	image create photo i.instr_sustained2 -file $extra_dir/K12/icons/instr_sustained2.png

	image create photo i.midi_synth -file $extra_dir/K12/icons/midi_synth.png
	image create photo i.midi_note -file $extra_dir/K12/icons/midi_note.png
	image create photo i.midi_instrument -file $extra_dir/K12/icons/midi_instrument.png
	image create photo i.midi_control -file $extra_dir/K12/icons/midi_control.png

	image create photo i.fx_pitchshift -file $extra_dir/K12/icons/fx_pitchshift.png
	image create photo i.fx_filter -file $extra_dir/K12/icons/fx_filter.png
	image create photo i.fx_phaser -file $extra_dir/K12/icons/fx_phaser.png
	image create photo i.fx_multitap -file $extra_dir/K12/icons/fx_multitap.png
	image create photo i.fx_reverb -file $extra_dir/K12/icons/fx_reverb.png

	image create photo i.fx_autotune -file $extra_dir/K12/icons/fx_autotune.png
	image create photo i.output -file $extra_dir/K12/icons/audio_on.png

	image create photo i.edit -file $extra_dir/K12/icons/edit.png
	image create photo i.perform -file $extra_dir/K12/icons/perform.png

	image create photo i.data -file $extra_dir/K12/icons/control.png
	image create photo i.sound -file $extra_dir/K12/icons/sound.png
	image create photo i.data_on -file $extra_dir/K12/icons/control_on.png
	image create photo i.sound_on -file $extra_dir/K12/icons/sound_on.png

	.mbar.file insert 2 command -label {K12 Demos} -command {menu_k12_open_demos}

	#pack forget .controls.switches.audiobutton
	#pack forget .controls.inout
	#.mbar.audio delete 0 2
}

# calculate offset on a movable canvas
set tmp_xpix 0
set tmp_ypix 0

set popup_xpix 0
set popup_ypix 0

# monitor pointer position
set pointer_x_local 0
set pointer_y_local 0

set pointer_x_virtual 0
set pointer_y_virtual 0

set pointer_x_global 0
set pointer_y_global 0

# text pasting global
set copytexttocanvas 0

set global_clipboard 0
# used for comparison to avoid redundant copyfromexternalbuffer
set last_clipboard 0
set global_selection 0

#TOOLTIPS PATCH
#TODO: make a separate tcl file for tooltips and put
#afterid in its scope    
variable afterid 0
variable duplicate_tags -1
variable current_window 0
variable nlet_color 0
variable autotips 0
#variable magicglass 0
variable tooltip_visible 0

# x:y location tooltip during dragging
set tooltip [toplevel .tooltip -bd 1 -bg black]
wm attributes $tooltip -topmost 1
wm overrideredirect $tooltip 1
pack [label $tooltip.label -bg lightyellow -fg black -text aaa -justify left]
wm withdraw $tooltip

# timeout for the tooltip
proc pdtk_toggle_xy_tooltip {name num} {
	global tooltip
	if {$num == 0} {
		wm withdraw $tooltip
	} else {
		wm deiconify $tooltip
	}
}

proc pdtk_update_xy_tooltip {name x y} {
	global tooltip
	global pointer_x_virtual pointer_y_virtual pointer_x_global pointer_y_global
	wm geometry $tooltip +[expr $pointer_x_global+15]+[expr $pointer_y_global-2]
	$tooltip.label configure -text [concat x: $x\ny: $y]
	set pointer_x_virtual $x
	set pointer_y_virtual $y
}

# begin hack to hide hidden files/folder in tk browser on unix ----------
if {$pd_nt == 0} {
    # load the dialog once, otherwise setting the vars will not work
    catch {tk_getOpenFile -with-invalid-argument} 

    # change the environment variables
    namespace eval ::tk::dialog::file {
    variable showHiddenBtn 1
    variable showHiddenVar 0
    }
}
# end hidden files/folder hack ------------------

# Tearoff is set to false by default:
set pd_tearoff 0
# Put menu tearoff is set to true by default:
set put_tearoff 1
# turn off tearoff menus globally
#option add *tearOff 0

# jsarlo
set pd_array_listview_pagesize 1000
set pd_array_listview_id(0) 0
set pd_array_listview_entry(0) 0
set pd_array_listview_page(0) 0
# end jsarlo


if {$pd_nt == 1} {
    global pd_guidir
    set pd_gui2 [string range $argv0 0 [expr [string last \\ $argv0 ] - 1]]
    regsub -all \\\\ $pd_gui2 / pd_gui3
    set pd_guidir [file normalize $pd_gui3/..]
    load $pd_guidir/bin/pdtcl.dll
}

if {$pd_nt == 2} {
    # turn on James Tittle II's fast drawing
    set tk::mac::useCGDrawing 1
    # anti-alias all lines that need it
    set tk::mac::CGAntialiasLimit 0
    global pd_guidir
    set pd_gui2 [string range $argv0 0 [expr [string last / $argv0 ] - 1]]
    set pd_guidir [file normalize $pd_gui2/..]
    load $pd_guidir/bin/libPdTcl.dylib
    global pd_macready
    set pd_macready 0
    global pd_macdropped
    set pd_macdropped ""
    # tk::mac::OpenDocument is called with the filenames put into the 
    # var args whenever docs are either dropped on the Pd.app icon or 
    # opened from the Finder.
    # It uses menu_doc_open so it can handles numerous file types.
    proc tk::mac::OpenDocument {args} {
        global pd_macready pd_macdropped
        foreach file $args {
            if {$pd_macready != 0} {
                pd [concat pd open [pdtk_enquote [file tail $file]] \
                        [pdtk_enquote  [file dirname $file]] \;]
                menu_doc_open [file dirname $file] [file tail $file]
            } else {
                set pd_macdropped $args
            }
        }
    }
	# intercept kAEQuitApplication from Cmd-Q
	proc ::tk::mac::Quit {} {
		puts stderr "::tk::mac::Quit"
		menu_quit
	}
}

# hack so you can easily test-run this script in linux... define pd_guidir
# (which is normally defined at startup in pd under linux...)

if {$pd_nt == 0} {
    if {! [info exists pd_guidir]} {
        global pd_guidir
        puts stderr {setting pd_guidir to '.'}
        set pd_guidir .
    }
}

#set pd_deffont {courier 10}
set pd_deffont console_font

set help_top_directory $pd_guidir/doc

#==============================================================================#
# pd-gui-rewrite-0.43 help browser backport

switch -- $pd_nt {
    0  { set ::windowingsystem "x11" }
    1  { set ::windowingsystem "win32" }
    2  { set ::windowingsystem "aqua" }
}

# Pd's packages are stored in the same directory as the main script (pd-gui.tcl)
set auto_path [linsert $auto_path 0 [file dirname [info script]]]
# the pd-gui-rewrite-0.43 help browser is backported to Pd-extended 0.42
package require helpbrowser
package require msgcat
package require tkpng
package require tkdnd
package require pd_guiprefs
package require pd_menus
package require pdtk_textwindow

namespace import ::pd_guiprefs::init
namespace import ::pd_guiprefs::update_recentfiles
namespace import ::pd_guiprefs::write_recentfiles

set total_recentfiles 5
::pd_guiprefs::init

# Prefences Dialog
# dialog_prefs.tcl must come first because dialog_gui.tcl depends on it
# This is an ugly hack-- it should just be loaded as tcl packages like
# in 0.43...
source [file join [file dirname [info script]] dialog_prefs.tcl]
source [file join [file dirname [info script]] dialog_gui.tcl]
source [file join [file dirname [info script]] dialog_midi.tcl]
source [file join [file dirname [info script]] dialog_audio.tcl]

# Add a trace for the color array. This way any gui-plugin can make
# color changes simply by changing one of the elements of the pd_colors
# array, and all the preference dialog stuff and open patches will
# magically update
trace add variable pd_colors write ::dialog_prefs::set_color

# ... and a trace for the ::gui_preset variable.  There's probably
# a way to do this inside the dropdown code, which would be better...
trace add variable gui_preset write "::dialog_gui::set_gui_preset"

# Now that we've got a trace for the colors, we can set a
# color scheme if there isn't one in the preferences
# (defined in dialog_gui.tcl)
if {$::gui_preset eq ""} {
    set ::gui_preset L2Ork
} else {
    ::dialog_gui::set_gui_preset
}

# todo: find a home for these:
set ::pd_colors(signal_cord_width) 3
set ::pd_colors(control_cord_width) 1

# color scheme
# set canvas_fill "white"
# set text_color "#000"
# set select_color "#e87216"
# set dash_outline "#f00"
# set dash_fill "#f7f7f7"
# set box_outline "#ccc"
# set graph_outline "#777"
# set atom_box_fill "#eee"
# set msg_box_fill "#f8f8f6"
# set obj_box_fill "#f6f8f8"
# Doesn't look like signal_cord_highlight is used
# set signal_cord_highlight "#58a"
# set signal_cord "#808095"
# set signal_nlet $signal_cord
# Todo: make sure these work in k12 mode
# set signal_cord_width 3
# set msg_cord_highlight "#474"
# set msg_cord "#565"
# set msg_nlet "white"
# set mixed_nlet "#88aaff"
# set msg_cord_width 1

#nlet highlighting stuff
set select_nlet_color $pd_colors(selection)
set highlight_width 5

# official GNU gettext msgcat shortcut
proc _ {s} {return [::msgcat::mc $s]}

namespace eval ::pdwindow:: {
    proc verbose {level postme} {puts stderr "$level: $postme"}
    proc error {postme} {puts stderr $postme; pdtk_post $postme}
    proc warn {postme} {::pdwindow::error $postme}
}

set ::dialog_menubar .mbar
set ::modifier $ctrl_key
set ::sys_libdir $pd_guidir
switch $pd_nt {
    0 {set ::pd_path [list ~/pd-l2ork-externals /usr/local/lib/pd-l2ork-externals]}
    1 {set ::pd_path [list [file normalize $::env(AppData)/Pd] \
                          [file normalize $::env(CommonProgramFiles)/Pd]]}
    2 {set ::pd_path [list ~/Library/Pd /Library/Pd]}
}
#==============================================================================#

################## set up main window #########################
# the menus are instantiated here for the main window
# for the patch windows, they are created by pdtk_canvas_new

#ttk error button customizations
ttk::style configure IOErrorOn.TButton -background "#dd2222"
ttk::style map IOErrorOn.TButton -background [list active "#ff2222"] \
	-foreground [list disabled black]
ttk::style configure IOErrorOff.TButton -background lightgrey
ttk::style map IOErrorOff.TButton -background [list active $colors(-frame)]

match_linux_wm [list menu .mbar -relief flat]
match_linux_wm [list menu .mbar.file -tearoff $pd_tearoff -postcommand [concat pdtk_fixfilemenu .mbar.file]]
.mbar add cascade -label File -menu .mbar.file
match_linux_wm [list menu .mbar.edit -tearoff $pd_tearoff]
.mbar add cascade -label Edit -menu .mbar.edit
match_linux_wm [list menu .mbar.put -tearoff $pd_tearoff]
.mbar add cascade -label Put -menu .mbar.put
#match_linux_wm [list menu .mbar.find -tearoff $put_tearoff]
#.mbar add cascade -label Find -menu .mbar.find
match_linux_wm [list menu .mbar.windows -postcommand [concat pdtk_fixwindowmenu] \
	-tearoff $pd_tearoff]
match_linux_wm [list menu .mbar.audio -tearoff $pd_tearoff]
if {$pd_nt != 2} {
    .mbar add cascade -label "Windows" -menu .mbar.windows
    .mbar add cascade -label "Media" -menu .mbar.audio
    match_linux_wm [list menu .mbar.help -tearoff $pd_tearoff]
    .mbar add cascade -label "Help" -menu .mbar.help
} else {
    menu .mbar.apple -tearoff 0
    .mbar add cascade -label "Apple" -menu .mbar.apple 
    # arrange menus according to Apple HIG
    .mbar add cascade -label "Media" -menu .mbar.audio
    .mbar add cascade -label "Window" -menu .mbar.windows
    match_linux_wm [list menu .mbar.help -tearoff $pd_tearoff]
    .mbar add cascade -label "Help" -menu .mbar.help
}

# fix menu font size on Windows with tk scaling = 1
if {$pd_nt == 1} {
    .mbar.file configure -font menuFont
    .mbar.edit configure -font menuFont
    .mbar.find configure -font menuFont
    .mbar.windows configure -font menuFont
    .mbar.audio configure -font menuFont
    .mbar.help configure -font menuFont
}

proc showhide_printouttext {state} {
    if {$state} {
        #pack .printout -side bottom -fill both -expand 1
		#pack .controls.clr_console -pady 30
		wm deiconify .printout
		#wm resizable . 1 1
		#wm minsize . 460 194
    } else {
        #pack forget .printout
		wm withdraw .printout
		#pack forget .controls.clr_console
		#wm minsize . 0 0
		#wm geometry . 355x75
		#wm resizable . 0 0
    }
}

set ctrls_audio_on 0
set ctrls_meter_on 0
set ctrls_inlevel 0
set ctrls_outlevel 0
set show_text_window 0

match_linux_wm [list frame .controls]
#if { [info tclversion] >= 8.5 && $pd_nt == 0 } {
#	ttk::separator .eyecandy
#	pack .eyecandy .controls -fill x -expand 0
#} else {
pack .controls -fill x -expand 1
#}
match_linux_wm [list frame .controls.switches]
match_linux_wm [list checkbutton .controls.switches.audiobutton -text {compute audio  } \
    -variable ctrls_audio_on \
    -command {pd [concat pd dsp $ctrls_audio_on \;]}]

match_linux_wm [list checkbutton .controls.switches.meterbutton -text {peak meters  } \
    -variable ctrls_meter_on \
    -command {pd [concat pd meters $ctrls_meter_on \;]}]

match_linux_wm [list checkbutton .controls.switches.console -text "console" \
    -variable show_console \
    -command {showhide_printouttext $show_console}]

pack .controls.switches.audiobutton .controls.switches.meterbutton \
    .controls.switches.console -side top -anchor w

match_linux_wm [list frame .controls.inout]
match_linux_wm [list frame .controls.inout.in]
match_linux_wm [list label .controls.inout.in.label -text IN]
entry .controls.inout.in.level -textvariable ctrls_inlevel -width 3 \
	-highlightthickness 0 -takefocus 0 -state readonly -readonlybackground white
if { [info tclversion] >= 8.5 && $pd_nt == 0 } {
	match_linux_wm [list button .controls.inout.in.clip \
		-text {CLIP} -state disabled -style IOErrorOff.TButton -width 4]
} else {
	button .controls.inout.in.clip -text {CLIP} -state disabled
}

match_linux_wm [list frame .controls.inout.in.spacer]

pack .controls.inout.in.label .controls.inout.in.level \
    .controls.inout.in.clip .controls.inout.in.spacer -side top -pady 1

match_linux_wm [list frame .controls.inout.out]
match_linux_wm [list label .controls.inout.out.label -text OUT]
entry .controls.inout.out.level -textvariable ctrls_outlevel -width 3 \
	 -highlightthickness 0 -takefocus 0 -state readonly -readonlybackground white
if { [info tclversion] >= 8.5 && $pd_nt == 0 } {
	match_linux_wm [list button .controls.inout.out.clip \
		-text {CLIP} -state disabled -style IOErrorOff.TButton -width 4]
} else {
	button .controls.inout.out.clip -text {CLIP} -state disabled
}

match_linux_wm [list frame .controls.inout.out.spacer]

pack .controls.inout.out.label .controls.inout.out.level \
    .controls.inout.out.clip .controls.inout.out.spacer -side top -pady 1

if { [info tclversion] >= 8.5 && $pd_nt == 0 } {
	match_linux_wm [list ttk::button .controls.dio -text "\nIO Errors\n" \
		-command { if {![info exists show_console] || $show_console == 0} \
		{ menu_toggle_console; }; \
		pd [concat pd audiostatus \;]} \
		-width 8 -style IOErrorOff.TButton]
} else {
	button .controls.dio -text "DIO\nerrors" \
		-command { if {![info exists show_console] || $show_console == 0} \ 
		{ .controls.switches.console invoke; }; \
		pd [concat pd audiostatus \;]}
}

#match_linux_wm [list button .controls.clr_console -text "Clear Console" \
#	-command [concat menu_clear_console]]

pack .controls.inout.in .controls.inout.out -side left -padx 6
pack .controls.inout -side left -padx 14
pack .controls.switches -side right
pack .controls.dio -side right -padx 20

#if {[info exists show_console] && $show_console == 1} {
#	pack .controls.clr_console -pady 30
#}

toplevel .printout -class [winfo class .]
wm title .printout "Console"
# initial location of the console window (+x+y)
wm geometry .printout +10+170
# wm minsize .printout 460 194
wm protocol .printout WM_DELETE_WINDOW { .controls.switches.console invoke }
match_linux_wm [list frame .printout.frame]
text .printout.frame.text -relief sunken -bd 1 -font console_font \
    -yscrollcommand ".printout.frame.scroll set"  -width 70 -height 24 \
	-highlightthickness 0 -takefocus 0 -fg $pd_colors(text_in_console) \
    -state disabled -bg $pd_colors(canvas_color)
#.printout.frame.text tag configure sel -background $linux_wm_hlcolor

# .printout.frame.text insert end "\n\n\n\n\n\n\n\n\n\n"
match_linux_wm [list scrollbar .printout.frame.scroll -command ".printout.frame.text yview"]
match_linux_wm [list frame .printout.bar]
match_linux_wm [list button .printout.bar.clear -text "CLEAR" \
	-width 7 -command [concat menu_clear_console]]
match_linux_wm [list entry .printout.bar.entry \
	-textvariable send_textvariable]
bind .printout.bar.entry <KeyPress-Return> {
	pdtk_post "\nmessage-to-pd: $send_textvariable"
    pd [concat $send_textvariable \;]
}
#match_linux_wm [list button .printout.bar.x -text "x" \
#	-width 2 -command [concat .printout.bar.entry delete 0 end]]
match_linux_wm [list label .printout.bar.label -text "Send Message to Pd:"]

pack .printout.frame.scroll -side right -fill y
pack .printout.frame.text -side left -fill both -expand 1
pack .printout.bar -side bottom -fill x -expand 0
pack .printout.frame -fill both -expand 1
pack .printout.bar.clear -side left -padx 3 -pady 3
#pack .printout.bar.x -side right -padx 3 -pady 3
pack .printout.bar.entry -side right -fill both -expand 1 -padx 3 -pady 3
pack .printout.bar.label -side right -padx 3 -pady 3

# the console is open by default
#.controls.switches.console select
# in the case console should be turned off by default
wm withdraw .printout
#wm geometry .printout 1x1+0+0
#wm overrideredirect .printout 1
#wm transient .printout

bind .printout.frame.text <Button> {pdtk_update_root_edit_menu 0}
bind .printout.frame.text <<Selection>> {pdtk_update_root_edit_menu 1}
bind .printout <Control-Next> {menu_raisenextwindow}
bind .printout <Control-Prior> {menu_raisepreviouswindow} ;# needs Tcl/Tk 8.5
bind .printout <Control-w> { .controls.switches.console invoke }

proc pdtk_update_root_edit_menu {value} {
	#pdtk_post "update_root_edit_menu $value\n"
	if {$value} {
		set range [.printout.frame.text tag ranges sel]
		#pdtk_post "[lindex $range 0] -- [lindex $range 1]\n"
		if {[lindex $range 0] != [lindex $range 1]} {
			#.mbar.edit entryconfigure "Cut" -state normal
			.mbar.edit entryconfigure "Copy" -state normal
		}
	} else {
		#pdtk_post off
		#.mbar.edit entryconfigure "Cut" -state disabled
		.mbar.edit entryconfigure "Copy" -state disabled
	}
}

proc pdtk_post {stuff} {
	.printout.frame.text configure -state normal
    .printout.frame.text insert end $stuff
    after cancel .printout.frame.text yview end-2char
    after idle .printout.frame.text yview end-2char
	.printout.frame.text configure -state disabled
}

proc pderror_select_by_id {objectid} {
    if [llength $objectid] {
        pdsend "pd findinstance $objectid"
    }
}

# stopgap for ::pdwindow::logpost
proc pdtk_posterror {objectid loglevel errormsg} {
    set t .printout.frame.text
    $t configure -state normal
    # if we have an object id, make a friendly link...
    if {$objectid ne ""} {
        $t insert end "error" [list obj$objectid errorlink]
        $t tag bind obj$objectid <1> "pderror_select_by_id $objectid; break"
        $t tag bind obj$objectid <Enter> "$t configure -cursor hand2"
        $t tag bind obj$objectid <Leave> "$t configure -cursor xterm"
        $t tag configure errorlink -foreground "$::pd_colors(dash_outline)" \
            -underline on -background "$::pd_colors(dash_fill)"
    } else {
        $t insert end "error"
    }
    $t insert end ": "
    $t insert end $errormsg

    after cancel .printout.frame.text yview end-2char
    after idle .printout.frame.text yview end-2char
	.printout.frame.text configure -state disabled
}

proc pdtk_k12panel_standardkeybindings {id} {
    global pd_nt ctrl_key
    set names [split $id .]
    set name [concat .[lindex $names 1].c]
    bind $id <$ctrl_key-Key> "pdtk_canvas_ctrlkey $name %K 0"
	bind $id <$ctrl_key-Shift-Key> "pdtk_canvas_ctrlkey $name %K 1"
}

proc pdtk_standardkeybindings {id} {
    global pd_nt ctrl_key
    bind $id <$ctrl_key-Key> {pdtk_canvas_ctrlkey %W %K 0}
    bind $id <$ctrl_key-Shift-Key> {pdtk_canvas_ctrlkey %W %K 1}
}

proc pdtk_panelkeybindings {id panelname} {
    global pd_nt ctrl_key
    pdtk_standardkeybindings $id
    bind $id <KeyPress-Escape> [format "%s_cancel %s" $panelname $id]
    bind $id <KeyPress-Return> [format "%s_ok %s" $panelname $id]
    bind $id <$ctrl_key-Key-w> [format "%s_cancel %s" $panelname $id]
    bind $id <$ctrl_key-Key-x> [format "menu_cut %s" $id]
    bind $id <$ctrl_key-Key-c> [format "menu_copy %s" $id]
}

pdtk_standardkeybindings .
# hacks to add standard key bindings to the Pd window
bind . <$ctrl_key-Key-a> {.printout.frame.text tag add sel 1.0 end}
#bind . <$ctrl_key-Key-x> {tk_textCut .printout.frame.text; \
#	.mbar.edit entryconfigure "Paste" -state normal}
bind . <$ctrl_key-Key-c> {tk_textCopy .printout.frame.text}
bind .printout <$ctrl_key-Key-c> {tk_textCopy .printout.frame.text}
bind .printout <$ctrl_key-Key-a> {.printout.frame.text tag add sel 1.0 end}
#	.mbar.edit entryconfigure "Paste" -state normal}
#bind . <$ctrl_key-Key-v> {tk_textPaste .printout.frame.text}
bind . <$ctrl_key-Key-w> {menu_quit}
# kludge to add window control bindings to the Pd Window
if {$pd_nt == 2} {
	bind . <Mod1-quoteleft>  {menu_raisenextwindow}
} else {
	bind . <Control-Next>    {menu_raisenextwindow}
	bind . <Control-Prior>   {menu_raisepreviouswindow} ;# needs Tcl/Tk 8.5
}

# pass key presses inside main window to patch windows
proc pdtk_capture_root_window_keys {state key iso shift serial} {
	global menu_windowlist

	set first_patch_window_name [lindex $menu_windowlist 0 1]
	# pdtk_post "$first_patch_window_name\n"

	if { [string length $first_patch_window_name] > 0 } {
		pdtk_canvas_sendkey $first_patch_window_name.c $state $key $iso $shift 0 $serial
	}
}

bind . <Key> {pdtk_capture_root_window_keys 1 %K %A 0 %t}
bind . <Shift-Key> {pdtk_capture_root_window_keys 1 %K %A 1 %t}
bind . <KeyRelease> {pdtk_capture_root_window_keys 0 %K %A 0 %t}
bind . <Control-Key> {pdtk_canvas_ctrlkey %W %K 0}
bind . <Control-Shift-Key> {pdtk_canvas_ctrlkey %W %K 1}

bind .printout <Key> {pdtk_capture_root_window_keys 1 %K %A 0 %t}
bind .printout <Shift-Key> {pdtk_capture_root_window_keys 1 %K %A 1 %t}
bind .printout <KeyRelease> {pdtk_capture_root_window_keys 0 %K %A 0 %t}
bind .printout <Control-Key> {pdtk_canvas_ctrlkey %W %K 0}
bind .printout <Control-Shift-Key> {pdtk_canvas_ctrlkey %W %K 1}

wm title . "Pure-Data L2Ork"
# initial location of Pd window (+x+y)
wm geometry . +10+35
catch {
	set appicon [image create photo -format gif -file "$pd_guidir/pd-l2ork.gif"]
	wm iconphoto . -default $appicon
}
. configure -menu .mbar -width 200 -height 150
if { [info tclversion] >= 8.5 && $pd_nt == 0 } { wm resizable . 0 0 }
# Intercept closing the main pd window: MP 20060413:
wm protocol . WM_DELETE_WINDOW menu_quit
focus .
after idle {
	dnd bindtarget . text/uri-list <Drop> { foreach file %D {open_file $file} }
	dnd bindtarget .printout.frame text/uri-list <Drop> { foreach file %D {open_file $file} }
	dnd bindtarget .printout.bar text/uri-list <Drop> { foreach file %D {open_file $file} }
}


############### set up global variables ################################

set untitled_number 1
if {$pd_nt == 2} {
    set untitled_directory $::env(HOME)
} else {
    set untitled_directory [pwd]
}
set pd_opendir $untitled_directory
set pd_savedir $untitled_directory
#set pd_undoaction no
#set pd_redoaction no
#set pd_undocanvas no

################ utility functions #########################

# enquote a string to send it to a tcl function
proc pdtk_enquote {x} {
    set foo [string map {"," "" ";" "" \" ""} $x]
    set foo2 [string map {" " "\\ "} $foo]
    concat $foo2
}

interp alias {} chr {} format %c

#enquote a string to send it to Pd.  Blow off semi and comma; replace spaces with VT (ascii dec. 11)
#we also blow off "{", "}", "\" because they'll just cause bad trouble later.
proc pdtk_unspace {x} {
	set space [chr 11]
    set y [string map [list " " $space ";" "" "," "" "{" "" "}" "" "\\" ""] $x]
    if {$y == ""} {set y "empty"}
    concat $y
}

#enquote a string for preferences (command strings etc.)
proc pdtk_encodedialog {x} {
    concat +[string map {" " "+_" "$" "+d" ";" "+s" "," "+c" "+" "++"} $x]
}

proc pdtk_debug {x} {
    tk_messageBox -message $x -type ok
}

proc pdtk_watchdog {} {
    pd [concat pd watchdog \;]
    after 2000 {pdtk_watchdog}
}

proc pdtk_ping {} {
    pd [concat pd ping \;]
}

##### routine to ask user if OK and, if so, send a message on to Pd ######
proc pdtk_check {canvas x message default} {
    global pd_nt
	raise $canvas
	reset_ctrl_on_popup_window
    if {$pd_nt == 1} {
        set answer [tk_messageBox -message $x -type yesno -default $default \
            -icon question]
    } else {
        set answer [tk_messageBox -message $x -type yesno -default $default \
            -parent $canvas -icon question]
    }
    if {! [string compare $answer yes]}  {
		pd $message
		if {$canvas eq "."} {
			focus $canvas
		} else {
			menu_close $canvas
		}
	}
}

##### ask user Save? Discard? Cancel?, and if so, send a message on to Pd ######
proc pdtk_canvas_menuclose {window reply} {
	global pd_nt
	raise $window
	reset_ctrl_on_popup_window
	set filename [wm title $window]
	set message [format {Do you wish to save the changes you made in "%s"?} $filename]
	set answer [tk_messageBox -message $message -type yesnocancel -default "yes" \
					-parent $window -icon question]
	switch -- $answer {
		yes {
			pd [concat $window menusave \;]
			#when quitting the application sometimes the save menu fails to show up
			#after 250 pd $reply
			#pd $reply
		}
		no {
			pd [concat $window dirty 0 \;]
			pd $reply
		}
		cancel {}
	}
}

proc pdtk_fixfilemenu {name} {
	::pd_menus::update_recentfiles_menu $name false
}

set menu_windowlist {} 

proc pdtk_fixwindowmenu {} {
    global menu_windowlist pd_nt k12_mode
	if { $k12_mode == 0 } {
		.mbar.windows delete 0 end
		if {$pd_nt == 2} {
			.mbar.windows add command -label {Minimize} -command {menu_minimize .} \
				-accelerator [accel_munge "Ctrl+m"]
			.mbar.windows add command -label {Zoom} -command {menu_zoom .}
		} else {
			.mbar.windows add command -label "Next Window" -command {menu_raisenextwindow} \
				-accelerator "Ctrl+PageDown"
			.mbar.windows add command -label "Previous Window" -command {menu_raisepreviouswindow} \
				-accelerator "Ctrl+PageUp"
		}
		match_linux_wm [list .mbar.windows add separator]
		.mbar.windows add command -label {parent window} -state disabled
		.mbar.windows add command -label {Pd & Console} -command menu_raise_console \
			-accelerator [accel_munge "Ctrl+;"] -state disabled
		match_linux_wm [list .mbar.windows add separator]
		foreach i $menu_windowlist {
		    .mbar.windows add command -label [lindex $i 0] \
		        -command [concat menu_domenuwindow [lindex $i 1]]
		    menu_fixwindowmenu [lindex $i 1]
		}
	}
}

####### Odd little function to make better Mac accelerators #####

proc accel_munge {acc} {
    global pd_nt

    if {$pd_nt == 2} {
        if [string is upper [string index $acc end]] {
            return [format "%s%s" "Shift+" \
                        [string toupper [string map {Ctrl Meta} $acc] end]]
        } else {
            return [string toupper [string map {Ctrl Meta} $acc] end]
        }
    } else {
        return $acc
    }
}



###############  the "New" menu command  ########################
proc menu_new {} {
    global untitled_number
    global untitled_directory
	global k12_mode
	global k12_saveas_on_new
    if { ! [file isdirectory $untitled_directory]} {set untitled_directory $::env(HOME)}
    pd [concat pd filename Untitled-$untitled_number \
			[pdtk_enquote $untitled_directory] \;]
	if { $k12_mode == 1 } {
		set k12_saveas_on_new 1
		pd {
		    #N canvas;
			#X obj -30 -30 preset_hub k12 1 %hidden%;
		    #X pop 1;
		}
	} else {
		pd {
		    #N canvas;
		    #X pop 1;
		}
	}
    set untitled_number [expr $untitled_number + 1]
}

############## the helper command for buggy popups #################
# this is an ugly workaround that should go away

proc reset_ctrl_on_popup_window {} {
	global menu_windowlist
	set first_patch_window_name [lindex $menu_windowlist 0 1]
	if { $first_patch_window_name != "" } {
		pdtk_canvas_sendkey $first_patch_window_name.c 0 Control_L null 0 1 -1
		pdtk_canvas_sendkey $first_patch_window_name.c 0 Control_R null 0 1 -1
	}
}

################## the "Open" menu command #########################

proc menu_open {} {
    global pd_opendir filetypes
    if { ! [file isdirectory $pd_opendir]} {set pd_opendir $::env(HOME)}
    set files [tk_getOpenFile -defaultextension .pd \
					  -multiple true \
                      -filetypes $filetypes -initialdir $pd_opendir]
    reset_ctrl_on_popup_window
    if {$files != ""} {
		foreach filename $files {
			open_file $filename
		}
	}
}

proc menu_k12_open_demos {} {
	global pd_guidir filetypes
	if { ! [file isdirectory $pd_guidir/extra/K12/demos]} {
		set files [tk_getOpenFile -defaultextension .pd \
						  -multiple true \
		                  -filetypes $filetypes -initialdir $pd_guidir/extra/]
	} else {
		set files [tk_getOpenFile -defaultextension .pd \
						  -multiple true \
		                  -filetypes $filetypes -initialdir $pd_guidir/extra/K12/demos]
	}
    if {$files != ""} {
		foreach filename $files {
			open_file $filename
		}
	}	
}

proc pdtk_set_current_dir {path_and_filename} {
	global pd_opendir untitled_directory
	set directory [file dirname $path_and_filename]
	set pd_opendir $directory
	set untitled_directory $directory
}

proc open_file {filename} {
    global pd_opendir pd_guidir pd_nt
	#puts stderr open_file
	set directory [file dirname $filename]
	set basename [file tail $filename]
    if {[regexp -nocase -- "\.(pat|mxb|help)$" $basename]} {
		puts stderr "converting $filename"
		if {$pd_nt == 0} { 
			# on GNU/Linux, cyclist is installed into /usr/bin usually
			set cyclist "/usr/bin/cyclist" 
		} else {
			set cyclist "$pd_guidir/bin/cyclist"
		}
		puts stderr "$cyclist '$filename'"
		# convert Max binary to text .pat
		set binport [open "| \"$cyclist\" \"$filename\""]
		set convertedtext [read $binport]
		if { ! [catch {close $binport} err]} {
			if {! [file writable $directory]} {	set directory "/tmp" }
			set basename "$basename.pat"
			set textpatfile [open "$directory/$basename" w]
			puts $textpatfile $convertedtext
			close $textpatfile
			puts stderr "converted Max binary to text format: $directory/$basename"
		}
	}
    if {[regexp -nocase -- "\.(pd|pat|mxt)$" $basename]} {
        pd "pd open [pdtk_enquote $basename] [pdtk_enquote $directory] ;"
        set pd_opendir $directory
        ::pd_guiprefs::update_recentfiles "$filename" 1
    }
}

################## the "Message" menu command #########################
proc menu_send {} {
    global pd_nt ctrl_key
    reset_ctrl_on_popup_window
    if { [winfo exists .sendpanel.entry] } {
        raise .sendpanel
    } else {
		toplevel .sendpanel -class [winfo class .]
		wm title .sendpanel {Send Message to Pd}
		wm resizable .sendpanel 0 0
		match_linux_wm [list .sendpanel configure]
		pdtk_standardkeybindings .sendpanel
		match_linux_wm [list entry .sendpanel.entry \
			-textvariable send_textvariable]
		pack .sendpanel.entry -side bottom -fill both -ipadx 100 -padx 3 -pady 5
		if { [info tclversion] < 8.5 } {
			.sendpanel.entry select from 0
			.sendpanel.entry select adjust end
		}
		bind .sendpanel <$ctrl_key-Key-w> {destroy .sendpanel}
		bind .sendpanel <KeyPress-Escape> {destroy .sendpanel}
		bind .sendpanel.entry <KeyPress-Return> {
			pdtk_post "\nmessage-to-pd: $send_textvariable"
		    pd [concat $send_textvariable \;]
		}
		focus .sendpanel.entry
	}
}


################## menu commands for Mac OS X #########################

proc menu_minimize {window} {
	if {$window eq ""} { #Pd Window
		wm iconify [winfo toplevel .printout]
	} else {
		wm iconify [winfo toplevel $window]
	}
}

proc menu_zoom {window} {
	wm state $window zoomed
}

proc menu_raisenextwindow {} {
	set target [lindex [wm stackorder .] 0]
	raise $target
	if { [winfo exists $target.c] } {
		focus $target.c
	} else {
		focus $target
	}
}

# lreverse came along in Tcl 8.5
proc menu_raisepreviouswindow {} {
	set last [lindex [wm stackorder .] end]
	set all [wm stackorder .]
	foreach i $all {
		if { $i != $last } { 
			raise [lindex $i]
			set target $i
		} else {
			if { [winfo exists $target.c] } {
				focus $target.c
			} else {
				focus $target
			}
		}
	}
}

################## menu commands for console #########################

proc menu_raise_console {} {
	set pd_window .
	set top_window [lindex [wm stackorder $pd_window] end]
	focus .
	if {$pd_window eq $top_window} {
		lower $pd_window
		.controls.switches.console instate {selected} {
			lower .printout
		}
		#catch {lower .printout}
	} else {
		wm deiconify $pd_window
		raise $pd_window
		.controls.switches.console instate {selected} {
			wm deiconify .printout
			wm manage .printout
			raise .printout
			#focus .printout
		}
		#catch {wm deiconify .printout}
		#catch {wm manage .prinout}
		#raise .printout
	}
}

proc menu_toggle_console {} { .controls.switches.console invoke }

proc menu_clear_console {} {.printout.frame.text configure -state normal; .printout.frame.text delete 0.0 end; .printout.frame.text configure -state disabled}

################## the "Quit" menu command #########################
proc menu_really_quit {} {pd {pd quit;}}

proc menu_quit {} {pd {pd verifyquit;}}

######### the "audio" menu command  ###############
proc menu_audio {flag} {pd [concat pd dsp $flag \;]}

######### the "reselect" menu command ################
proc menu_reselect {name} {pd [concat $name reselect \;]}

######### the "documentation" menu command  ###############

set doc_number 1

# open text docs in a Pd window
proc menu_opentext {filename} {
    global doc_number
    global pd_guidir
    global pd_myversion
	global ctrl_key
    if { [winfo exists .about.text] } {
        raise .about
    } else {
		destroy .about
		toplevel .about -class [winfo class .]
		wm title .about "Text Viewer"
		wm geometry .about 550x480
		match_linux_wm [list text .about.text -relief sunken -bd 1 -font text_font \
		    -yscrollcommand ".about.scroll set" -highlightthickness 0 -takefocus 0]
		match_linux_wm [list scrollbar .about.scroll -command ".about.text yview"]
		pack .about.scroll -side right -fill y
		pack .about.text -side left -fill both -expand 1
		bind .about <$ctrl_key-Key-w> [concat destroy .about set doc_number [expr $doc_number - 1]]
		
		set f [open $filename]
		while {![eof $f]} {
		    set bigstring [read $f 1000]
		    regsub -all PD_BASEDIR $bigstring $pd_guidir bigstring2
		    regsub -all PD_VERSION $bigstring2 $pd_myversion bigstring3
		    .about.text insert end $bigstring3
		}
		close $f
	}
}

# open HTML docs from the menu using the OS-default HTML viewer
proc menu_openhtml {filename} {
    global pd_nt         

    if {$pd_nt == 0} {
        foreach candidate \
            { gnome-open xdg-open sensible-browser iceweasel firefox mozilla \
                  galeon konqueror netscape lynx } {
                      set browser [lindex [auto_execok $candidate] 0]
                      if {[string length $browser]} {
                          puts stderr [format "%s '%s'" $browser $filename]
                          exec -- sh -c [format "%s '%s'" $browser $filename] &
                          break
                      }
                  }
    } elseif {$pd_nt == 2} {
        puts stderr [format "open '%s'" $filename]
        exec sh -c [format "open '%s'" $filename]
    } else {
        exec rundll32 url.dll,FileProtocolHandler \
            [format "%s" $filename] &
    }
}

proc menu_openpdpedia {} {
	set top_window [lindex [wm stackorder .] end]
	set window_title [wm title $top_window]
	set helpfile [regsub -- {(.*)-help.*} $window_title {\1}]
	if {$helpfile eq $window_title} {
		menu_openhtml "http://wiki.puredata.info/"
	} else {
		menu_openhtml "http://wiki.puredata.info/en/$helpfile"
	}
}

proc menu_doc_open {dir basename} {
    global pd_guidir
    
    if {[file pathtype $dir] eq "relative"} {
        set dirname "$pd_guidir/$dir"
    } else {
        set dirname $dir
    }

    if {[file isdirectory [file join $dirname $basename]]} {
        menu_openhtml $dirname/$basename
    } elseif {[regexp -nocase -- ".*\.(txt|c)$" $basename]} {
        menu_opentext $dirname/$basename
    } elseif {[regexp -nocase -- ".*\.(htm|html|pdf)$" $basename]} {
        menu_openhtml $dirname/$basename
    } else {
        set fullpath [file normalize [file join $dirname $basename]]
        set dirname [file dirname $fullpath]
        set basename [file tail $fullpath]
        pd [concat pd open [pdtk_enquote $basename] \
                [pdtk_enquote $dirname] \;]
    }
}

# backported from pd
# ------------------------------------------------------------------------------
# opening docs as menu items (like the Test Audio and MIDI patch and the manual)
#package provide pd_menucommands 0.1
#
#namespace eval ::pd_menucommands:: {
#    variable untitled_number "1"
#
#    namespace export menu_*
#}

# TODO enquote a filename to send it to pd, " isn't handled properly tho...
#proc enquote_path {message} {
#    string map {"," "\\," ";" "\\;" " " "\\ "} $message
#}

#proc ::menu_doc_open {dir basename} {
#    if {[file pathtype $dir] eq "relative"} {
#        set dirname "$::sys_libdir/$dir"
#    } else {
#        set dirname $dir
#    }
#    set textextension "[string tolower [file extension $basename]]"
#    if {[lsearch -exact [lindex $::filetypes 0 1]  $textextension] > -1} {
#        set fullpath [file normalize [file join $dirname $basename]]
#        set dirname [file dirname $fullpath]
#        set basename [file tail $fullpath]
#        pdsend "pd open [enquote_path $basename] [enquote_path $dirname]"
#    } else {
#        ::menu_openfile "$dirname/$basename"
#    }
#}

# open HTML docs from the menu using the OS-default HTML viewer
proc ::menu_openfile {filename} {
    if {$::tcl_platform(os) eq "Darwin"} {
        exec sh -c [format "open '%s'" $filename]
    } elseif {$::tcl_platform(platform) eq "windows"} {
        exec rundll32 url.dll,FileProtocolHandler [format "%s" $filename] &
    } else {
        foreach candidate { gnome-open xdg-open sensible-browser iceweasel firefox \
                                mozilla galeon konqueror netscape lynx } {
            set browser [lindex [auto_execok $candidate] 0]
            if {[string length $browser] != 0} {
                exec -- sh -c [format "%s '%s'" $browser $filename] &
                break
            }
        }
    }
}

############# routine to add media, help, and apple menu items ###############

proc menu_addstd {mbar} {
    global pd_apilist pd_midiapilist pd_nt pd_tearoff
    #          the "Audio" menu
    $mbar.audio add command -label {Audio ON} -accelerator [accel_munge "Ctrl+/"] \
        -command {menu_audio 1} 
    $mbar.audio add command -label {Audio OFF} -accelerator [accel_munge "Ctrl+."] \
        -command {menu_audio 0} 
	# match_linux_wm [list $mbar.audio add separator]
	# $mbar.audio add command -label {Audio Settings} -state disabled
    # for {set x 1} {$x<[llength $pd_apilist]} {incr x} {
        # $mbar.audio add radiobutton -label [concat [lindex [lindex $pd_apilist $x] 0] Driver] \
            # -command {menu_audio 0} -variable pd_whichapi \
            # -value [lindex [lindex $pd_apilist $x] 1]\
			# -selectcolor "#dddddd" \
            # -command {pd [concat pd audio-setapi $pd_whichapi \;]}
    # }
	# match_linux_wm [list $mbar.audio add separator]
	# $mbar.audio add command -label {MIDI Settings} -state disabled
    # for {set x 0} {$x<[llength $pd_midiapilist]} {incr x} {
        # $mbar.audio add radiobutton -label [concat [lindex [lindex $pd_midiapilist $x] 0] Driver]\
            # -command {menu_midi 0} -variable pd_whichmidiapi \
            # -value [lindex [lindex $pd_midiapilist $x] 1]\
			# -selectcolor "#dddddd" \
            # -command {pd [concat pd midi-setapi $pd_whichmidiapi \;]}
    # }
    #if {$pd_nt != 2} {
	#	$mbar.audio add separator
    #    $mbar.audio add command -label {Audio settings...} \
    #        -command {pd pd audio-properties \;}
    #    $mbar.audio add command -label {MIDI settings...} \
    #        -command {pd pd midi-properties \;}
    #}
	match_linux_wm [list $mbar.audio add separator] 
    $mbar.audio add command -label {Test Audio and MIDI} \
        -command {menu_doc_open doc/7.stuff/tools testtone.pd} 
    $mbar.audio add command -label {Load Meter} \
        -command {menu_doc_open doc/7.stuff/tools load-meter.pd} 

    #       the MacOS X app menu

    # The menu on the main menubar named $whatever.apple while be treated
    # as a special menu on MacOS X.  Tcl/Tk assigns the $whatever.apple menu
    # to the app-specific menu in MacOS X that is named after the app,
    # so in our case, the Pd menu.  <hans@at.or.at>
    # See SPECIAL MENUS IN MENUBARS http://www.tcl.tk/man/tcl8.4/TkCmd/menu.htm
    if {$pd_nt == 2} {
        $mbar.apple add command -label "About Pd..." -command \
            {menu_doc_open doc/1.manual 1.introduction.txt} 
        menu $mbar.apple.preferences -tearoff 0
        $mbar.apple add cascade -label "Preferences" -menu $mbar.apple.preferences
        $mbar.apple.preferences add command -label "Path..." \
            -command {pd pd start-path-dialog \;}
        $mbar.apple.preferences add command -label "Startup..." \
            -command {pd pd start-startup-dialog \;}
        $mbar.apple.preferences add command -label "Audio Settings..." \
            -command {pd pd audio-properties \;}
        $mbar.apple.preferences add command -label "MIDI settings..." \
            -command {pd pd midi-properties \;}
    }


    # the "Help" menu
    if {$pd_nt != 2} {
        $mbar.help add command -label {About Pd-L2Ork} \
            -command {menu_doc_open doc/1.manual 1.introduction.txt} 
    }
    $mbar.help add command -label {Manual} \
        -command {menu_doc_open doc/1.manual index.htm} 
    $mbar.help add command -label {Browser} \
        -accelerator [accel_munge "Ctrl+b"] \
        -command {::dialog_search::open_helpbrowser .search}
    match_linux_wm [list $mbar.help add separator]
    #$mbar.help add command -label {puredata.info} \
    #    -command {menu_openhtml http://puredata.info} 
    #$mbar.help add command -label {Pdpedia} \
    #    -command {menu_openpdpedia} 
    #$mbar.help add command -label {FAQ} \
    #    -command {menu_openhtml http://puredata.info/docs/faq} 
    #$mbar.help add separator
    $mbar.help add command -label {Pd-L2Ork mailing list} \
        -command {menu_openhtml http://disis.music.vt.edu/listinfo/l2ork-dev} 
    $mbar.help add command -label {Pure-Data mailing lists} \
        -command {menu_openhtml http://puredata.info/community/lists} 
    $mbar.help add command -label {Forums} \
        -command {menu_openhtml http://forum.pdpatchrepo.info/} 
    $mbar.help add command -label {IRC chat} \
        -command {menu_openhtml irc://irc.freenode.net/dataflow} 
    #$mbar.help add separator
	#$mbar.help add command -label {report bug} -command \
	#	{menu_openhtml {http://sourceforge.net/tracker/?func=add&group_id=55736&atid=478070}} 
}

#################### the "File" menu for the Pd window ##############

.mbar.file add command -label New -command {menu_new} \
    -accelerator [accel_munge "Ctrl+n"]
.mbar.file add command -label Open -command {menu_open} \
    -accelerator [accel_munge "Ctrl+o"]
match_linux_wm [list .mbar.file add separator]
.mbar.file add command -label Save -accelerator [accel_munge "Ctrl+s"] \
	-state disabled
.mbar.file add command -label "Save as..." -accelerator [accel_munge "Ctrl+S"] \
	-state disabled
match_linux_wm [list .mbar.file add separator]
if {$pd_nt != 2} {
	.mbar.file add command -label "Message..." -command {menu_send} \
		-accelerator [accel_munge "Ctrl+m"]
	# On MacOS X, follow the standard Human Interface Guidelines
	# i.e. the Preferences menu under "Pd"
	match_linux_wm [list .mbar.file add  separator]
    .mbar.file add command -label Path... \
        -command {pd pd start-path-dialog \;}
    .mbar.file add command -label Startup... \
        -command {pd pd start-startup-dialog \;}
} else { # Mac OS X
	# Cmd-m is minimize window on Mac OS X, so remove binding
	.mbar.file add command -label "Message..." -command {menu_send}
	match_linux_wm [list .mbar.file add  separator]
	.mbar.file add command -label "Make app from patch..." -state disabled
	.mbar.file add command -label "Make app from folder..." -state disabled
}
match_linux_wm [list .mbar.file add  separator]
.mbar.file add command -label "Print..." -accelerator [accel_munge "Ctrl+p"] \
	-state disabled

# update recent files
match_linux_wm [list .mbar.file add separator]
.mbar.file add command -label "No Recent Files" -state disabled
#if {[llength $::recentfiles_list] > 0} {
#    ::pd_menus::update_recentfiles_menu .mbar.file false
#}

match_linux_wm [list .mbar.file add separator]
.mbar.file add command -label Close -accelerator [accel_munge "Ctrl+w"] \
	-state disabled

if {$pd_nt != 2} {
	# Mac OS X doesn't put Quit on the File menu
	.mbar.file add command -label Quit -command {menu_quit} \
	    -accelerator [accel_munge "Ctrl+q"]
}

#################### the "Edit" menu for the Pd window ##############
# this is mostly a placeholder
.mbar.edit add command -label Undo -accelerator [accel_munge "Ctrl+z"] \
    -state disabled
.mbar.edit add command -label Redo -accelerator [accel_munge "Ctrl+Z"] \
    -state disabled
match_linux_wm [list .mbar.edit add separator]
# this should apply to .printout.frame.text
.mbar.edit add command -label Cut  -accelerator [accel_munge "Ctrl+x"] \
    -command {tk_textCut .printout.frame.text} -state disabled
# this should apply to .printout.frame.text
.mbar.edit add command -label Copy -accelerator [accel_munge "Ctrl+c"] \
    -command {global copytexttocanvas; tk_textCopy .printout.frame.text; set copytexttocanvas 1; pdtk_canvas_update_paste_menu 1} -state disabled
.mbar.edit add command -label Paste -accelerator [accel_munge "Ctrl+v"] \
    -command {tk_textPaste .printout.frame.text} -state disabled
.mbar.edit add command -label Duplicate -accelerator [accel_munge "Ctrl+d"] \
    -state disabled
# this should apply to .printout.frame.text
.mbar.edit add command -label {Select all in console} -accelerator [accel_munge "Ctrl+a"]\
    -command {.printout.frame.text tag add sel 1.0 end}
.mbar.edit add command -label {Reselect} \
        -accelerator "Ctrl+Enter" -state disabled
match_linux_wm [list .mbar.edit add separator]
.mbar.edit add command -label {Tidy Up} -accelerator [accel_munge "Ctrl+y"] -state disabled

.mbar.edit add command -label {Bring To Front} \
        -accelerator [accel_munge "Ctrl+Up"] \
		-state disabled

.mbar.edit add command -label {Send To Back} \
        -accelerator [accel_munge "Ctrl+Down"] \
		-state disabled

match_linux_wm [list .mbar.edit add separator]
#	.mbar.edit add command -label {Text Editor} -state disabled
#if {$pd_nt == 2} { # no key command for Mac OS X
#} else {
#	.mbar.edit add command -label {Text Editor} -accelerator "Ctrl+t" \
#	-state disabled
#}
.mbar.edit add command -label Font -state disabled

.mbar.edit add checkbutton -label {Cord Inspector} \
    -indicatoron false -selectcolor black \
    -state disabled \
    -accelerator [accel_munge "Ctrl+r"]

match_linux_wm [list .mbar.edit add separator]

.mbar.edit add command -label "Toggle console" \
	-accelerator [accel_munge "Ctrl+R"] -command menu_toggle_console
.mbar.edit add command -label "Clear console" \
    -accelerator [accel_munge "Ctrl+L"] -command menu_clear_console
match_linux_wm [list .mbar.edit add separator]
# this should apply to .printout.frame.text
.mbar.edit add command -label {Find...} -accelerator [accel_munge "Ctrl+f"] \
    -state disabled
# this should apply to .printout.frame.text
.mbar.edit add command -label {Find Again} -accelerator [accel_munge "Ctrl+g"] \
    -state disabled
.mbar.edit add command -label {Find last error}
match_linux_wm [list .mbar.edit add separator]
.mbar.edit add checkbutton -label "Autotips" \
        -indicatoron false -selectcolor black \
        -accelerator [accel_munge "Ctrl+E"] \
    	-state disabled
.mbar.edit add command -label {Edit mode} -accelerator [accel_munge "Ctrl+e"] \
    -state disabled
match_linux_wm [list .mbar.edit add separator]
.mbar.edit add command -label {Preferences...} \
    -command {::dialog_prefs::open_prefs_dialog .}

#################### the "Find" menu for the Pd window ##############

#.mbar.find add command -label {Find...} -accelerator [accel_munge "Ctrl+f"] \
#    -state disabled
#.mbar.find add command -label {Find Again} -accelerator [accel_munge "Ctrl+g"] \
#    -state disabled
#.mbar.find add command -label {Find last error} -command {menu_finderror} 


#######  functions for embedding a patch into a standalone Mac OS X app #######

proc makeapp_promptreplace {appdir} {
	if {[file exists $appdir]} {
		set answer [tk_messageBox -message [concat overwrite $appdir "?"] \
						-type yesno -icon question]
		return [string equal $answer "yes"]
	} else {
		return 1
	}
}

proc makeapp_createapp {appdir} {
	global pd_guidir
	set pdapp_contents [file normalize "$pd_guidir/.."]
	pdtk_post "Copying:$pdapp_contents\n  -->\t$appdir/\n"
	catch {
		exec -- chmod -R u+w $appdir
		file delete -force -- $appdir
	}
	file mkdir $appdir
	file copy -- $pdapp_contents "$appdir/"
	file rename -force -- $appdir/Contents/org.puredata.pdl2ork.default.plist \
		$appdir/Contents/org.puredata.pdl2ork.plist
}

proc makeapp_makeinfoplist {appdir} {
	regexp {.*/(.+)\.app} $appdir -> appname
	pdtk_post "Setting up $appdir/Contents/Info.plist\n"
	set info_plist [open "$appdir/Contents/Info.plist" r]
	set info_plist_contents [read $info_plist]
	regsub -- {CFBundleName</key>.*?<string>Pd-.*extended.*<} $info_plist_contents \
		"CFBundleName</key>\n\t<string>$appname<" info_plist_contents
	set cfbundleversion [clock format [clock seconds] -format %Y.%m.%d]
	regsub -- {CFBundleVersion</key>.*?<string>.*?<} $info_plist_contents \
		"CFBundleVersion</key>\n\t<string>$cfbundleversion<" info_plist_contents
	regsub -- {org.puredata.pd.wish} $info_plist_contents \
		"org.puredata.pd.app.$appname" info_plist_contents
	regsub -- {<key>CFBundleDocumentTypes.+?</array>.+?</array>} \
		$info_plist_contents {} info_plist_contents
	regsub -- {<key>UTExportedTypeDeclarations.+</array>} $info_plist_contents \
		{} info_plist_contents
	close $info_plist
	set info_plist [open "$appdir/Contents/Info.plist" w]
	puts $info_plist $info_plist_contents
	close $info_plist		
}

proc makeapp_copycurrentpatch {appdir patch patchname isdir} {
	if {$isdir} {
		pdtk_post [format "Copying:%s\n  -->\t$appdir/Contents/Resources/extra/\n" \
					   [file dirname $patch]]
		file copy -- [file dirname $patch] "$appdir/Contents/Resources/extra/"
	} else {
		set embedded_patch "$appdir/Contents/Resources/extra/$patchname/$patchname.pd"
		pdtk_post "Copying:$patch\n  -->\t$embedded_patch\n"
		file mkdir "$appdir/Contents/Resources/extra/$patchname"
		file copy -- $patch $embedded_patch
	}
}

proc makeapp_getpatchname {top_window} {
	set top_window_path [wm attributes $top_window -titlepath]
	if {$top_window_path != ""} {
		return $top_window_path
	} else {
		return ""
	}
}

proc makeapp_embedprefs {appdir patch_to_open} {
	pdtk_post "Setting up $appdir/Contents/org.puredata.pdl2ork.plist\n"
	set plist [open "$appdir/Contents/org.puredata.pdl2ork.plist" r]
	set new_plist [read $plist]
	close $plist
	regsub -- {flags</key>.*?<string>.*?<} $new_plist \
		"flags</key>\n\t<string>-open hcs/embed.pd -open $patch_to_open<" new_plist
	set plist [open "$appdir/Contents/org.puredata.pdl2ork.plist" w]
	puts $plist $new_plist
	close $plist		

}

proc makeapp_busypanel {appdir} {
	toplevel .makeapp -class [winfo class .]
	wm title .makeapp "Making App"
	wm attributes .makeapp -topmost 1
	wm resizable .makeapp 0 0
	label .makeapp.label -text "Making App... in $appdir..."
	pack .makeapp.label -side top -fill both -ipadx 200 -ipady 100
}

###########  functions for menu functions on document windows ########

proc menu_makeapp {isdir} {
	set top_window [lindex [wm stackorder .] end]
	menu_windowparent $top_window
	set patch [makeapp_getpatchname $top_window]
	if {$patch == ""} {
		pdtk_post \
			"No patch found! Select an open parent patch with the mouse, then try again.\n"
		return
	}
	# TODO set -parent to patch being turned into app
	pdtk_post "Select name for app to build...\n"
	set appdir [tk_getSaveFile -filetypes { {{Mac OS X Application} {.app}} } \
				   -parent $top_window -defaultextension .app \
				   -title "Save application to..."]
	if {$appdir != ""} {
		if {![string match "*.app" $appdir]} {
			set appdir "$appdir.app"
#			pdtk_post "Adding .app extension: $appdir\n"
		}
		if {[makeapp_promptreplace $appdir]} {
			makeapp_busypanel $appdir
			makeapp_createapp $appdir
			.makeapp.label configure -text "Configuring Info.plist..."
			makeapp_makeinfoplist $appdir
			.makeapp.label configure -text "Setting patch name..."
			regexp {.*/(.*?)\.pd} $patch -> patchname
			.makeapp.label configure -text "Copying current patch..."
			makeapp_copycurrentpatch $appdir $patch $patchname $isdir
			.makeapp.label configure -text "Setting embedded preferences..."
			makeapp_embedprefs $appdir "$patchname/$patchname.pd"
			pdtk_post "$appdir is complete!\n"
			destroy .makeapp
		}
	}
}

proc menu_save {name} {
    pdtk_canvas_checkgeometry $name
    pd [concat $name menusave \;]
}

proc menu_saveas {name} {
    pdtk_canvas_checkgeometry $name
    pd [concat $name menusaveas \;]
}

proc menu_print {name} {
    set filename [tk_getSaveFile -initialfile pd.ps \
                      -defaultextension .ps \
                      -filetypes { {{postscript} {.ps}} }]

    if {$filename != ""} {
        $name.c postscript -file $filename
    }
}

proc menu_close {name} {
	#puts stderr menu_close
	if {$name == ".texteditor.text"} { 
		set topname [string trimright $name .text]
		texteditor_send $name
		destroy $topname
		focus . 
	} else {
		menu_windowparent $name
		pdtk_canvas_checkgeometry $name
    	pd [concat $name menuclose 0 \;]
	}
}

proc menu_really_close {name} {
    pdtk_canvas_checkgeometry $name
    pd [concat $name menuclose 1 \;]
}

proc menu_undo {name} {
	#puts stderr "menu_undo $name\n"
    #global pd_undoaction
    #global pd_redoaction
    #global pd_undocanvas
    if {$::undo($name) != "no"} {
        pd [concat $name undo \;]
    }
}

proc menu_redo {name} {
	#puts stderr "menu_redo $name\n"
    #global pd_undoaction
    #global pd_redoaction
    #global pd_undocanvas
    if {$::redo($name) != "no"} {
        pd [concat $name redo \;]
    }
}

proc menu_cut {name} {
	#puts stderr "menu_cut $name"
	global copytexttocanvas
	if {![string match .gfxstub* $name] && ![string match .printout* $name] && ![string match *entry $name]} {
		pd [concat $name cut \;]
		#pdtk_canvas_getscroll $name.c
		set copytexttocanvas 0
		clipboard clear
	} else {
		set copytexttocanvas 1
		pd [concat pd clipboardtext  1 \;]
	}
	pdtk_canvas_update_paste_menu 1
}

proc menu_copy {name} {
	#puts stderr menu_copy
	global copytexttocanvas
	if {![string match .gfxstub* $name] && ![string match .printout* $name] && ![string match *entry $name]} {
	    pd [concat $name copy \;]
		set copytexttocanvas 0
		clipboard clear
	} else {
		# pdtk_post "this_is_text\n"
		set clipboardtext 1
		pd [concat pd clipboardtext 1 \;]
	}
	pdtk_canvas_update_paste_menu 1
}

proc menu_paste {name} {
	global copytexttocanvas
	# pdtk_pastetext
	# pdtk_post "pasting..."
	if {![string match .gfxstub* $name] && ![string match .printout* $name] && ![string match *entry $name]} {
		# puts stderr "this is not an entry $copytexttocanvas\n"
		# if {$copytexttocanvas} {
		#	pdtk_pastetext
		#} else {
			pd [concat $name paste \;]
			#pdtk_canvas_getscroll $name.c
		#}
	} else {
		# puts stderr "pasting text..."
		pdtk_pastetext
	}
}

#bind . <$ctrl_key-Key-x> {menu_cut .printout.frame.text}
bind . <$ctrl_key-Key-c> {global copytexttocanvas; tk_textCopy .printout.frame.text; set copytexttocanvas 1; pdtk_canvas_update_paste_menu 1}
#bind . <$ctrl_key-Key-v> {menu_paste .printout.frame.text}

proc menu_duplicate {name} {
    pd [concat $name duplicate \;]
	#pdtk_canvas_getscroll $name.c
}

proc menu_selectall {name} {
	if {![string match .gfxstub* $name] && ![string match *ent* $name]} {
    	pd [concat $name selectall \;]
	} else {
		if { [string match *ent* $name] } {
			$name selection range 0 end
		}
	}
}

proc menu_texteditor {name} {
	reset_ctrl_on_popup_window
    pd [concat $name texteditor \;]
}

proc menu_font {name} {
	reset_ctrl_on_popup_window
    pd [concat $name menufont \;]
}

proc menu_tidyup {name} {
	if {[string compare $name .c]} {
		set name [string trimright $name .c]
	}
    pd [concat $name tidy \;]
}

## jsarlo
proc menu_magicglass {name} {
    pd [concat $name magicglass 0 \;]
}
## end jsarlo

proc menu_editmode {name} {
	global k12_mode
    pd [concat $name editmode 0 \;]
	#if { $k12_mode == 1 } { menu_tooltips $name }
}

proc menu_tooltips {name} {
	pd [concat $name tooltips 0 \;]
}

proc menu_object {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name obj $accel \;]
}

proc menu_message {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name msg $accel \;]
}

proc menu_floatatom {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name floatatom $accel \;]
}

proc menu_symbolatom {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name symbolatom $accel \;]
}

proc menu_comment {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name text $accel \;]
}

proc menu_graph {name} {
	pd [concat $name dirty 1 \;]
	set xdraw [expr int([$name.c canvasx 0])]
	set ydraw [expr int([$name.c canvasy 0])]
    pd [concat $name graph NULL 0 0 0 0 [expr $xdraw+30] [expr $ydraw+30] 0 [expr $ydraw+30]\;]
    #pd [concat $name graph \;]
}

proc menu_array {name} {
	pd [concat $name dirty 1 \;]
    pd [concat $name menuarray \;]
}

############iemlib##################
proc menu_bng {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name bng $accel \;]
}

proc menu_toggle {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name toggle $accel \;]
}

proc menu_numbox {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name numbox $accel \;]
}

proc menu_vslider {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name vslider $accel \;]
}

proc menu_hslider {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name hslider $accel \;]
}

proc menu_hradio {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name hradio $accel \;]
}

proc menu_vradio {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name vradio $accel \;]
}

proc menu_vumeter {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name vumeter $accel \;]
}

proc menu_mycnv {name accel} {
	pd [concat $name dirty 1 \;]
    pd [concat $name mycnv $accel \;]
}

############iemlib##################

# correct edit menu, enabling or disabling undo/redo/cut/copy/paste/tooltips/cord inspector
proc menu_fixeditmenu {name} {
	if { [winfo exists $name] } {
		catch {
			#puts stderr "fixeditmenu $name\n"

			#global pd_undoaction
			#global pd_redoaction
			#global pd_undocanvas

			global global_selection
			global global_clipboard
			global last_clipboard

			global autotips
			#global magicglass

			pdtk_canvas_leaveitem $name.c

			pdtk_canvas_tooltips $name $autotips
			#pdtk_canvas_magicglassval $name $magicglass

			# investigate if we have already something copied from an external source
			set current_clipboard 0
			catch {set current_clipboard [clipboard get]}
			#puts stderr $current_clipboard
			#puts stderr "======================================\n"
			#puts stderr $last_clipboard
			if {$current_clipboard != 0} {
				#puts stderr "curent clipboard != 0"
				# make sure the clipboard contents have not changed
				if { [string compare $last_clipboard $current_clipboard] } {
					#puts stderr "current != last"
					set data [split $current_clipboard "\n"]
					set first 0
					set full_line ""
					pd [concat $name reset_copyfromexternalbuffer\;]
					foreach line $data {
						if { [string index $line end] == ";" } {
							if { $full_line == "" } {
								set full_line $line
							} else {
								append full_line " " $line
							}
							#puts stderr "pd.tk sends: |$line| |$full_line|"
							if { !$first } {
								pd [concat $name copyfromexternalbuffer\;]
								pd [concat $name copyfromexternalbuffer $full_line\;]
								set first 1
							} else {
								pd [concat $name copyfromexternalbuffer $full_line\;]
							}
							set full_line ""
						} else {
							append full_line " " $line
							set full_line [string map {"\n" ""} $full_line]
						}
					}
					set global_clipboard 1
					set last_clipboard $current_clipboard
					pd [concat $name copyfromexternalbuffer\;]
					pdtk_canvas_update_edit_menu $name 1
				}
			}

			# puts stderr [concat menu_fixeditmenu $name $pd_undocanvas $pd_undoaction]
			if {$::undo($name) != "no"} {
				$name.m.edit entryconfigure "Undo*" -state normal \
				    -label [concat "Undo " $::undo($name)]
			} else {
				$name.m.edit entryconfigure "Undo*" -state disabled -label "Undo"
			}
			if {$::redo($name) != "no"} {
				$name.m.edit entryconfigure "Redo*" -state normal\
				    -label [concat "Redo " $::redo($name)]
			} else {
				$name.m.edit entryconfigure "Redo*" -state disabled
			}

			if {$global_selection == 1} {
				$name.m.edit entryconfigure "Duplicate" -state normal
			} else {
				$name.m.edit entryconfigure "Duplicate" -state disabled
			}

			if {$global_clipboard == 1} {
				$name.m.edit entryconfigure "Paste" -state normal
			} else {
				$name.m.edit entryconfigure "Paste" -state disabled
			}
		}
	}
}

# reset last_clipboard whenever we do copy/cut from inside pd
proc pdtk_canvas_reset_last_clipboard {} {
	global last_clipboard
	set last_clipboard 0
	#puts stderr pdtk_canvas_reset_last_clipboard
}

# message from Pd to update the currently available undo/redo action
proc pdtk_undomenu {name undoaction redoaction} {
    #global pd_undoaction
    #global pd_redoaction
    #global pd_undocanvas
    #    puts stderr [concat pdtk_undomenu $name $undoaction $redoaction]
    #set pd_undocanvas $name
    #set pd_undoaction $undoaction
    #set pd_redoaction $redoaction
	set ::undo($name) $undoaction
	set ::redo($name) $redoaction
    if {$name != "nobody"} {
        #    unpleasant way of avoiding a more unpleasant bug situation --atl 2002.11.25
        menu_fixeditmenu $name
		#puts stderr UNDO-[string trimleft $name .x]
		#set pdname [string trimleft $name .x]
		#pd [concat $name fixgop \;]
    }
}

proc menu_windowparent {name} {
    pd [concat $name findparent \;]
}

proc menu_findagain {name} {
    pd [concat $name findagain \;]
}

proc menu_finderror {} {
    pd [concat pd finderror \;]
}

proc menu_domenuwindow {i} {
    raise $i
}

proc menu_fixwindowmenu {name} {
    global menu_windowlist pd_tearoff pd_nt
    $name.m.windows add command
	if {$pd_nt == 2} {
		$name.m.windows delete 6 end
	} else {
		if $pd_tearoff {
			$name.m.windows delete 6 end
		} else {
			$name.m.windows delete 5 end
		}
	}
    foreach i $menu_windowlist {
        $name.m.windows add command -label [lindex $i 0] \
            -command [concat menu_domenuwindow [lindex $i 1]]
    }
}

################## the "find" menu item ###################

set find_canvas nobody
set find_string ""
set find_count 1
set find_wholeword 1

proc find_ok {name} {
    global find_string find_canvas find_wholeword
    pd [concat $find_canvas find [pdtk_encodedialog $find_string] \
        $find_wholeword \;]
    after 50 destroy $name
}

proc find_cancel {name} {
    after 50 destroy $name
}

proc menu_findobject {canvas} {
    global find_string
    global find_canvas
    global find_count
	global pd_nt
	global pointer_x_global pointer_y_global

	reset_ctrl_on_popup_window

    if { [winfo exists .find.frame.entry] } {
        raise .find
		wm geometry .find "+$pointer_x_global+$pointer_y_global"
    } else {

		set find_canvas $canvas
		
		toplevel .find -class [winfo class .]
		wm title .find "Find"
		match_linux_wm [list .find configure]
		#wm geometry .find =400x125+150+100
		wm geometry .find "+$pointer_x_global+$pointer_y_global"
		wm resizable .find 0 0
		catch {wm attributes .find -topmost 1}

		pdtk_panelkeybindings .find "find"

		match_linux_wm [list frame .find.frame]
		pack .find.frame -pady 3
		match_linux_wm [list entry .find.frame.entry -width 30 \
			-textvariable find_string]
		focus .find.frame.entry
		pack .find.frame.entry -side top -padx 3 -pady 3

	    match_linux_wm [list checkbutton .find.frame.wholeword \
			-variable find_wholeword \
	        -text {whole word}]
		match_linux_wm [list button .find.frame.close -text "Close" \
			-command "find_cancel .find" -width 9]
		match_linux_wm [list button .find.frame.button -text "Find" \
			-command "find_ok .find" \
			-width 9 -default active]
		pack .find.frame.button .find.frame.close .find.frame.wholeword -side right -padx 3
	}
}

proc pdtk_canvas_set_font {name size} {
	if {[info exists ::font($name)]} {
		set ::font($name) $size
	}
}

proc setTooltip {widget text} {
	if { $text != "" } {
		# 2) Adjusted timings and added key and button bindings. These seem to
		# make artifacts tolerably rare.
		bind $widget <Any-Enter>    [list after 500 [list showTooltip %W $text]]
		bind $widget <Any-Leave>    [list after 500 [list destroy %W.tooltip]]
		bind $widget <Any-KeyPress> [list after 500 [list destroy %W.tooltip]]
		bind $widget <Any-Button>   [list after 500 [list destroy %W.tooltip]]
	}
}

proc showTooltip {widget text} {
	global tcl_platform
	if { [string match $widget* [winfo containing  [winfo pointerx .] [winfo pointery .]] ] == 0  } {
		return
	}

	catch { destroy $widget.tooltip }

	set scrh [winfo screenheight $widget]    ; # 1) flashing window fix
	set scrw [winfo screenwidth $widget]     ; # 1) flashing window fix
	set tooltip [toplevel $widget.tooltip -bd 1 -bg black]
	wm geometry $tooltip +$scrh+$scrw        ; # 1) flashing window fix
	wm overrideredirect $tooltip 1

	if {$tcl_platform(platform) == {windows}} { ; # 3) wm attributes...
		wm attributes $tooltip -topmost 1   ; # 3) assumes...
	}                                           ; # 3) Windows
	pack [label $tooltip.label -bg lightyellow -fg black -text $text -justify left]

	set width [winfo reqwidth $tooltip.label]
	set height [winfo reqheight $tooltip.label]

	set pointer_below_midline [expr [winfo pointery .] > [expr [winfo screenheight .] / 2.0]]                ; # b.) Is the pointer in the bottom half of the screen?

	set positionX [expr [winfo pointerx .] - round($width / 2.0)]    ; # c.) Tooltip is centred horizontally on pointer.
	set positionY [expr [winfo pointery .] + 35 * ($pointer_below_midline * -2 + 1) - round($height / 2.0)]  ; # b.) Tooltip is displayed above or below depending on pointer Y position.

	# a.) Ad-hockery: Set positionX so the entire tooltip widget will be displayed.
	# c.) Simplified slightly and modified to handle horizontally-centred tooltips and the left screen edge.
	if  {[expr $positionX + $width] > [winfo screenwidth .]} {
		set positionX [expr [winfo screenwidth .] - $width]
	} elseif {$positionX < 0} {
		set positionX 0
	}

	wm geometry $tooltip [join  "$width x $height + $positionX + $positionY" {}]
	raise $tooltip

	# 2) Kludge: defeat rare artifact by passing mouse over a tooltip to destroy it.
	bind $widget.tooltip <Any-Enter> {destroy %W}
	bind $widget.tooltip <Any-Leave> {destroy %W}
 }

proc put_K12_objects {name object} {
	global k12_mode
	global pointer_x_local
	global pointer_y_local

	if { $k12_mode == 1 } {
		pd [concat $name dirty 1 \;]
		pd [concat $name obj_abstraction @pd_extra/K12/$object 0 20 \;]
	}
}

# K12 module abstraction additions and menu rearrangment by ktsoukalas@vt.edu

proc pdtk_k12_show_data_icons {name} {
	$name.k12frame.datasound.data configure -image i.data_on
	$name.k12frame.datasound.sound configure -image i.sound
	catch {
		pack forget \
		$name.k12frame.signal_1 \
		$name.k12frame.signal_2 \
		$name.k12frame.signal_3 \
		$name.k12frame.instr \
		$name.k12frame.midi \
		$name.k12frame.fx \
		$name.k12frame.output
		pack \
		$name.k12frame.wii \
		$name.k12frame.wii2 \
		$name.k12frame.arduino \
		$name.k12frame.rpi \
		$name.k12frame.math_2 \
		$name.k12frame.math_3 \
		$name.k12frame.logic \
		$name.k12frame.other \
		$name.k12frame.misc -side top -expand 0 -fill x
	}
}

proc pdtk_k12_show_sound_icons {name} {
	$name.k12frame.datasound.data configure -image i.data
	$name.k12frame.datasound.sound configure -image i.sound_on
	catch {
		pack forget \
		$name.k12frame.wii \
		$name.k12frame.wii2 \
		$name.k12frame.arduino \
		$name.k12frame.rpi \
		$name.k12frame.math_2 \
		$name.k12frame.math_3 \
		$name.k12frame.logic \
		$name.k12frame.other \
		$name.k12frame.misc
		pack \
		$name.k12frame.signal_1 \
		$name.k12frame.signal_2 \
		$name.k12frame.signal_3 \
		$name.k12frame.instr \
		$name.k12frame.midi \
		$name.k12frame.fx \
		$name.k12frame.output -side top -expand 0 -fill x
	}
}

package require tkpath 0.3.3

proc pdtk_canvas_recolor {name mode} {
	global k12_mode
	if { $k12_mode == 1 } {
		if {$mode == 0} {
			if {[info exists ::canvas_color($name)]} {
		        $name.c configure -background $::canvas_color($name)
		    } else {
		        $name.c configure -background $::pd_colors(canvas_color)
			}
		} else {
			$name.c configure -background #ffbc96
		}
	}		
}

############# pdtk_canvas_new -- create a new canvas ###############
proc pdtk_canvas_new {name width height geometry editable} {
    global pd_tearoff put_tearoff
    global pd_nt
    global tcl_version
#    global canvas_fill
	global colors
	global global_clipboard
	global global_selection
	global k12_mode
	global k12_saveas_on_new
	global autotips
	#global magicglass

	#retaining window-specific preferences
	global window_prefs

	reset_ctrl_on_popup_window

    # local vars for window-specific behavior
	# visibility of menu and scrollbars, plus canvas background
	if {![info exists ::scroll($name)]} {
		set ::scroll($name) 1
	}
	if {![info exists ::menu($name)]} {
		set ::menu($name) 1
	}
        # attempt at getting global presets to play
        # well with local settings.
        set my_canvas_color {}
#        set ::canvas_color($name) orange
	if {[info exists ::canvas_color($name)]} {
            set my_canvas_color $::canvas_color($name)
        } else {
            set my_canvas_color $::pd_colors(canvas_color)
	}
	if {![info exists ::topmost($name)]} {
		set ::topmost($name) 0
	}
	if {![info exists ::resize($name)]} {
		set ::resize($name) 1
	}
	if {![info exists ::xscrollable($name)]} {
		set ::xscrollable($name) 0
	}
	if {![info exists ::yscrollable($name)]} {
		set ::yscrollable($name) 0
	}
	if {![info exists ::update_tick($name)]} {
		set ::update_tick($name) 0
	}
	if {![info exists ::drag_tick($name)]} {
		set ::drag_tick($name) 0
	}
	if {![info exists ::undo($name)]} {
		set ::undo($name) no
	}
	if {![info exists ::redo($name)]} {
		set ::redo($name) no
	}
	if {![info exists ::font($name)]} {
		set ::font($name) 10
	}
	if {![info exists ::doscroll($name)]} {
		set ::doscroll($name) 0
	}

	if {$::menu($name) == 1} {
    	toplevel $name -menu $name.m -class [winfo class .]
	} else {
		toplevel $name -menu "" -class [winfo class .]
	}

	# initialize variable to reflect that this window has been open
	if {![info exists ::loaded($name)]} {
		set ::loaded($name) 1
	}

    # slide offscreen windows into view
    if {$tcl_version >= 8.4} {
        set geometry [split $geometry +]
        if { $pd_nt == 0 && [lindex $geometry 2] == 0 } {
			after idle center_window $name [expr int(-$width/3)] [expr int(-$height/3)]
        }
        set i 1
        foreach geo {width height} {
            set screen($geo) [winfo screen$geo .]
            if {[expr [lindex $geometry $i] + [set $geo]] > $screen($geo)} {
                set pos($geo) [expr $screen($geo) - [set $geo]]
                if {$pos($geo) < 0} {set pos($geo) 0}
                lset geometry $i $pos($geo)
            }
            incr i
        }
        if { $pd_nt == 2 && [lindex $geometry 2] < 22 } {
            lset geometry 2 22
        }
        set geometry [join $geometry +]
    }

	#apply window properties
	wm resizable $name $::resize($name) $::resize($name)
	wm attributes $name -topmost $::topmost($name)

	#if {[info tclversion] >= 8.5 && $pd_nt == 0} {
		#if {$::menu($name) == 1} {
			#ttk::separator $name.eyecandy
		#}
	#}

	if { $k12_mode == 1 } {
		# K-12 menu

		match_linux_wm [list frame $name.k12frame]
		pack $name.k12frame -side left -fill y

		# ---------------------------------- EDIT BUTTON -----------------------------------------
		match_linux_wm [list frame $name.k12frame.edit -relief flat]
		if {$editable==1} {
			match_linux_wm [list button $name.k12frame.edit.b -image i.edit \
				-command [concat menu_editmode $name]]
		} else {
			match_linux_wm [list button $name.k12frame.edit.b -image i.perform \
				-command [concat menu_editmode $name]]
		}
		pack $name.k12frame.edit.b -side left -expand 1 -padx 1 -pady 0
		setTooltip $name.k12frame.edit.b "Toggle between building and playing an instrument"
		pdtk_k12panel_standardkeybindings $name.k12frame.edit.b
		bind $name.k12frame.edit.b <Key> [list pdtk_canvas_sendkey $name.c 1 %K %A 0 1 %t]
    	bind $name.k12frame.edit.b <KeyRelease> [list pdtk_canvas_sendkey $name.c 0 %K %A 0 1 %t]

		# ---------------------------------- DATA VS SOUND BUTTONS ----------------------------------
		match_linux_wm [list frame $name.k12frame.datasound -relief flat]
		match_linux_wm [list button $name.k12frame.datasound.data -text "CONTROL" -image i.data_on -command [concat pdtk_k12_show_data_icons $name]]
		match_linux_wm [list button $name.k12frame.datasound.sound -text "SOUND" -image i.sound -command [concat pdtk_k12_show_sound_icons $name]]
		pack $name.k12frame.datasound.data $name.k12frame.datasound.sound -side left -pady 1 -padx 1 -expand 0
		setTooltip $name.k12frame.datasound.data "Show CONTROL objects"
		setTooltip $name.k12frame.datasound.sound "Show SOUND objects"
		pdtk_k12panel_standardkeybindings $name.k12frame.datasound.data
		pdtk_k12panel_standardkeybindings $name.k12frame.datasound.sound

		# ---------------------------------- MESSAGES LABEL -----------------------------------------

		#match_linux_wm [list frame $name.k12frame.msgs -relief flat]
		#match_linux_wm [list label $name.k12frame.msgs.label -relief flat -text "MESSAGES"]
		#pack $name.k12frame.msgs.label -fill x -pady 0 -padx 1

		# ---------------------------------- WII -----------------------------------------
		match_linux_wm [list frame $name.k12frame.wii -relief flat]
		match_linux_wm [list button $name.k12frame.wii.b_wii_connect -image i.wii_connect \
			-command [concat put_K12_objects $name wii_connect]]
		match_linux_wm [list button $name.k12frame.wii.b_wii_buttons -image i.wii_buttons \
			-command [concat put_K12_objects $name wii_buttons]]
		match_linux_wm [list button $name.k12frame.wii.b_wii_hit -image i.wii_hit \
			-command [concat put_K12_objects $name wii_hit]]
		match_linux_wm [list button $name.k12frame.wii.b_wii_accelerometer -image i.wii_accelerometer \
			-command [concat put_K12_objects $name wii_accelerometer]]
		match_linux_wm [list button $name.k12frame.wii.b_wii_speed_xry -image i.wii_speed_xry \
			-command [concat put_K12_objects $name wii_speed_xry]]
		pack $name.k12frame.wii.b_wii_connect $name.k12frame.wii.b_wii_buttons $name.k12frame.wii.b_wii_hit $name.k12frame.wii.b_wii_accelerometer $name.k12frame.wii.b_wii_speed_xry -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.wii.b_wii_connect "Wiimote Connect: Use this to connect wiimote to the computer"
		setTooltip $name.k12frame.wii.b_wii_buttons "Wiimote Buttons: Use this to select which Wiimote button should activate objects connected to this object"
		setTooltip $name.k12frame.wii.b_wii_hit "Wiimote Hit: Use this to detect when the wiimote has been shaken like a mallet"
		setTooltip $name.k12frame.wii.b_wii_accelerometer "Wiimote Accelerometer: Use this to monitor Wiimotes acceleration across X, Y, and Z axes"
		setTooltip $name.k12frame.wii.b_wii_speed_xry "Wiimote Speed X, Roll, Y: Use this to detect how quickly is Wiimote moving across individual axes x, roll, and y (requires motion plus)"
		pdtk_k12panel_standardkeybindings $name.k12frame.wii.b_wii_connect
		pdtk_k12panel_standardkeybindings $name.k12frame.wii.b_wii_buttons
		pdtk_k12panel_standardkeybindings $name.k12frame.wii.b_wii_hit
		pdtk_k12panel_standardkeybindings $name.k12frame.wii.b_wii_accelerometer
		pdtk_k12panel_standardkeybindings $name.k12frame.wii.b_wii_speed_xry

		# ---------------------------------- WII2 -----------------------------------------
		match_linux_wm [list frame $name.k12frame.wii2 -relief flat]
		match_linux_wm [list button $name.k12frame.wii2.b_wii_speed -image i.wii_speed \
			-command [concat put_K12_objects $name wii_speed]]
		match_linux_wm [list button $name.k12frame.wii2.b_wii_nunchuk_buttons -image i.wii_nunchuk_buttons \
			-command [concat put_K12_objects $name wii_nunchuk_buttons]]
		match_linux_wm [list button $name.k12frame.wii2.b_wii_nunchuk_hit -image i.wii_nunchuk_hit \
			-command [concat put_K12_objects $name wii_nunchuk_hit]]
		match_linux_wm [list button $name.k12frame.wii2.b_wii_nunchuk_accelerometer -image i.wii_nunchuk_accelerometer \
			-command [concat put_K12_objects $name wii_nunchuk_accelerometer]]
		match_linux_wm [list button $name.k12frame.wii2.b_wii_nunchuk_stick -image i.wii_nunchuk_stick \
			-command [concat put_K12_objects $name wii_nunchuk_stick]]
		pack $name.k12frame.wii2.b_wii_speed $name.k12frame.wii2.b_wii_nunchuk_buttons $name.k12frame.wii2.b_wii_nunchuk_hit $name.k12frame.wii2.b_wii_nunchuk_accelerometer $name.k12frame.wii2.b_wii_nunchuk_stick -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.wii2.b_wii_speed "Wiimote Speed: Use this to detect how quickly is Wiimote moving (requires motion plus)"
		setTooltip $name.k12frame.wii2.b_wii_nunchuk_buttons "Wiimote Nunchuk Buttons: Use this to select which Nunchuk button should activate objects connected to this object (requires nunchuk extension)"
		setTooltip $name.k12frame.wii2.b_wii_nunchuk_hit "Wiimote Nunchuk Hit: Use this to detect when the wiimote has been shaken like a mallet (requires nunchuk extension)"
		setTooltip $name.k12frame.wii2.b_wii_nunchuk_accelerometer "Wiimote Nunchuk Accelerometer: Use this to monitor Nunchuk acceleration across X, Y, and Z axes (requires nunchuk extension)"
		setTooltip $name.k12frame.wii2.b_wii_nunchuk_stick "Wiimote Nunchuk stick: Use this to monitor Nunchuk stick motion across X and Y axes (requires nunchuk extension)"
		pdtk_k12panel_standardkeybindings $name.k12frame.wii2.b_wii_speed
		pdtk_k12panel_standardkeybindings $name.k12frame.wii2.b_wii_nunchuk_buttons
		pdtk_k12panel_standardkeybindings $name.k12frame.wii2.b_wii_nunchuk_hit
		pdtk_k12panel_standardkeybindings $name.k12frame.wii2.b_wii_nunchuk_accelerometer
		pdtk_k12panel_standardkeybindings $name.k12frame.wii2.b_wii_nunchuk_stick

		# ---------------------------------- ARDUINO -----------------------------------------
		match_linux_wm [list frame $name.k12frame.arduino -relief flat]
		match_linux_wm [list button $name.k12frame.arduino.b_arduino -image i.arduino \
			-command [concat put_K12_objects $name arduino_connect]]
		match_linux_wm [list button $name.k12frame.arduino.b_arduino_digital_in -image i.arduino_digital_in \
			-command [concat put_K12_objects $name arduino_digital_in]]
		match_linux_wm [list button $name.k12frame.arduino.b_arduino_digital_out -image i.arduino_digital_out \
			-command [concat put_K12_objects $name arduino_digital_out]]
		match_linux_wm [list button $name.k12frame.arduino.b_arduino_analog_in -image i.arduino_analog_in \
			-command [concat put_K12_objects $name arduino_analog_in]]
		match_linux_wm [list button $name.k12frame.arduino.b_arduino_analog_out -image i.arduino_analog_out \
			-command [concat put_K12_objects $name arduino_analog_out]]
		#match_linux_wm [list button $name.k12frame.arduino.b_arduino_piezo -image i.arduino_piezo \
		#	-command [concat put_K12_objects $name arduino_piezo]]
		pack $name.k12frame.arduino.b_arduino $name.k12frame.arduino.b_arduino_digital_in $name.k12frame.arduino.b_arduino_digital_out $name.k12frame.arduino.b_arduino_analog_in $name.k12frame.arduino.b_arduino_analog_out -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.arduino.b_arduino "Arduino Connect: Use this to arduino to the computer"
		setTooltip $name.k12frame.arduino.b_arduino_digital_in "Arduino Digital In: Use this to detect on/off states of a digital sensor"
		setTooltip $name.k12frame.arduino.b_arduino_digital_out "Arduino Digital Out: Use this to send on/off state to an outgoing device (e.g. LED)"
		setTooltip $name.k12frame.arduino.b_arduino_analog_in "Arduino Analog In: Use this to monitor analog sensor"
		setTooltip $name.k12frame.arduino.b_arduino_analog_out "Arduino Analog Out: Use this to send analog signal over a PWM-enabled digital pin"
		#setTooltip $name.k12frame.arduino.b_arduino_hit "Arduino Hit: Use this to detect when the arduino analog sensor data has rapidly changed"
		#setTooltip $name.k12frame.arduino.b_arduino_piezo "Arduino Piezo: Use this to analyze data coming from a piezo microphone sensor"
		pdtk_k12panel_standardkeybindings $name.k12frame.arduino.b_arduino
		pdtk_k12panel_standardkeybindings $name.k12frame.arduino.b_arduino_digital_in
		pdtk_k12panel_standardkeybindings $name.k12frame.arduino.b_arduino_digital_out
		pdtk_k12panel_standardkeybindings $name.k12frame.arduino.b_arduino_analog_in
		pdtk_k12panel_standardkeybindings $name.k12frame.arduino.b_arduino_analog_out

		# ---------------------------------- RPI  -----------------------------------------
		match_linux_wm [list frame $name.k12frame.rpi -relief flat]
		#match_linux_wm [list button $name.k12frame.rpi.b_sarcduino_net -image i.sarcduino_net \
		#	-command [concat put_K12_objects $name sarcduino_net]]
		match_linux_wm [list button $name.k12frame.rpi.b_rpi_digital -image i.raspberry_digital \
			-command [concat put_K12_objects $name raspberrypi_digital]]
		match_linux_wm [list button $name.k12frame.rpi.b_rpi_analog_out -image i.raspberry_analog_out \
			-command [concat put_K12_objects $name raspberrypi_analog_out]]
		match_linux_wm [list button $name.k12frame.rpi.b_rpi_analog_in -image i.raspberry_analog_in \
			-command [concat put_K12_objects $name raspberrypi_analog_in]]
		match_linux_wm [list button $name.k12frame.rpi.b_rpi_motor -image i.raspberry_motor \
                        -command [concat put_K12_objects $name raspberrypi_motor]]
                match_linux_wm [list button $name.k12frame.rpi.b_rpi_solenoid -image i.raspberry_solenoid \
                        -command [concat put_K12_objects $name raspberrypi_solenoid]]
		pack $name.k12frame.rpi.b_rpi_digital $name.k12frame.rpi.b_rpi_analog_out $name.k12frame.rpi.b_rpi_analog_in  $name.k12frame.rpi.b_rpi_motor  $name.k12frame.rpi.b_rpi_solenoid -side left -expand 0 -padx 1 -pady 1
		#setTooltip $name.k12frame.math_1.b_sarcduino_net "Arduino Net: Use this to retrieve data from arduino devices connected via network"
		setTooltip $name.k12frame.rpi.b_rpi_digital "RaspberryPi Digital: Use this to read from or write to GPIO pins in digital format"
		setTooltip $name.k12frame.rpi.b_rpi_analog_out "RaspberryPi Analog Out: Use this to write to GPIO pins in analog format using PWM"
		setTooltip $name.k12frame.rpi.b_rpi_analog_in "RaspberryPi Analog In: Use this to read from RaspberryPi LOP Shield's analog inputs"
		setTooltip $name.k12frame.rpi.b_rpi_motor "RaspberryPi Motor: Use this to control a DC servo motor angle degree from a GPIO" 
		setTooltip $name.k12frame.rpi.b_rpi_solenoid "RaspberryPi Solenoid: Use this to send a pulse from a GPIO to a solenoid"
		pdtk_k12panel_standardkeybindings $name.k12frame.rpi.b_rpi_digital
		pdtk_k12panel_standardkeybindings $name.k12frame.rpi.b_rpi_analog_out
		pdtk_k12panel_standardkeybindings $name.k12frame.rpi.b_rpi_analog_in
		pdtk_k12panel_standardkeybindings $name.k12frame.rpi.b_rpi_motor
		pdtk_k12panel_standardkeybindings $name.k12frame.rpi.b_rpi_solenoid

		# ---------------------------------- MATH ROW 1 -----------------------------------------
		match_linux_wm [list frame $name.k12frame.math_2 -relief flat]
		match_linux_wm [list button $name.k12frame.math_2.b_math_netreceive -image i.math_netreceive \
			-command [concat put_K12_objects $name math_netreceive]]
		match_linux_wm [list button $name.k12frame.math_2.b_math_netsend -image i.math_netsend \
                        -command [concat put_K12_objects $name math_netsend]]
		match_linux_wm [list button $name.k12frame.math_2.b_math_tag -image i.math_tag \
			-command [concat put_K12_objects $name math_tag]]
		match_linux_wm [list button $name.k12frame.math_2.b_math_routebytag -image i.math_routebytag \
			-command [concat put_K12_objects $name math_routebytag]]
		match_linux_wm [list button $name.k12frame.math_2.b_math_random -image i.math_random \
			-command [concat put_K12_objects $name math_random]]
		pack \
			$name.k12frame.math_2.b_math_netreceive \
			$name.k12frame.math_2.b_math_netsend \
			$name.k12frame.math_2.b_math_tag \
			$name.k12frame.math_2.b_math_routebytag \
			$name.k12frame.math_2.b_math_random -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.math_2.b_math_netreceive "Netreceive: Use this to receive data from another computer over network"
		setTooltip $name.k12frame.math_2.b_math_netsend "Netsend: Use this to send data over network to another computer"
		setTooltip $name.k12frame.math_2.b_math_tag "Tag: Use this to tag data to be sent over network"
		setTooltip $name.k12frame.math_2.b_math_routebytag "Route By Tag: Use this to filter incoming network data by tag"
		setTooltip $name.k12frame.math_2.b_math_random "Random: Use this to generate random numbers"

		pdtk_k12panel_standardkeybindings $name.k12frame.math_2.b_math_netreceive
		pdtk_k12panel_standardkeybindings $name.k12frame.math_2.b_math_netsend
		pdtk_k12panel_standardkeybindings $name.k12frame.math_2.b_math_tag
		pdtk_k12panel_standardkeybindings $name.k12frame.math_2.b_math_routebytag
		pdtk_k12panel_standardkeybindings $name.k12frame.math_2.b_math_random

		# ---------------------------------- MATH ROW 2 -----------------------------------------
		match_linux_wm [list frame $name.k12frame.math_3 -relief flat]
		match_linux_wm [list button $name.k12frame.math_3.b_math_add -image i.math_add \
			-command [concat put_K12_objects $name math_add]]
		match_linux_wm [list button $name.k12frame.math_3.b_math_subtract -image i.math_subtract \
			-command [concat put_K12_objects $name math_subtract]]
		match_linux_wm [list button $name.k12frame.math_3.b_math_multiply -image i.math_multiply \
			-command [concat put_K12_objects $name math_multiply]]
		match_linux_wm [list button $name.k12frame.math_3.b_math_divide -image i.math_divide \
			-command [concat put_K12_objects $name math_divide]]
		match_linux_wm [list button $name.k12frame.math_3.b_math_exponentiate -image i.math_exponentiate \
			-command [concat put_K12_objects $name math_exponentiate]]
		setTooltip $name.k12frame.math_3.b_math_add "Add: Use this to add two values"
		setTooltip $name.k12frame.math_3.b_math_subtract "Subtract: Use this to subtract two values"
		setTooltip $name.k12frame.math_3.b_math_multiply "Multiply: Use this to multiply two values"
		setTooltip $name.k12frame.math_3.b_math_divide "Divide: Use this to divide two values"
		setTooltip $name.k12frame.math_3.b_math_exponentiate "Exponentiate: Use this to raise a base value to the power of an exponent value"
		pack \
		$name.k12frame.math_3.b_math_add \
		$name.k12frame.math_3.b_math_subtract \
		$name.k12frame.math_3.b_math_multiply \
		$name.k12frame.math_3.b_math_divide \
		$name.k12frame.math_3.b_math_exponentiate -side left -expand 0 -padx 1 -pady 1
		pdtk_k12panel_standardkeybindings $name.k12frame.math_3.b_math_add
		pdtk_k12panel_standardkeybindings $name.k12frame.math_3.b_math_subtract
		pdtk_k12panel_standardkeybindings $name.k12frame.math_3.b_math_multiply
		pdtk_k12panel_standardkeybindings $name.k12frame.math_3.b_math_divide
		pdtk_k12panel_standardkeybindings $name.k12frame.math_3.b_math_exponentiate

		# ---------------------------------- MATH ROW 3 & LOGIC -----------------------------------------
		match_linux_wm [list frame $name.k12frame.logic -relief flat]
		match_linux_wm [list button $name.k12frame.logic.b_math_number -image i.math_number \
                        -command [concat put_K12_objects $name math_number]]
                match_linux_wm [list button $name.k12frame.logic.b_math_average -image i.math_average \
			-command [concat put_K12_objects $name math_average]]
		match_linux_wm [list button $name.k12frame.logic.b_math_scale -image i.math_scale \
			-command [concat put_K12_objects $name math_scale]]
		match_linux_wm [list button $name.k12frame.logic.b_logic_compare -image i.logic_compare \
			-command [concat put_K12_objects $name logic_compare]]
		match_linux_wm [list button $name.k12frame.logic.b_logic_mapper -image i.logic_mapper \
			-command [concat put_K12_objects $name logic_mapper]]
		pack \
		$name.k12frame.logic.b_math_number \
		$name.k12frame.logic.b_math_average \
		$name.k12frame.logic.b_math_scale \
		$name.k12frame.logic.b_logic_compare \
		$name.k12frame.logic.b_logic_mapper -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.logic.b_math_number "Number: Use this to assign a value to other objects"
                setTooltip $name.k12frame.logic.b_math_average "Average: Use this to calculate average from a stream of numbers"
		setTooltip $name.k12frame.logic.b_math_scale "Scale: Use this to scale incoming values to a new range and direction"
		setTooltip $name.k12frame.logic.b_logic_compare "Compare: Use this to compare two values"
		setTooltip $name.k12frame.logic.b_logic_mapper "Mapper: Use this to map one value to two different but related values"
		pdtk_k12panel_standardkeybindings $name.k12frame.logic.b_math_number
                pdtk_k12panel_standardkeybindings $name.k12frame.logic.b_math_average
		pdtk_k12panel_standardkeybindings $name.k12frame.logic.b_math_scale
		pdtk_k12panel_standardkeybindings $name.k12frame.logic.b_logic_compare
		pdtk_k12panel_standardkeybindings $name.k12frame.logic.b_logic_mapper

		# ---------------------------------- LOGIC + OTHER -----------------------------------------
		match_linux_wm [list frame $name.k12frame.other -relief flat]
		match_linux_wm [list button $name.k12frame.other.b_logic_metronome -image i.logic_metronome \
			-command [concat put_K12_objects $name logic_metronome]]
		match_linux_wm [list button $name.k12frame.other.b_logic_counter -image i.logic_counter \
                        -command [concat put_K12_objects $name logic_counter]]
		match_linux_wm [list button $name.k12frame.other.b_logic_sequencer -image i.logic_sequencer \
			-command [concat put_K12_objects $name logic_sequencer]]
		match_linux_wm [list button $name.k12frame.other.b_logic_hit -image i.logic_hit \
                        -command [concat put_K12_objects $name logic_hit]]
		pack \
		$name.k12frame.other.b_logic_metronome \
		$name.k12frame.other.b_logic_counter \
		$name.k12frame.other.b_logic_sequencer \
		$name.k12frame.other.b_logic_hit -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.other.b_logic_metronome "Metronome: Use this to create a steady pulse"
		setTooltip $name.k12frame.other.b_logic_counter "Counter: Use this to count events"
		setTooltip $name.k12frame.other.b_logic_sequencer "Sequencer: Use this to map values to MIDI pitches"
                setTooltip $name.k12frame.other.b_logic_hit "Hit: Use this to detect a hit on a control data stream"
		pdtk_k12panel_standardkeybindings $name.k12frame.other.b_logic_metronome
                pdtk_k12panel_standardkeybindings $name.k12frame.other.b_logic_counter
		pdtk_k12panel_standardkeybindings $name.k12frame.other.b_logic_sequencer
		pdtk_k12panel_standardkeybindings $name.k12frame.other.b_logic_hit
		
		# ---------------------------------- MISC----------------------------------
		match_linux_wm [list frame $name.k12frame.misc -relief flat]
		match_linux_wm [list button $name.k12frame.misc.b_preset -image i.preset \
			-command [concat put_K12_objects $name preset]] 
		match_linux_wm [list button $name.k12frame.misc.b_comment -image i.comment \
			-command [concat menu_comment $name 1]]
		pack \
		$name.k12frame.misc.b_preset \
		$name.k12frame.misc.b_comment -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.misc.b_preset "Preset: Use this to store and recall up to four different states of your instrument"
		setTooltip $name.k12frame.misc.b_comment "Comment: Use this to post comments inside your patch"
		pdtk_k12panel_standardkeybindings $name.k12frame.misc.b_preset
		pdtk_k12panel_standardkeybindings $name.k12frame.misc.b_comment

		# ---------------------------------- SOUND LABEL -----------------------------------------
		#match_linux_wm [list frame $name.k12frame.sound -relief flat]
		#match_linux_wm [list label $name.k12frame.sound.label -relief flat -text "SOUND"]
		#pack $name.k12frame.sound.label -fill x -pady 0 -padx 1

		# ---------------------------------- SIGNAL ROW 1 -----------------------------------------
		match_linux_wm [list frame $name.k12frame.signal_1 -relief flat]
		match_linux_wm [list button $name.k12frame.signal_1.b_signal_microphone -image i.signal_microphone \
			-command [concat put_K12_objects $name signal_microphone]]

		match_linux_wm [list button $name.k12frame.signal_1.b_signal_netsend -image i.signal_netsend \
			-command [concat put_K12_objects $name signal_netsend]]
		match_linux_wm [list button $name.k12frame.signal_1.b_signal_netreceive -image i.signal_netreceive \
			-command [concat put_K12_objects $name signal_netreceive]]

		match_linux_wm [list button $name.k12frame.signal_1.b_signal_sampler -image i.signal_sampler \
			-command [concat put_K12_objects $name signal_sampler]]
		match_linux_wm [list button $name.k12frame.signal_1.b_signal_player -image i.signal_player \
			-command [concat put_K12_objects $name signal_player]]
		pack $name.k12frame.signal_1.b_signal_microphone $name.k12frame.signal_1.b_signal_netsend $name.k12frame.signal_1.b_signal_netreceive $name.k12frame.signal_1.b_signal_sampler $name.k12frame.signal_1.b_signal_player -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.signal_1.b_signal_microphone "Microphone: Use this to capture and monitor microphone input"
		setTooltip $name.k12frame.signal_1.b_signal_netsend "Netsend Sound: Use this to send your sound over network to another computer"
		setTooltip $name.k12frame.signal_1.b_signal_netreceive "Netreceive Sound: Use this to receive sound from another computer over network"
		setTooltip $name.k12frame.signal_1.b_signal_sampler "Sampler: Use this to record audio from microphone and play it back in various ways"
		setTooltip $name.k12frame.signal_1.b_signal_player "Player: Use this to play WAV files in various ways"
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_1.b_signal_microphone
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_1.b_signal_netsend
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_1.b_signal_netreceive
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_1.b_signal_sampler
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_1.b_signal_player

		# ---------------------------------- SIGNAL ROW 2 -----------------------------------------
		match_linux_wm [list frame $name.k12frame.signal_2 -relief flat]
		match_linux_wm [list button $name.k12frame.signal_2.b_signal_sine -image i.signal_sine \
			-command [concat put_K12_objects $name signal_sine]]
		match_linux_wm [list button $name.k12frame.signal_2.b_signal_saw -image i.signal_saw \
			-command [concat put_K12_objects $name signal_saw]]
		match_linux_wm [list button $name.k12frame.signal_2.b_signal_square -image i.signal_square \
			-command [concat put_K12_objects $name signal_square]]
		match_linux_wm [list button $name.k12frame.signal_2.b_signal_triangle -image i.signal_triangle \
			-command [concat put_K12_objects $name signal_triangle]]
		match_linux_wm [list button $name.k12frame.signal_2.b_signal_envelope -image i.signal_envelope \
			-command [concat put_K12_objects $name signal_envelope]]
		pack $name.k12frame.signal_2.b_signal_sine $name.k12frame.signal_2.b_signal_saw $name.k12frame.signal_2.b_signal_square $name.k12frame.signal_2.b_signal_triangle $name.k12frame.signal_2.b_signal_envelope -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.signal_2.b_signal_sine "Sine: Use this to generate sine tone"
		setTooltip $name.k12frame.signal_2.b_signal_saw "Sawtooth: Use this to generate sawtooth tone"
		setTooltip $name.k12frame.signal_2.b_signal_square "Square: Use this to generate square tone"
		setTooltip $name.k12frame.signal_2.b_signal_triangle "Triangle: Use this to generate triangle tone"
		setTooltip $name.k12frame.signal_2.b_signal_envelope "Envelope: Use this to shape sound loudness"
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_2.b_signal_sine
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_2.b_signal_saw
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_2.b_signal_square
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_2.b_signal_triangle
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_2.b_signal_envelope

		# ---------------------------------- SIGNAL ROW 3 -----------------------------------------
		match_linux_wm [list frame $name.k12frame.signal_3 -relief flat]
		match_linux_wm [list button $name.k12frame.signal_3.b_signal_noise -image i.signal_noise \
			-command [concat put_K12_objects $name signal_noise]]
		match_linux_wm [list button $name.k12frame.signal_3.b_signal_pink -image i.signal_pink \
			-command [concat put_K12_objects $name signal_pink]]
		match_linux_wm [list button $name.k12frame.signal_3.b_signal_add -image i.signal_add \
			-command [concat put_K12_objects $name signal_add]]
		match_linux_wm [list button $name.k12frame.signal_3.b_signal_multiply -image i.signal_multiply \
			-command [concat put_K12_objects $name signal_multiply]]
		pack $name.k12frame.signal_3.b_signal_noise $name.k12frame.signal_3.b_signal_pink $name.k12frame.signal_3.b_signal_add $name.k12frame.signal_3.b_signal_multiply -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.signal_3.b_signal_noise "Noise: Use this to generate white (harsh) noise"
		setTooltip $name.k12frame.signal_3.b_signal_pink "Pink: Use this to generate pink (softer) noise"
		setTooltip $name.k12frame.signal_3.b_signal_add "Signal Add: Use this to add two sounds (signals)"
		setTooltip $name.k12frame.signal_3.b_signal_multiply "Signal Multiply: Use this to multiply two sounds (signals)"
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_3.b_signal_noise 
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_3.b_signal_pink
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_3.b_signal_add
		pdtk_k12panel_standardkeybindings $name.k12frame.signal_3.b_signal_multiply

		# ---------------------------------- INSTRUMENTS -----------------------------------------
		match_linux_wm [list frame $name.k12frame.instr -relief flat]
		match_linux_wm [list button $name.k12frame.instr.b_instr_short1 -image i.instr_short1 \
			-command [concat put_K12_objects $name instr_short1]]
		match_linux_wm [list button $name.k12frame.instr.b_instr_short2 -image i.instr_short2 \
			-command [concat put_K12_objects $name instr_short2]]
		match_linux_wm [list button $name.k12frame.instr.b_instr_sustained1 -image i.instr_sustained1 \
			-command [concat put_K12_objects $name instr_sustained1]]
		match_linux_wm [list button $name.k12frame.instr.b_instr_sustained2 -image i.instr_sustained2 \
			-command [concat put_K12_objects $name instr_sustained2]]
		pack $name.k12frame.instr.b_instr_short1 $name.k12frame.instr.b_instr_short2 $name.k12frame.instr.b_instr_sustained1 $name.k12frame.instr.b_instr_sustained2 -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.instr.b_instr_short1 "Bass Drum: Use this to produce short sounds like a single bass drum hit"
		setTooltip $name.k12frame.instr.b_instr_short2 "Snare Drum: Use this to produce short sounds like a single snare drum hit"
		setTooltip $name.k12frame.instr.b_instr_sustained1 "Air Instrument: Use this to produce long sustained sound like a sound of a woodwind instrument"
		setTooltip $name.k12frame.instr.b_instr_sustained2 "Brass Instrument: Use this to produce long sustained sound like a sound of brass instrument"
		pdtk_k12panel_standardkeybindings $name.k12frame.instr.b_instr_short1
		pdtk_k12panel_standardkeybindings $name.k12frame.instr.b_instr_short2
		pdtk_k12panel_standardkeybindings $name.k12frame.instr.b_instr_sustained1
		pdtk_k12panel_standardkeybindings $name.k12frame.instr.b_instr_sustained2

		# ---------------------------------- MIDI INSTRUMENTS ------------------------------------
		match_linux_wm [list frame $name.k12frame.midi -relief flat]
		match_linux_wm [list button $name.k12frame.midi.b_midi_synth -image i.midi_synth \
			-command [concat put_K12_objects $name midi_synth]]
		match_linux_wm [list button $name.k12frame.midi.b_midi_note -image i.midi_note \
			-command [concat put_K12_objects $name midi_note]]
		match_linux_wm [list button $name.k12frame.midi.b_midi_instrument -image i.midi_instrument \
			-command [concat put_K12_objects $name midi_instrument]]
		match_linux_wm [list button $name.k12frame.midi.b_midi_control -image i.midi_control \
			-command [concat put_K12_objects $name midi_control]]
		pack $name.k12frame.midi.b_midi_synth $name.k12frame.midi.b_midi_note $name.k12frame.midi.b_midi_instrument $name.k12frame.midi.b_midi_control -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.midi.b_midi_synth "MIDI Synth: create a synthesizer with up to 128 unique sounds"
		setTooltip $name.k12frame.midi.b_midi_note "MIDI Note: connect this to MIDI synth to issue note on and off commands"
		setTooltip $name.k12frame.midi.b_midi_instrument "MIDI Instrument: connect this to MIDI synth to issue instrument change commands"
		setTooltip $name.k12frame.midi.b_midi_control "MIDI Control: connect this to MIDI synth to change instrument properties"
		pdtk_k12panel_standardkeybindings $name.k12frame.midi.b_midi_synth
		pdtk_k12panel_standardkeybindings $name.k12frame.midi.b_midi_note
		pdtk_k12panel_standardkeybindings $name.k12frame.midi.b_midi_instrument
		pdtk_k12panel_standardkeybindings $name.k12frame.midi.b_midi_control

		# ---------------------------------- F/X -----------------------------------------
		match_linux_wm [list frame $name.k12frame.fx -relief flat]
		match_linux_wm [list button $name.k12frame.fx.b_fx_pitchshift -image i.fx_pitchshift \
			-command [concat put_K12_objects $name fx_pitchshift]]
		match_linux_wm [list button $name.k12frame.fx.b_fx_filter -image i.fx_filter \
			-command [concat put_K12_objects $name fx_filter]]
		match_linux_wm [list button $name.k12frame.fx.b_fx_phaser -image i.fx_phaser \
			-command [concat put_K12_objects $name fx_phaser]]
		match_linux_wm [list button $name.k12frame.fx.b_fx_multitap -image i.fx_multitap \
			-command [concat put_K12_objects $name fx_multitap]]
		match_linux_wm [list button $name.k12frame.fx.b_fx_reverb -image i.fx_reverb \
			-command [concat put_K12_objects $name fx_reverb]]
		pack $name.k12frame.fx.b_fx_pitchshift $name.k12frame.fx.b_fx_filter $name.k12frame.fx.b_fx_phaser $name.k12frame.fx.b_fx_multitap $name.k12frame.fx.b_fx_reverb -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.fx.b_fx_pitchshift "Pitch Shift: Use this to change pitch of an incoming sound"
		setTooltip $name.k12frame.fx.b_fx_filter "Filter: Use this to make sound appear muffled or brighter"
		setTooltip $name.k12frame.fx.b_fx_phaser "Phaser: Use this to add a flanger-like wavy effect to a sound"
		setTooltip $name.k12frame.fx.b_fx_multitap "Echo: Use this to make sound echo"
		setTooltip $name.k12frame.fx.b_fx_reverb "Reverb: Use this to make sound appear as if it is being played in a large space"
		pdtk_k12panel_standardkeybindings $name.k12frame.fx.b_fx_pitchshift
		pdtk_k12panel_standardkeybindings $name.k12frame.fx.b_fx_filter
		pdtk_k12panel_standardkeybindings $name.k12frame.fx.b_fx_phaser
		pdtk_k12panel_standardkeybindings $name.k12frame.fx.b_fx_multitap
		pdtk_k12panel_standardkeybindings $name.k12frame.fx.b_fx_reverb

		# ---------------------------------- OUTPUT/OTHER -----------------------------------------

		match_linux_wm [list frame $name.k12frame.output -relief flat]
		match_linux_wm [list button $name.k12frame.output.b_fx_autotune -image i.fx_autotune \
			-command [concat put_K12_objects $name fx_autotune]]
		match_linux_wm [list button $name.k12frame.output.b_output -image i.output \
			-command [concat put_K12_objects $name output]] 	
		pack $name.k12frame.output.b_fx_autotune $name.k12frame.output.b_output -side left -expand 0 -padx 1 -pady 1
		setTooltip $name.k12frame.output.b_fx_autotune "Autotune: Use this to correct pitch of an incoming sound to match desired scale"
		setTooltip $name.k12frame.output.b_output "Output: Use this to send sound from computer into speakers"
		pdtk_k12panel_standardkeybindings $name.k12frame.output.b_fx_autotune
		pdtk_k12panel_standardkeybindings $name.k12frame.output.b_output

		# ---------------------------------------- NOW PACK THEM ALL -----------------------------------------
		pack \
		$name.k12frame.edit \
		$name.k12frame.datasound \
		$name.k12frame.wii $name.k12frame.wii2 \
		$name.k12frame.arduino $name.k12frame.rpi \
		$name.k12frame.math_2 $name.k12frame.math_3 \
		$name.k12frame.logic $name.k12frame.other \
		$name.k12frame.misc -side top -expand 0 -fill x
	}
    tkp::canvas $name.c -width $width -height $height -background $my_canvas_color \
		-highlightthickness 0 -bd 0
        #-yscrollcommand "$name.scrollvert set" \
        #-xscrollcommand "$name.scrollhort set" \
        #-scrollregion [concat 0 0 $width $height]
	#$name.c configure -closeenough 0.0

	#pdtk_standardkeybindings $name.c

	#if {[info tclversion] >= 8.5 && $pd_nt == 0} {
		#if {$::menu($name) == 1} {
			#pack $name.eyecandy $name.c -fill x -expand 0
		#}
	#}

    #match_linux_wm [list scrollbar $name.scrollvert -command "$name.c yview"]
    #match_linux_wm [list scrollbar $name.scrollhort -command "$name.c xview" \
    #-orient horizontal]

	#pack $name.scrollhort -side bottom -fill x
	#pack $name.scrollvert -side right -fill y
    pack $name.c -side left -expand 1 -fill both
	if { $k12_mode == 0 } {
    	wm minsize $name 50 20
	} else {
		wm minsize $name 580 407
	}
    wm geometry $name $geometry
    # the "File" menu
	
    # The menus are instantiated here for the patch windows.
    # For the main window, they are created on load, at the 
    # top of this file.
    match_linux_wm [list menu $name.m -relief flat]
    match_linux_wm [list menu $name.m.file  -postcommand [concat pdtk_fixfilemenu $name.m.file] -tearoff $pd_tearoff]
    $name.m add cascade -label File -menu $name.m.file

    $name.m.file add command -label New -command {menu_new} \
        -accelerator [accel_munge "Ctrl+n"]

    $name.m.file add command -label Open -command {menu_open} \
        -accelerator [accel_munge "Ctrl+o"]

	if { $k12_mode == 1 } {
		$name.m.file add command -label {K12 Demos} -command {menu_k12_open_demos}
	}

    match_linux_wm [list $name.m.file add separator]

    $name.m.file add command -label Save -command [concat menu_save $name] \
        -accelerator [accel_munge "Ctrl+s"]

    $name.m.file add command -label "Save as..." \
        -command [concat menu_saveas $name] \
        -accelerator [accel_munge "Ctrl+S"]
	if { $k12_mode == 0 } {
		match_linux_wm [list $name.m.file add separator]

		# arrange menus according to Apple HIG
		if {$pd_nt != 2 } {
			$name.m.file add command -label "Message..." -command {menu_send} \
				-accelerator [accel_munge "Ctrl+m"]
			# these are now part of Preferences... on Mac OS X
		    $name.m.file add command -label Path... \
		        -command {pd pd start-path-dialog \;} 
		    $name.m.file add command -label Startup... \
		        -command {pd pd start-startup-dialog \;} 
		} else { 
			# Cmd-m is minimize window on Mac OS X		
			$name.m.file add command -label "Message..." -command {menu_send}
			match_linux_wm [list $name.m.file add  separator]
			$name.m.file add command -label "Make app from patch..." \
				-command {menu_makeapp 0}
			$name.m.file add command -label "Make app from folder..." \
				-command {menu_makeapp 1}
		}
		match_linux_wm [list $name.m.file add separator]
		$name.m.file add command -label "Print..." -command [concat menu_print $name] \
		    -accelerator [accel_munge "Ctrl+p"]
	}
    # update recent files
    match_linux_wm [list $name.m.file add separator]
    $name.m.file add command -label "No Recent Files" -state disabled
    #match_linux_wm [list $name.m.file add separator]
    #if {[llength $::recentfiles_list] > 0} {
    #    ::pd_menus::update_recentfiles_menu $name.m.file false
    #}

	match_linux_wm [list $name.m.file add separator]
    $name.m.file add command -label Close \
        -command [concat menu_close $name] \
        -accelerator [accel_munge "Ctrl+w"]

	if {$pd_nt != 2} {
		# Mac OS X doesn't put Quit on the File menu
		$name.m.file add command -label Quit -command {menu_quit} \
			-accelerator [accel_munge "Ctrl+q"]
	}

    # the "Edit" menu
    match_linux_wm [list menu $name.m.edit -postcommand [concat menu_fixeditmenu $name] -tearoff $pd_tearoff]
    $name.m add cascade -label Edit -menu $name.m.edit
    
    $name.m.edit add command -label Undo -command [concat menu_undo $name] \
        -accelerator [accel_munge "Ctrl+z"]

    $name.m.edit add command -label Redo -command [concat menu_redo $name] \
        -accelerator [accel_munge "Ctrl+Z"]

    match_linux_wm [list $name.m.edit add separator]

    $name.m.edit add command -label Cut -command [concat menu_cut $name] \
        -accelerator [accel_munge "Ctrl+x"] -state disabled

    $name.m.edit add command -label Copy -command [concat menu_copy $name] \
        -accelerator [accel_munge "Ctrl+c"] -state disabled

    $name.m.edit add command -label Paste \
        -command [concat menu_paste $name] \
        -accelerator [accel_munge "Ctrl+v"]

	if {!$global_clipboard} {
		$name.m.edit entryconfigure "Paste" -state disabled
	} else {
		$name.m.edit entryconfigure "Paste" -state normal
	}

    $name.m.edit add command -label Duplicate \
        -command [concat menu_duplicate $name] \
        -accelerator [accel_munge "Ctrl+d"]

	if {!$global_selection} {
		$name.m.edit entryconfigure "Duplicate" -state disabled
	} else {
		$name.m.edit entryconfigure "Duplicate" -state normal
	}

    $name.m.edit add command -label {Select all} \
        -command [concat menu_selectall $name] \
        -accelerator [accel_munge "Ctrl+a"]

	if { $k12_mode == 0 } {
		$name.m.edit add command -label {Reselect} \
		    -command [concat menu_reselect $name] \
		    -accelerator "Ctrl+Enter" -state disabled
	}

    match_linux_wm [list $name.m.edit add separator]

	$name.m.edit add command -label {Tidy Up} \
		-command [concat menu_tidyup $name] \
	    -accelerator [accel_munge "Ctrl+y"] -state disabled

	if { $k12_mode == 0 } {

		$name.m.edit add command -label {Bring To Front} \
			-command [concat popup_action $name 3] \
		    -accelerator [accel_munge "Ctrl+Up"] -state disabled

		$name.m.edit add command -label {Send To Back} \
			-command [concat popup_action $name 4] \
		    -accelerator [accel_munge "Ctrl+Down"] -state disabled
	}

	match_linux_wm [list $name.m.edit add separator]

	if { $k12_mode == 0 } {

		#if {$pd_nt == 2} { # no key command on Mac OS X, conflicts with standard
		#	$name.m.edit add command -label {Text Editor} \
		#		-command [concat menu_texteditor $name]
		#} else {
		#	$name.m.edit add command -label {Text Editor} \
		#		-accelerator [accel_munge "Ctrl+t"] \
		#		-command [concat menu_texteditor $name]
		#}

		$name.m.edit add command -label Font \
		    -command [concat menu_font $name] 
	}

## jsarlo
    $name.m.edit add checkbutton -label "Cord Inspector" \
        -indicatoron false -selectcolor black \
        -command [concat menu_magicglass $name] \
        -accelerator [accel_munge "Ctrl+r"]

    #if { $editable == 0 } {
    #       $name.m.edit entryconfigure "Cord Inspector" -indicatoron false }
  
    match_linux_wm [list $name.m.edit add separator]
## end jsarlo

	$name.m.edit add command -label "Toggle console" \
	    -accelerator [accel_munge "Ctrl+R"] \
	    -command [concat .controls.switches.console invoke]

	$name.m.edit add command -label "Clear console" \
	    -accelerator [accel_munge "Ctrl+L"] \
	    -command [concat menu_clear_console]

	match_linux_wm [list $name.m.edit add separator]

	if { $k12_mode == 0 } {
    
		# Apple, Microsoft, and others put find functions in the Edit menu.
		$name.m.edit add command -label {Find...} \
		    -accelerator [accel_munge "Ctrl+f"] \
		    -command [concat menu_findobject $name] 
		$name.m.edit add command -label {Find Again} \
		    -accelerator [accel_munge "Ctrl+g"] \
		    -command [concat menu_findagain $name] 
		$name.m.edit add command -label {Find last error} \
		    -command [concat menu_finderror] 

		match_linux_wm [list $name.m.edit add separator]

		############iemlib##################
		# instead of "red = #BC3C60" we take "grey85", so there is no difference,
		# if widget is selected or not.

		$name.m.edit add checkbutton -label "Autotips" \
		    -indicatoron false -selectcolor black \
		    -command [concat menu_tooltips $name] \
		    -accelerator [accel_munge "Ctrl+E"]
	}

    $name.m.edit add checkbutton -label "Edit mode" \
        -indicatoron false -selectcolor black \
        -command [concat menu_editmode $name] \
        -accelerator [accel_munge "Ctrl+e"]
    if {$k12_mode == 0} {
    	match_linux_wm [list $name.m.edit add separator]
        $name.m.edit add command -label {Preferences...} \
        -command {::dialog_prefs::open_prefs_dialog .}
    }

	if { $editable == 1 } {
    	$name.m.edit entryconfigure "Edit mode" -background "#7dd37d" -foreground black
	}

	if { $k12_mode == 0 && $autotips == 1 } {
    	$name.m.edit entryconfigure "Autotips" -background "#7dd37d" -foreground "#dddddd"
	}

	set ::editmode($name) $editable

	pdtk_canvas_recolor $name $editable

	#if { $magicglass == 1 } {
    #	$name.m.edit entryconfigure "Cord Inspector" -background "#7dd37d"
	#	menu_magicglass $name
	#}

    #if { $editable == 0 } {
    #    $name.m.edit entryconfigure "Edit mode" -indicatoron false 
    #}

    
    ############iemlib##################

	if { $k12_mode == 0 } {

		# the "Put" menu
		match_linux_wm [list menu $name.m.put -tearoff $put_tearoff]
		$name.m add cascade -label Put -menu $name.m.put

		$name.m.put add command -label Object \
		    -command [concat menu_object $name 0] \
		    -accelerator [accel_munge "Ctrl+1"]

		$name.m.put add command -label Message \
		    -command [concat menu_message $name 0] \
		    -accelerator [accel_munge "Ctrl+2"]

		$name.m.put add command -label Number \
		    -command [concat menu_floatatom $name 0] \
		    -accelerator [accel_munge "Ctrl+3"]

		$name.m.put add command -label Symbol \
		    -command [concat menu_symbolatom $name 0] \
		    -accelerator [accel_munge "Ctrl+4"]

		$name.m.put add command -label Comment \
		    -command [concat menu_comment $name 0] \
		    -accelerator [accel_munge "Ctrl+5"]

		match_linux_wm [list $name.m.put add separator]
		
		############iemlib##################

		$name.m.put add command -label Bang \
		    -command [concat menu_bng $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+b"]
		
		$name.m.put add command -label Toggle \
		    -command [concat menu_toggle $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+t"]
		
		$name.m.put add command -label Number2 \
		    -command [concat menu_numbox $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+n"]
		
		$name.m.put add command -label Vslider \
		    -command [concat menu_vslider $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+v"]
		
		$name.m.put add command -label Hslider \
		    -command [concat menu_hslider $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+h"]
		
		$name.m.put add command -label Vradio \
		    -command [concat menu_vradio $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+d"]
		
		$name.m.put add command -label Hradio \
		    -command [concat menu_hradio $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+i"]
		
		$name.m.put add command -label VU \
		    -command [concat menu_vumeter $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+u"]
		
		$name.m.put add command -label Canvas \
		    -command [concat menu_mycnv $name 0] \
		    -accelerator [accel_munge "Shift+Ctrl+c"]

		############iemlib##################
		
		match_linux_wm [list $name.m.put add separator]
		
		$name.m.put add command -label Graph \
		    -command [concat menu_graph $name] 

		$name.m.put add command -label Array \
		    -command [concat menu_array $name] 

		# the find menu
		# Apple, Microsoft, and others put find functions in the Edit menu.
		# But in order to move these items to the Edit menu, the Find menu
		# handling needs to be dealt with, including this line in g_canvas.c:
		#         sys_vgui(".mbar.find delete %d\n", i);
		# <hans@at.or.at>
		#match_linux_wm [list menu $name.m.find -tearoff $put_tearoff]
		#$name.m add cascade -label Find -menu $name.m.find
		#
		#$name.m.find add command -label {Find...} \
		#    -accelerator [accel_munge "Ctrl+f"] \
		#    -command [concat menu_findobject $name] 
		#$name.m.find add command -label {Find Again} \
		#    -accelerator [accel_munge "Ctrl+g"] \
		#    -command [concat menu_findagain $name] 
		#$name.m.find add command -label {Find last error} \
		#    -command [concat menu_finderror] 
		
		# the window menu
		match_linux_wm [list menu $name.m.windows -postcommand \
			[concat menu_fixwindowmenu $name] -tearoff $pd_tearoff]

		if {$pd_nt == 2} {
			$name.m.windows add command -label {Minimize} \
				-command "menu_minimize $name" -accelerator [accel_munge "Ctrl+m"]
			$name.m.windows add command -label {Zoom} -command "menu_zoom $name"
		} else {
			$name.m.windows add command -label "Next Window" -command {menu_raisenextwindow} \
				-accelerator "Ctrl+PageDown"
			$name.m.windows add command -label "Previous Window" -command {menu_raisepreviouswindow} \
				-accelerator "Ctrl+PageUp"
		}
		match_linux_wm [list $name.m.windows add separator]
		$name.m.windows add command -label {parent window}\
		    -command [concat menu_windowparent $name] 
		$name.m.windows add command -label {Pd & Console} -command menu_raise_console \
			-accelerator [accel_munge "Ctrl+;"]
		match_linux_wm [list $name.m.windows add separator]

		# the audio menu
		match_linux_wm [list menu $name.m.audio -tearoff $pd_tearoff]

		if {$pd_nt != 2} {
		    $name.m add cascade -label Windows -menu $name.m.windows
		    $name.m add cascade -label Media -menu $name.m.audio
		} else {
		    $name.m add cascade -label Media -menu $name.m.audio
		    $name.m add cascade -label Window -menu $name.m.windows
		    # the MacOS X app menu
		    menu $name.m.apple -tearoff $pd_tearoff
		    $name.m add cascade -label "Apple" -menu $name.m.apple 
		}

		# the "Help" menu

		match_linux_wm [list menu $name.m.help -tearoff $pd_tearoff]
		$name.m add cascade -label Help -menu $name.m.help

		menu_addstd $name.m
	}

    # the popup menu
	match_linux_wm [list menu $name.popup -tearoff false]
	if { $k12_mode == 0 } {
		$name.popup add command -label {Properties} \
		    -command [concat popup_action $name 0]
		$name.popup add command -label {Open} \
		    -command [concat popup_action $name 1]
		$name.popup add command -label {Help} \
		    -command [concat popup_action $name 2]
		match_linux_wm [list $name.popup add separator]
		$name.popup add command -label {To Front} \
		    -command [concat popup_action $name 3]
		$name.popup add command -label {To Back} \
		    -command [concat popup_action $name 4]
	} else {
		$name.popup add command -label {Properties} -state disabled \
		    -command [concat popup_action $name 0] 
		$name.popup add command -label {Open} -state disabled \
		    -command [concat popup_action $name 1]
		$name.popup add command -label {Help} \
		    -command [concat popup_action $name 2]
		match_linux_wm [list $name.popup add separator]
		$name.popup add command -label {To Front} -state disabled \
		    -command [concat popup_action $name 3]
		$name.popup add command -label {To Back} -state disabled \
		    -command [concat popup_action $name 4]
	}

    # fix menu font size on Windows with tk scaling = 1
    if {$pd_nt == 1} {
        $name.m.file configure -font menuFont
        $name.m.edit configure -font menuFont
        $name.m.find configure -font menuFont
        $name.m.put configure -font menuFont
        $name.m.windows configure -font menuFont
        $name.m.audio configure -font menuFont
        $name.m.help configure -font menuFont
        $name.popup configure -font menuFont
    }

    # WM protocol
    wm protocol $name WM_DELETE_WINDOW [concat menu_close $name]

    # bindings.
    # this is idiotic -- how do you just sense what mod keys are down and
    # pass them on? I can't find it anywhere.
    # Here we encode shift as 1, control 2, alt 4, in agreement
    # with definitions in g_canvas.c.  The third button gets "8" but we don't
    # bother with modifiers there.
    # We don't handle multiple clicks yet.

    bind $name.c <Configure> {pdtk_canvas_getscroll %W}
	#bind $name.c <Configure> {after 100 pdtk_canvas_getscroll_configure %W}
    bind $name.c <Button> {pdtk_canvas_click %W %x %y %b 0}
    bind $name.c <Shift-Button> {pdtk_canvas_click %W %x %y %b 1}
    bind $name.c <Control-Shift-Button> {pdtk_canvas_click %W %x %y %b 3}
    # Alt key is called Option on the Mac
    if {$pd_nt == 2} {
        bind $name.c <Option-Button> {pdtk_canvas_click %W %x %y %b 4}
        bind $name.c <Option-Shift-Button> {pdtk_canvas_click %W %x %y %b 5}
        bind $name.c <Option-Control-Button> {pdtk_canvas_click %W %x %y %b 6}
        bind $name.c <Mod1-Button> {pdtk_canvas_click %W %x %y %b 6}
        bind $name.c <Option-Control-Shift-Button> \
            {pdtk_canvas_click %W %x %y %b 7}
    } else {
        bind $name.c <Alt-Button> {pdtk_canvas_click %W %x %y %b 4}
        bind $name.c <Alt-Shift-Button> {pdtk_canvas_click %W %x %y %b 5}
        bind $name.c <Alt-Control-Button> {pdtk_canvas_click %W %x %y %b 6}
        bind $name.c <Alt-Control-Shift-Button> \
            {pdtk_canvas_click %W %x %y %b 7}
    }
    global pd_nt
    # button 2 is the right button on Mac; on other platforms it's button 3.
    if {$pd_nt == 2} {
        bind $name.c <Button-2> {pdtk_canvas_rightclick %W %x %y %b}
        bind $name.c <Control-Button> {pdtk_canvas_rightclick %W %x %y %b}
    } else {
        bind $name.c <Button-3> {pdtk_canvas_rightclick %W %x %y %b}
        bind $name.c <Control-Button> {pdtk_canvas_click %W %x %y %b 2}
    }
    #on linux, button 2 "pastes" from the X windows clipboard
    if {$pd_nt == 0} {
        bind $name.c <Button-2> {pdtk_canvas_middleclick %W %x %y %b 0;}
    }

    bind $name.c <ButtonRelease> {pdtk_canvas_mouseup %W %x %y %b}
    bind $name.c <Control-Key> {pdtk_canvas_ctrlkey %W %K 0}
    bind $name.c <Control-Shift-Key> {pdtk_canvas_ctrlkey %W %K 1}
    #    bind $name.c <Mod1-Key> {puts stderr [concat mod1 %W %K %A]}
    if {$pd_nt == 2} {
        bind $name.c <Mod1-Key> {pdtk_canvas_ctrlkey %W %K 0}
        bind $name.c <Mod1-Shift-Key> {pdtk_canvas_ctrlkey %W %K 1}
        bind $name.c <Mod1-BackSpace> {pdtk_canvas_sendkey %W 1 %K %A 0 1 %t}
        bind $name.c <Mod1-quoteleft> {menu_raisenextwindow}
    } else {
        bind $name.c <Control-Next>   {menu_raisenextwindow}
        bind $name.c <Control-Prior>  {menu_raisepreviouswindow} ;# needs Tcl/Tk 8.5
	}
    bind $name.c <Key> {pdtk_canvas_sendkey %W 1 %K %A 0 1 %t}
    bind $name.c <Shift-Key> {pdtk_canvas_sendkey %W 1 %K %A 1 1 %t}
    bind $name.c <KeyRelease> {pdtk_canvas_sendkey %W 0 %K %A 0 1 %t}
    bind $name.c <Motion> {pdtk_canvas_motion %W %x %y 0}
    bind $name.c <Shift-Motion> {pdtk_canvas_motion %W %x %y 1}
    bind $name.c <Control-Motion> {pdtk_canvas_motion %W %x %y 2}
    bind $name.c <Control-Shift-Motion> {pdtk_canvas_motion %W %x %y 3}

    # canvas bindings ---------------------------------------------------------
    # just for tooltips right now
	#$name.c bind all <Enter> "puts stderr {%x %y}"
    #$name.c bind inlet <Enter> "pdtk_canvas_enteritem %W %x %y inlet %t"
    #$name.c bind outlet <Enter> "pdtk_canvas_enteritem %W %x %y outlet %t"
    #$name.c bind text <Enter> "pdtk_canvas_enteritem %W %x %y text %t"
    #$name.c bind inlet <Leave> "pdtk_canvas_leaveitem %W inlet 0"
    #$name.c bind outlet <Leave> "pdtk_canvas_leaveitem %W outlet 0"
    #$name.c bind text <Leave> "pdtk_canvas_leaveitem %W text 0"
	
    if {$pd_nt == 2} {
        bind $name.c <Option-Motion> {pdtk_canvas_motion %W %x %y 4}
    } else { 
        bind $name.c <Alt-Motion> {pdtk_canvas_motion %W %x %y 4}
    }
    bind $name.c <Map> {pdtk_canvas_map %W}
    bind $name.c <Unmap> {pdtk_canvas_unmap %W}

    switch $pd_nt { 0 {
        bind $name.c <Button-4>  "pdtk_canvas_scroll $name.c y -1"
        bind $name.c <Button-5>  "pdtk_canvas_scroll $name.c y +1"
        bind $name.c <Shift-Button-4>  "pdtk_canvas_scroll $name.c x -1"
        bind $name.c <Shift-Button-5>  "pdtk_canvas_scroll $name.c x +1"
		#if { $k12_mode == 0 } {
		#    bind $name.c <Control-Button-4>  "pdtk_zoom $name 1"
		#    bind $name.c <Control-Button-5>  "pdtk_zoom $name -1"
		#}
    } default {
        bind $name.c  <MouseWheel> \
            "pdtk_canvas_scroll $name.c y \[expr -abs(%D)/%D\]"
        bind $name.c  <Shift-MouseWheel> \
            "pdtk_canvas_scroll $name.c x \[expr -abs(%D)/%D\]"
    }}

    #dnd bindtarget $name.c text/uri-list <Drop> { pdtk_canvas_makeobjs $name %D %x %y }

    # hack: we do catch because when reloading abstractions this never happens as the window is not created
    # for closed abstractions that appear as sub-patches
    #after idle [list catch { dnd bindtarget $name text/uri-list <Drop> { foreach file %D {open_file $file} } }]

    #    puts stderr "all done"
    #   after 1 [concat raise $name]
    global pdtk_canvas_mouseup_name
    set pdtk_canvas_mouseup_name ""

	bind $name <FocusIn> "menu_fixeditmenu $name"
	bind $name <FocusOut> "pdtk_canvas_leaveitem $name.c"
	if { $k12_mode == 1 } { pd [concat $name tooltips 1 \;] }

	# hack: we do catch because when reloading abstractions this never happens as the window is not created
    # for closed abstractions that appear as sub-patches
    catch { focus $name.c }

	if { $k12_mode == 1 && $k12_saveas_on_new == 1 } {
		after 1000 [concat pdtk_k12_saveas_on_new $name]
	}

	set ::scroll_on($name) 0
	set ::hit_scrollbar($name) 0
	#set ::scroll_was_cursor($name) 0
	set ::last_scroll_x($name) 0
	set ::last_scroll_y($name) 0
	set ::canvaswidth($name) 0
	set ::canvasheight($name) 0
}

set SCROLL_OPACITY 0.33
set HSCROLL_PAD_L 6
set HSCROLL_PAD_R 13
set VSCROLL_PAD_U 6
set VSCROLL_PAD_D 13
set SCROLL_PAD_EDGE 5
set SCROLL_THICKNESS 6
set scrollbar_color "#555"

proc pdtk_canvas_draw_scrollbars {name} {
	#puts stderr "pdtk_canvas_draw_scrollbars $name"
	global scrollbar_color
	global HSCROLL_PAD_L
	global HSCROLL_PAD_R
	global VSCROLL_PAD_U
	global VSCROLL_PAD_D
	global SCROLL_PAD_EDGE
	global SCROLL_THICKNESS
	global SCROLL_OPACITY
	set name [string trimright $name .c]
	catch {
		$name.c delete xscroll
		$name.c delete yscroll
	}
	if { $::xscrollable($name) == 1 } {
		set visible [$name.c xview]
		set vx1 [lindex $visible 0]
		set vx2 [lindex $visible 1]
		#if {$vx2 - $vx1 < 0.99} {
			set npix [expr int([winfo width $name.c]-$HSCROLL_PAD_L-$HSCROLL_PAD_R)]
			set width [expr int($npix * ($vx2 -$vx1))]
			set loffset [expr int($vx1 * $npix)] 
			set scrollx1 [expr [$name.c canvasx 0] + $HSCROLL_PAD_L + $loffset]
			set scrolly1 [expr [$name.c canvasy 0] + [winfo height $name.c] - $SCROLL_PAD_EDGE]
			set scrollx2 [expr $scrollx1 + $width]
			#puts stderr "$vx1 $vx2 $npix $width $loffset $scrollx1 $scrollx2"
			set hscroll [$name.c create polyline $scrollx1 $scrolly1 $scrollx2 $scrolly1 -stroke $scrollbar_color -strokewidth $SCROLL_THICKNESS -strokeopacity $SCROLL_OPACITY -tags xscroll -strokelinecap round]
			$name.c addtag noscroll withtag xscroll
			#$name.c bind $hscroll <Button-1> {pdtk_canvas_scroll_horizontal_click %W %x %y %b 0}
			$name.c bind $hscroll <Enter> {pdtk_canvas_enter_scrollbar %W %x %y}
			#$name.c bind $hscroll <Motion> {pdtk_canvas_enter_scrollbar %W}
			$name.c bind $hscroll <Leave> {pdtk_canvas_leave_scrollbar %W %x %y}
		#}
	}
	if { $::yscrollable($name) == 1 } {
		set visible [$name.c yview]
		set vy1 [lindex $visible 0]
		set vy2 [lindex $visible 1]
		#if {$vy2 - $vy1 < 0.99} {
			set npix [expr int([winfo height $name.c]-$VSCROLL_PAD_U-$VSCROLL_PAD_D)]
			set height [expr int($npix * ($vy2 -$vy1))]
			set toffset [expr int($vy1 * $npix)] 
			set scrollx1 [expr [$name.c canvasx 0] + [winfo width $name.c] - $SCROLL_PAD_EDGE]
			set scrolly1 [expr [$name.c canvasy 0] + $VSCROLL_PAD_U +$toffset]
			set scrolly2 [expr $scrolly1 + $height]
			#puts stderr "$vy1 $vy2 $npix $height $toffset $scrolly1 $scrolly2"
			set vscroll [$name.c create polyline $scrollx1 $scrolly1 $scrollx1 $scrolly2 -stroke $scrollbar_color -strokewidth $SCROLL_THICKNESS -strokeopacity $SCROLL_OPACITY -tags yscroll -strokelinecap round]
			$name.c addtag noscroll withtag yscroll
			#$name.c bind $vscroll <Button-1> {pdtk_canvas_scroll_vertical_click %W %x %y %b 0}
			$name.c bind $vscroll <Enter> {pdtk_canvas_enter_scrollbar %W %x %y}
			#$name.c bind $vscroll <Motion> {pdtk_canvas_enter_scrollbar %W}
			$name.c bind $vscroll <Leave> {pdtk_canvas_leave_scrollbar %W %x %y}
		#}
	}
	pdtk_canvas_update_sticky_tip $name.c
}

proc pdtk_canvas_enter_scrollbar {name x y} {
	set name [string trimright $name .c]
	if { $::hit_scrollbar($name) == 0 } {
		set x [$name.c canvasx $x]
		set y [$name.c canvasy $y]
		set inside 0
		if { $::yscrollable($name) } {
			set coords [$name.c bbox yscroll]
			foreach {xa ya xb yb} $coords {
				#puts stderr "Y | $x $y | $xa $xb $ya $yb"
				if { [expr $xa + 3] < $x && [expr $xb - 3] > $x && [expr $ya + 5] < $y && [expr $yb - 5] > $y } {
					 #puts stderr "inside Y"
					 set inside 1
				}
			}
		}
		if { $::xscrollable($name) } {
			set coords [$name.c bbox xscroll]
			foreach {xa ya xb yb} $coords {
				#puts stderr "Y | $x $y | $xa $xb $ya $yb"
				if { [expr $xa + 5] < $x && [expr $xb - 5] > $x && [expr $ya + 3] < $y && [expr $yb - 3] > $y } {
					 #puts stderr "inside X"
					 set inside 1
				}
			}
		}
		#set ::scroll_was_cursor($name) [$name cget -cursor]
		#$name configure -cursor $cursor_runmode_clickme
		if { $inside == 1 } {
			set ::hit_scrollbar($name) 1
		}
		#puts stderr scrollbar_enter
	}
}

proc pdtk_canvas_leave_scrollbar {name x y} {
	#puts stderr pre_scrollbar_leave
	set name [string trimright $name .c]
	if { $::hit_scrollbar($name) != 0 } {
		set x [$name.c canvasx $x]
		set y [$name.c canvasy $y]
		if { $::yscrollable($name) } {
			set coords [$name.c bbox yscroll]
			foreach {xa ya xb yb} $coords {
				#puts stderr "Y | $x $y | $xa $xb $ya $yb"
				if { [expr $xa + 3] < $x && [expr $xb - 3] > $x && [expr $ya + 5] < $y && [expr $yb - 5] > $y } {
					 #puts stderr "Y still inside"
					 return
				}
			}
		}
		if { $::xscrollable($name) } {
			set coords [$name.c bbox xscroll]
			foreach {xa ya xb yb} $coords {
				#puts stderr "Y | $x $y | $xa $xb $ya $yb"
				if { [expr $xa + 5] < $x && [expr $xb - 5] > $x && [expr $ya + 3] < $y && [expr $yb - 3] > $y } {
					 #puts stderr "X still inside"
					 return
				}
			}
		}
		set ::hit_scrollbar($name) 0
		#$name configure -cursor $::scroll_was_cursor($name)
		#puts stderr scrollbar_leave
	}
}

# from c
proc pdtk_canvas_scroll_xy_click {name x y b} {
	set name [string trimright $name .c]
	set ::scroll_on($name) $b
	#set ::last_scroll_x($name) $x
	#set ::last_scroll_y($name) $y
	#puts stderr "XY CLICK $name $x $y"
}

proc pdtk_canvas_detect_scroll_click {name x y b mod} {
	set xc [$name.c canvasx $x]
	set yc [$name.c canvasy $y]
	if { $::yscrollable($name) } {
		set coords [$name.c bbox yscroll]
		foreach {xa ya xb yb} $coords {
			#puts stderr "Y | $x $y | $xa $xb $ya $yb"
			if { [expr $xa + 3] < $xc && [expr $xb - 3] > $xc && [expr $ya + 5] < $yc && [expr $yb - 5] > $yc } {
				 pdtk_canvas_scroll_vertical_click $name.c $x $y $b $mod
				 return
			}
		}
	}
	if { $::xscrollable($name) } {
		set coords [$name.c bbox xscroll]
		foreach {xa ya xb yb} $coords {
			#puts stderr "Y | $x $y | $xa $xb $ya $yb"
			if { [expr $xa + 5] < $xc && [expr $xb - 5] > $xc && [expr $ya + 3] < $yc && [expr $yb - 3] > $yc } {
				 pdtk_canvas_scroll_horizontal_click $name.c $x $y $b $mod
			}
		}
	}
}

proc pdtk_canvas_scroll_horizontal_click {name x y b mod} {
	#puts stderr "HORIZONTAL CLICK $name $x $y $b $mod"
	set name [string trimright $name .c]
	if { $b == 1 } {
		set ::scroll_on($name) 1
		#set ::hit_scrollbar($name) 1
	} else {
		set ::scroll_on($name) 0
		pdtk_canvas_leave_scrollbar $name $x $y
	}
	#puts stderr $::scroll_on($name)
	set ::last_scroll_x($name) $x
}

#scroll_on states:
#0 = no scrolling
#1 = horizontal
#2 = vertical
#3 = both (middle click)

proc pdtk_canvas_scroll_horizontal_motion {name x y mod} {
	global HSCROLL_PAD_L
	global HSCROLL_PAD_R
	set name [string trimright $name .c]
	#puts stderr "HORIZONTAL MOTION $name $x $y $mod $::last_scroll_x($name)"
	if {$::xscrollable($name) && ($::scroll_on($name) == 1 || $::scroll_on($name) == 3)} {
		set deltax [expr $::last_scroll_x($name) - $x]
		#puts stderr "deltax=$deltax"
		if { $deltax != 0 } {
			set visible [$name.c xview]
			set vx1 [lindex $visible 0]
			set vx2 [lindex $visible 1]
			if {$::scroll_on($name) == 1} {
				set perpixdelta [expr (1.0)/([winfo width $name.c]-$HSCROLL_PAD_L-$HSCROLL_PAD_R)]
			} else {
				set perpixdelta [expr 1.0/$::canvasheight($name)]
			}
			#puts stderr "scrolling... $vx1 $vx2 $perpixdelta"
			#$name xview scroll [expr -$deltax] units
			set displace [expr $perpixdelta * $deltax]
			if {$::scroll_on($name) == 3} {
				set displace [expr -$displace]
			}
			$name.c xview moveto [expr $vx1 - $displace]
			pdtk_canvas_draw_scrollbars $name
		}
	}
	set ::last_scroll_x($name) $x
}

proc pdtk_canvas_scroll_vertical_click {name x y b mod} {
	#puts stderr "VERTICAL CLICK $name $x $y $b $mod"
	set name [string trimright $name .c]
	if { $b == 1 } {
		set ::scroll_on($name) 2
		#set ::hit_scrollbar($name) 1
	} else {
		set ::scroll_on($name) 0
		pdtk_canvas_leave_scrollbar $name $x $y
	}
	#puts stderr $::scroll_on($name)
	set ::last_scroll_y($name) $y
}

proc pdtk_canvas_scroll_vertical_motion {name x y mod} {
	global VSCROLL_PAD_U
	global VSCROLL_PAD_D
	set name [string trimright $name .c]
	#puts stderr "VERTICAL MOTION $name $x $y $mod $::last_scroll_y($name)"
	if {$::yscrollable($name) && $::scroll_on($name) >= 2} {
		set deltay [expr $::last_scroll_y($name) - $y]
		#puts stderr "deltay=$deltay"
		if { $deltay != 0 } {
			set visible [$name.c yview]
			set vy1 [lindex $visible 0]
			set vy2 [lindex $visible 1]
			if {$::scroll_on($name) == 2} {
				set perpixdelta [expr (1.0)/([winfo height $name.c]-$VSCROLL_PAD_U-$VSCROLL_PAD_D)]
			} else {
				set perpixdelta [expr 1.0/$::canvasheight($name)]
			}
			#puts stderr "scrolling... $vy1 $vy2 $perpixdelta $deltay"
			#$name xview scroll [expr -$deltax] units
			set displace [expr $perpixdelta * $deltay]
			if {$::scroll_on($name) == 3} {
				set displace [expr -$displace]
			}
			#puts stderr "$name.c yview moveto [expr $vy1 - $displace]"
			$name.c yview moveto [expr $vy1 - $displace]
			pdtk_canvas_draw_scrollbars $name
		}
	}
	set ::last_scroll_y($name) $y
}

proc pdtk_k12_saveas_on_new {name} {
	global k12_saveas_on_new
	pd [concat $name menusaveas \;]
	set k12_saveas_on_new 0
}

proc pdtk_noselect {name} {
	set topname [string trimright $name .c]
	pd [concat $topname noselect \;]
}

#### jsarlo #####
proc pdtk_array_listview_setpage {arrayName page} {
    global pd_array_listview_page
    set pd_array_listview_page($arrayName) $page
}

proc pdtk_array_listview_changepage {arrayName np} {
    global pd_array_listview_page
    pdtk_array_listview_setpage \
        $arrayName [expr $pd_array_listview_page($arrayName) + $np]
    pdtk_array_listview_fillpage $arrayName
}

proc pdtk_array_listview_fillpage {arrayName} {
    global pd_array_listview_page
    global pd_array_listview_id
    set windowName [format ".%sArrayWindow" $arrayName]
    set topItem [expr [lindex [$windowName.lb yview] 0] * \
                     [$windowName.lb size]]
    
    if {[winfo exists $windowName]} {
        set cmd "$pd_array_listview_id($arrayName) \
               arrayviewlistfillpage \
               $pd_array_listview_page($arrayName) \
               $topItem"
        
        pd [concat $cmd \;]
    }
}

proc pdtk_array_listview_new {id arrayName page} {
    global pd_nt
    global pd_array_listview_page
    global pd_array_listview_id
    global fontname fontweight
    set pd_array_listview_page($arrayName) $page
    set pd_array_listview_id($arrayName) $id
    set windowName [format ".%sArrayWindow" $arrayName]
    if [winfo exists $windowName] then [destroy $windowName]
    toplevel $windowName -class [winfo class .]
	wm geometry $windowName 220x400
	wm minsize $windowName 220 400
	# pdtk_standardkeybindings $windowName
	bind $windowName <Control-w> [list destroy $windowName]
	bind $windowName <Control-q> {menu_quit}
	match_linux_wm [list $windowName configure]
    wm protocol $windowName WM_DELETE_WINDOW \
        "pdtk_array_listview_close $id $arrayName"
    wm title $windowName [concat $arrayName "(list view)"]
    # FIXME
    set font 9
    set $windowName.lb [match_linux_wm [list listbox $windowName.lb \
							-height 20 -width 25 \
                            -selectmode extended \
                            -font [format {{%s} %d %s} $fontname $font $fontweight]\
                            -yscrollcommand "$windowName.lb.sb set"]]
    set $windowName.lb.sb [match_linux_wm [list scrollbar $windowName.lb.sb \
                               -command "$windowName.lb yview" -orient vertical]]
    #place configure $windowName.lb.sb -relheight 1 -relx 0.9 -relwidth 0.1
    pack $windowName.lb -expand 1 -fill both
	pack $windowName.lb.sb -side right -fill y
    bind $windowName.lb <Double-ButtonPress-1> \
        "pdtk_array_listview_edit $arrayName $page $font"
    # handle copy/paste
    if {$pd_nt == 0} {
        selection handle $windowName.lb \
            "pdtk_array_listview_lbselection $arrayName"
    } else {
        if {$pd_nt == 1} {
            bind $windowName.lb <ButtonPress-3> \
                "pdtk_array_listview_popup $arrayName"
        } 
    }
    set $windowName.prevBtn [match_linux_wm [list button $windowName.prevBtn -text "<-" \
                                 -command "pdtk_array_listview_changepage $arrayName -1"]]
    set $windowName.nextBtn [match_linux_wm [list button $windowName.nextBtn -text "->" \
                                 -command "pdtk_array_listview_changepage $arrayName 1"]]
    pack $windowName.prevBtn -side left -expand 1 -padx 3 -pady 3
    pack $windowName.nextBtn -side left -expand 1 -padx 3 -pady 3
    focus $windowName
}

proc pdtk_array_listview_lbselection {arrayName off size} {
    set windowName [format ".%sArrayWindow" $arrayName]
    set itemNums [$windowName.lb curselection]
    set cbString ""
    for {set i 0} {$i < [expr [llength $itemNums] - 1]} {incr i} {
        set listItem [$windowName.lb get [lindex $itemNums $i]]
        append cbString [string range $listItem \
                             [expr [string first ") " $listItem] + 2] \
                             end]
        append cbString "\n"
    }
    set listItem [$windowName.lb get [lindex $itemNums $i]]
    append cbString [string range $listItem \
                         [expr [string first ") " $listItem] + 2] \
                         end]
    set last $cbString
}

# Win32 uses a popup menu for copy/paste
proc pdtk_array_listview_popup {arrayName} {
    set windowName [format ".%sArrayWindow" $arrayName]
    if [winfo exists $windowName.popup] then [destroy $windowName.popup]
    menu $windowName.popup -tearoff false
    $windowName.popup add command -label {Copy} \
        -command "pdtk_array_listview_copy $arrayName; \
                  destroy $windowName.popup"
    $windowName.popup add command -label {Paste} \
        -command "pdtk_array_listview_paste $arrayName; \
                  destroy $windowName.popup"
    tk_popup $windowName.popup [winfo pointerx $windowName] \
        [winfo pointery $windowName] 0
}

proc pdtk_array_listview_copy {arrayName} {
    set windowName [format ".%sArrayWindow" $arrayName]
    set itemNums [$windowName.lb curselection]
    set cbString ""
    for {set i 0} {$i < [expr [llength $itemNums] - 1]} {incr i} {
        set listItem [$windowName.lb get [lindex $itemNums $i]]
        append cbString [string range $listItem \
                             [expr [string first ") " $listItem] + 2] \
                             end]
        append cbString "\n"
    }
    set listItem [$windowName.lb get [lindex $itemNums $i]]
    append cbString [string range $listItem \
                         [expr [string first ") " $listItem] + 2] \
                         end]
    clipboard clear
    clipboard append $cbString
}

proc pdtk_array_listview_paste {arrayName} {
    global pd_array_listview_page
    global pd_array_listview_pagesize
    set cbString [selection get -selection CLIPBOARD]
    set lbName [format ".%sArrayWindow.lb" $arrayName]
    set itemNum [lindex [$lbName curselection] 0]
    set splitChars ", \n"
    set itemString [split $cbString $splitChars]
    set flag 1
    for {set i 0; set counter 0} {$i < [llength $itemString]} {incr i} {
        if {[lindex $itemString $i] != {}} {
            pd [concat $arrayName [expr $itemNum + \
                                       [expr $counter + \
                                            [expr $pd_array_listview_pagesize \
                                                 * $pd_array_listview_page($arrayName)]]] \
                    [lindex $itemString $i] \;]
            incr counter
            set flag 0
        }
    }
}

proc pdtk_array_listview_edit {arrayName page font} {
    global pd_array_listview_entry
    global pd_nt
    global fontname fontweight
    set lbName [format ".%sArrayWindow.lb" $arrayName]
    if {[winfo exists $lbName.entry]} {
        pdtk_array_listview_update_entry \
            $arrayName $pd_array_listview_entry($arrayName)
        unset pd_array_listview_entry($arrayName)
    }
    set itemNum [$lbName index active]
    set pd_array_listview_entry($arrayName) $itemNum
    set bbox [$lbName bbox $itemNum]
    set y [expr [lindex $bbox 1] - 4]
    set $lbName.entry [entry $lbName.entry \
                           -font [format {{%s} %d %s} $fontname $font $fontweight]]
    $lbName.entry insert 0 []
    place configure $lbName.entry -relx 0 -y $y -relwidth 1
    lower $lbName.entry
    focus $lbName.entry
    bind $lbName.entry <Return> \
        "pdtk_array_listview_update_entry $arrayName $itemNum;"
}

proc pdtk_array_listview_update_entry {arrayName itemNum} {
    global pd_array_listview_page
    global pd_array_listview_pagesize
    set lbName [format ".%sArrayWindow.lb" $arrayName]
    set splitChars ", \n"
    set itemString [split [$lbName.entry get] $splitChars]
    set flag 1
    for {set i 0; set counter 0} {$i < [llength $itemString]} {incr i} {
        if {[lindex $itemString $i] != {}} {
            pd [concat $arrayName [expr $itemNum + \
                                       [expr $counter + \
                                            [expr $pd_array_listview_pagesize \
                                                 * $pd_array_listview_page($arrayName)]]] \
                    [lindex $itemString $i] \;]
            incr counter
            set flag 0
        }
    }
    pdtk_array_listview_fillpage $arrayName
    destroy $lbName.entry
}

proc pdtk_array_listview_closeWindow {arrayName} {
    set windowName [format ".%sArrayWindow" $arrayName]
    destroy $windowName
}

proc pdtk_array_listview_close {id arrayName} {
    pdtk_array_listview_closeWindow $arrayName
    set cmd [concat $id "arrayviewclose" \;]
    pd $cmd
}
##### end jsarlo #####

#################### event binding procedures ################

#get the name of the toplevel window for a canvas; this is also
#the name of the canvas object in Pd.

#proc pdtk_canvas_autoscrollbars {name x y} {
#    set size [$name bbox all]
#	set x2 [lindex $size 2]
#	set y2 [lindex $size 3]
#    set rootname [winfo parent $name]
#	if {$x > $x2} {pack forget $rootname.scrollhort}
#	if {$y > $y2} {pack forget $rootname.scrollvert}
#	if {$x < $x2} {pack $rootname.scrollhort -side bottom \
#                   -fill x -before $rootname.c}
#	if {$y < $y2} {pack $rootname.scrollvert -side right \
#                   -fill y -before $rootname.c}
#}

proc pdtk_canvas_toggle_scrollbars {rootname x} {
    if {$x == 1} {
		set ::scroll($rootname) 1
		set ::xscrollable($rootname) 1
		set ::yscrollable($rootname) 1
    } elseif {$x == 0} {
		set ::scroll($rootname) 0
		set ::xscrollable($rootname) 0
		set ::yscrollable($rootname) 0
    }
	if {[info exists ::loaded($rootname)]} {
		#puts stderr getscroll
		pdtk_canvas_getscroll $rootname.c
	}
}

# proc pdtk_canvas_set_scrollless {rootname} {
#	# EXPERIMENTAL: set scroll to permanently disabled for array and scalar GOP windows
#	set ::scroll($rootname) -1
#}

proc pdtk_set_canvas_background {rootname color} {
	set ::canvas_color($rootname) $color
	if {[info exists ::loaded($rootname)]} {
		$rootname.c configure -background $::canvas_color($rootname)
	}
}

proc pdtk_wm_topmost {rootname x} {
	set ::topmost($rootname) $x
	if {[info exists ::loaded($rootname)]} {
		wm attributes $rootname -topmost $x
	}
}

proc pdtk_wm_resize {rootname x} {
	set ::resize($rootname) $x
	if {[info exists ::loaded($rootname)]} {
		wm resizable $rootname $x $x
	}
}

proc pdtk_toggle_console {x} {
	if {$x==0} {
		.controls.switches.console instate {selected} {
			.controls.switches.console invoke
		}
	} elseif {$x==1} {
		.controls.switches.console instate {!selected} {
			.controls.switches.console invoke
		}
	}
}

proc pdtk_canvas_toggle_menu {rootname x} {
    #set rootname [winfo parent $name]
	global k12_mode
    if {$x == 1} {
		set ::menu($rootname) 1
		if {[info exists ::loaded($rootname)]} {
    		$rootname configure -menu $rootname.m
			#pack $rootname.eyecandy -fill x -expand 0 -before $rootname.c
			if { $k12_mode == 1 } {
				pack $rootname.k12frame  -side left -fill y -before $rootname.c
				wm minsize $rootname 580 532
			}
		}
    } elseif {$x == 0}  {
		set ::menu($rootname) 0
		if {[info exists ::loaded($rootname)]} {
    		$rootname configure -menu ""
			#pack forget $rootname.eyecandy
			if { $k12_mode == 1 } {
				pack forget $rootname.k12frame
				wm minsize $rootname 50 20
			}
		}
    }
}

proc canvastosym {name} {
    string range $name 0 [expr [string length $name] - 3]
}

set pdtk_lastcanvasconfigured ""
set pdtk_lastcanvasconfiguration ""
set pdtk_lastcanvasconfiguration2 ""

proc pdtk_canvas_checkgeometry {topname} {
    set boo [winfo geometry $topname.c]
    set boo2 [wm geometry $topname]
    global pdtk_lastcanvasconfigured
    global pdtk_lastcanvasconfiguration
    global pdtk_lastcanvasconfiguration2
    if {$topname != $pdtk_lastcanvasconfigured || \
            $boo != $pdtk_lastcanvasconfiguration || \
            $boo2 != $pdtk_lastcanvasconfiguration2} {
        set pdtk_lastcanvasconfigured $topname
        set pdtk_lastcanvasconfiguration $boo
        set pdtk_lastcanvasconfiguration2 $boo2
        pd $topname relocate $boo $boo2 \;
    }
}

# from newer pd branch
proc pdtk_canvas_mouse {name x y b f} {
    pd [canvastosym $name] mouse [$name canvasx $x] [$name canvasy $y] $b $f \;
}

proc pdtk_canvas_sendclick {name x y b f} {
    pd [canvastosym $name] mouse [$name canvasx $x] [$name canvasy $y] $b $f \;
}

proc pdtk_canvas_sendmiddleclick {name x y b f} {
    pd [canvastosym $name] mouse-2 [$name canvasx $x] [$name canvasy $y] $b $f \;
}

proc pdtk_canvas_click {name x y b f} {
    focus $name
    if { $b == 6 } {
        pdtk_canvas_scroll $name x -1
	} elseif { $b == 7 } {
        pdtk_canvas_scroll $name x +1
	} else {
	    set scroll_name [string trimright $name .c]
	    pdtk_canvas_detect_scroll_click $scroll_name $x $y $b $f
		if { $::hit_scrollbar($scroll_name) == 0 } {
	    	pdtk_canvas_sendclick $name $x $y $b $f
		}
	}
}

proc pdtk_canvas_middleclick {name x y b f} {
    focus $name
    pdtk_canvas_sendmiddleclick $name $x $y $b $f
}

proc pdtk_canvas_rightclick {name x y b} { 
    pdtk_canvas_sendclick $name $x $y $b 8
}

proc pdtk_canvas_shiftclick {name x y b} {
    pdtk_canvas_sendclick $name $x $y $b 1
}

proc pdtk_canvas_ctrlclick {name x y b} {
    pdtk_canvas_sendclick $name $x $y $b 2
}

proc pdtk_canvas_altclick {name x y b} {
    pdtk_canvas_sendclick $name $x $y $b 3
}

proc pdtk_canvas_dblclick {name x y b} {
    pdtk_canvas_sendclick $name $x $y $b 4
}

set pdtk_canvas_mouseup_name 0
set pdtk_canvas_mouseup_xminval 0
set pdtk_canvas_mouseup_xmaxval 0
set pdtk_canvas_mouseup_yminval 0
set pdtk_canvas_mouseup_ymaxval 0

proc pdtk_canvas_mouseup {name x y b} {
	pdtk_canvas_scroll_horizontal_click $name $x $y 0 0
	pdtk_canvas_scroll_vertical_click $name $x $y 0 0
	set scroll_name [string trimright $name .c]
	if { $::hit_scrollbar($scroll_name) == 0 } {
    	pd [concat [canvastosym $name] mouseup [$name canvasx $x] \
            [$name canvasy $y] $b \;]
    }
}

#proc pdtk_canvas_getscroll_ping {name} {
#	set wname [string trimright $name .c]
#	if {![winfo exists $wname]} {
#		set ::update_tick($wname) 0
#		return
#	}
#	if {$::update_tick($wname) == 2} {
#		set ::update_tick($wname) 3	
#		pdtk_canvas_getscroll $name
#	}
#	after 100 [list pdtk_canvas_getscroll_ping $name]
#}

# we use this to ensure that all gop children are selected for
# optimized displace and other operations without having to redraw
# canvas on every operation
proc pdtk_select_all_gop_widgets {name gop state} {
	#puts stderr "pdtk_select_all_gop_widgets $name $gop $state"
	foreach item [$name.c find all] {
		#puts stderr "object tags [$name.c gettags $item]"
		foreach tag [$name.c gettags $item] {
			if { [string first $gop $tag] > -1 } {
				#puts stderr "...match $tag"
				if {$state} {
					$name.c addtag selected withtag $tag
				} else {
					$name.c dtag $tag selected
				}
			}
		}
	}
}

# we use this to restore widgets original position (front to back)
# typically we call this when redrawing
proc pdtk_tag_all_widgets_with_arrange {canvas object state} {
	#puts stderr "pdtk_select_all_gop_widgets $canvas $object $state"
	foreach item [$canvas find all] {
		puts stderr [$canvas gettags $item]
		foreach tag [$canvas gettags $item] {
			if { [string first $object $tag] > -1 } {
				#puts stderr "...tag all match $tag"
				if {$state} {
					$canvas addtag arrange withtag $tag
				} else {
					$canvas dtag $tag arrange
				}
			}
		}
	}
}

proc pdtk_find_lowest_widget_withtag_and_arrange {canvas name target objtag} {
	# puts stderr "...pdtk_find_lowest_widget_withtag $canvas $name $target $objtag"
	set arrange_lowest 0
	foreach item [$canvas find all] {
		# puts stderr "tags=[$canvas gettags $item]"
		foreach tag [$canvas gettags $item] {
			if { [string first $name $tag] > -1 } {
				# puts stderr "...match $tag"
				set arrange_lowest $tag
				break;
			}
		}
		if { $arrange_lowest != 0 } {
			break;
		}
	}
	#puts stderr "final_lowest=$tag"
	if { $arrange_lowest != 0 } {
		if { $objtag != 0 } {
			# puts stderr "one_object canvas=$canvas object=$objtag"
			$canvas addtag arrange withtag $objtag
		}
		$canvas raise arrange
		$canvas lower arrange $arrange_lowest

		if { $objtag != 0 } {
			$canvas dtag $objtag arrange
		} else {
			$canvas dtag all arrange
		}
	}
}

proc pdtk_find_highest_widget_withtag {canvas name} {
	#puts stderr "pdtk_find_highest_widget_withtag $canvas $name"
	set ::arrange_highest 0
	set interrupt 0
	foreach item [$canvas find all] {
		#puts stderr "tags=[$canvas gettags $item]"
		foreach tag [$canvas gettags $item] {
			if { [string first $name $tag] > -1 } {
				#puts stderr ...match
				set ::arrange_highest $tag
				break;
			} elseif { $::arrange_highest != 0 } {
				set interrupt 1
				break;
			}
		}
		if { $interrupt == 1 } {
			break;
		}
	}
	#puts stderr "final_highest=$tag"
}

#proc pdtk_canvas_force_getscroll {name} {
#	set ::update_tick([winfo parent $name]) 0
#	after idle [concat pdtk_canvas_getscroll $name]
#}

proc pdtk_canvas_getscroll {name} {
	if {![winfo exists $name]} {return}
	set parentname [winfo parent $name]
	if {$::scroll($parentname) == 0} {return}
	# if {$::editmode($parentname) == 0} {
	# 	if { $::doscroll($parentname) != 0 } {
	# 		return
	# 	}
	# }
	catch { after cancel $::doscroll($parentname) }
	set ::doscroll($parentname) [after idle [concat pdtk_canvas_do_getscroll $name]]
}

proc pdtk_canvas_do_getscroll {name} {
	global pd_nt
    global pdtk_canvas_mouseup_name
    global pdtk_canvas_mouseup_xminval
    global pdtk_canvas_mouseup_xmaxval
    global pdtk_canvas_mouseup_yminval
    global pdtk_canvas_mouseup_ymaxval
	#global ::update_tick([winfo parent $name])

    # kludge since this gets called sometimes after a canvas is destroyed
    if {![winfo exists $name]} {return}

    set parentname [winfo parent $name]

	set ::doscroll($parentname) 0

    #puts stderr "pdtk_canvas_getscroll $name $::scroll($parentname)"
	if {$::scroll($parentname) == 0} {return}

    # for use with tick mechanism
	#if {$::update_tick([winfo parent $name]) == 1} {return}
	#after 100 set ::update_tick([winfo parent $name]) 0

	#puts stderr getscroll

	#debug
	#catch { $name delete debug }
	#puts stderr "top-left x:[$name canvasx 0] y:[$name canvasy 0]"

	#ico@bukvic.net 5/18/10
	#bbox all is not accurate when using text
	#this is a known issue described on the URL below
	#this is particularly obvious when using large iemlib objects
	#so, we calculate canvas size manually
    #set size [$name bbox all]

	#borrowed from http://wiki.tcl.tk/4844
	set x1 1.0e30; set x2 -1.0e30 ;
	set y1 1.0e30; set y2 -1.0e30 ;

	foreach item [$name find withtag {(!noscroll)}] {
	    switch -exact [$name type $item] {
			"text" {
				set size [$name bbox $item]
				if { [$name itemcget $item -text] != ""} {
					foreach {xa ya xb yb} $size {
						if { $xa < $x1 } {set x1 $xa}
						if { $xb > $x2 } {set x2 $xb}
						if { $ya < $y1 } {set y1 $ya}
						if { $yb > $y2 } {set y2 $yb}
						#for debugging purposes							
						#$name create rectangle $x1 $y1 $x2 $y2 -outline #ff0000 -tag debug
					}
				}
			}
			"image" {
				catch {
					set imgtags [$name gettags $item]
					set imgtag [lindex $imgtags 0]
					if { $imgtag != "" } {
						set anchor [$name itemcget $imgtag -anchor]
						set img [$name itemcget $imgtag -image]
						set imgh [image height $img]
						set imgw [image width $img]
						set center [$name coords $item]
						#for debugging purposes
						#puts stderr "IMAGE: $anchor [lindex $center 0] [lindex $center 1]"
						if { $anchor == "nw" } {
							set coords [list \
								[expr [lindex $center 0]] \
								[expr [lindex $center 1]] \
								[expr [lindex $center 0] + [expr $imgw]] \
								[expr [lindex $center 1] + [expr $imgh]] \
							]
						} else {
							set coords [list \
								[expr [lindex $center 0] - [expr $imgw/2]] \
								[expr [lindex $center 1] - [expr $imgh/2]] \
								[expr [lindex $center 0] + [expr $imgw/2]] \
								[expr [lindex $center 1] + [expr $imgh/2]] \
							]
						}
						foreach {x y} $coords {
							if { $x < $x1 } {set x1 $x}
							if { $x > $x2 } {set x2 $x}
							if { $y < $y1 } {set y1 $y}
							if { $y > $y2 } {set y2 $y}
						}
					}
				}
			}
			default {
				if { $item != 0 } {
					set coords [$name bbox $item]
					#puts stderr "$name $item $coords"
					foreach {x y} $coords {
						if { $x < $x1 } {set x1 $x}
						if { $x > $x2 } {set x2 $x}
						if { $y < $y1 } {set y1 $y}
						if { $y > $y2 } {set y2 $y}
					}
				}
				#set imgtags [$name gettags $item]
				#set imgtag [lindex $imgtags 0]
				#puts stderr $imgtag
				#$name create rectangle $x1 $y1 $x2 $y2 -outline #ff0000 -tag debug
			}

	    }
	}

	#puts stderr "$x1 $x2 $y1 $y2"

	if {$x1 != 1.0e30} {

		set xminval 0
		set yminval 0
		set xmaxval 100
		set ymaxval 20

		#these IMO work much better than the ones below
		#they allow for intelligent translation of the canvas
		#rather than introducing redundant scrollbars
		set xminval $x1
		set yminval $y1

		#set xmaxval [expr $x1+($x2-$x1)]
		#set ymaxval [expr $y1+($y2-$y1)]
		set xmaxval $x2
		set ymaxval $y2

		#if {$x1 < $xminval} {set xminval $x1}
		#if {$y1 < $yminval} {set yminval $y1}

		#if {$x2 > $xmaxval} {set xmaxval $x2}
		#if {$y2 > $ymaxval} {set ymaxval $y2}

		set winwidth [winfo width $parentname.c]
		set winheight [winfo height $parentname.c]

		set canvaswidth [ expr {abs($xmaxval-$xminval)} ]
		set canvasheight [ expr {abs($ymaxval-$yminval)} ]

		set ::canvaswidth($parentname) $canvaswidth
		set ::canvasheight($parentname) $canvasheight

		#puts stderr "BEFORE W: $winwidth ? $canvaswidth -- H: $winheight ? $canvasheight -- SC: $::xscrollable($parentname) $::yscrollable($parentname)"

		if {$::scroll($parentname) == 1} {

			#if {($::xscrollable($parentname) && $::yscrollable($parentname)
			#		&& [expr $winwidth + 14] >= $canvaswidth
			#		&& [expr $winheight + 14] >= $canvasheight)} {
			#	#puts stderr "TRYING TO ADJUST WIDTH & HEIGHT"
			#	pack forget $parentname.scrollhort
			#	set ::xscrollable($parentname) 0
			#	pack forget $parentname.scrollvert
			#	set ::yscrollable($parentname) 0
			#	set winwidth [expr {$winwidth + 14}]
			#	set winheight [expr {$winheight + 14}]
			#}

			if {$winwidth >= $canvaswidth && $::xscrollable($parentname)} {
				#puts stderr "NO HORIZONTAL NECESSARY"
				#pack forget $parentname.scrollhort
				set ::xscrollable($parentname) 0
				#set winheight [expr {$winheight + 14}]
			}

			if {$winheight >= $canvasheight && $::yscrollable($parentname)} {
				#puts stderr "NO VERTICAL NECESSARY"
				#pack forget $parentname.scrollvert
				set ::yscrollable($parentname) 0
				#set winwidth [expr {$winwidth + 14}]
			}

			#puts stderr "AFTER W: $winwidth ? $canvaswidth -- H: $winheight ? $canvasheight -- SC: $::xscrollable($parentname) $::yscrollable($parentname)"

			if {$winwidth < $canvaswidth && $::xscrollable($parentname) == 0} {
				#puts stderr "PUTTING HORIZONTAL"
				#pack $parentname.scrollhort -fill x \
				#-side bottom -before $parentname.c
				set ::xscrollable($parentname) 1
			}
			if {$winheight < $canvasheight && $::yscrollable($parentname) == 0} {
				#puts stderr "PUTTING VERTICAL"
				#pack $parentname.scrollvert -fill y \
				#	-side right -before $parentname.c
				set ::yscrollable($parentname) 1
			}
		}

		#puts stderr "========================\n\n"
	
		if {$pdtk_canvas_mouseup_name != $name || \
				$pdtk_canvas_mouseup_xminval != $xminval || \
				$pdtk_canvas_mouseup_xmaxval != $xmaxval || \
				$pdtk_canvas_mouseup_yminval != $yminval || \
				$pdtk_canvas_mouseup_ymaxval != $ymaxval } {
		
			set newsize "$xminval $yminval $xmaxval $ymaxval"
			$name configure -scrollregion $newsize
			set pdtk_canvas_mouseup_name $name
			set pdtk_canvas_mouseup_xminval $xminval
			set pdtk_canvas_mouseup_xmaxval $xmaxval
			set pdtk_canvas_mouseup_yminval $yminval
			set pdtk_canvas_mouseup_ymaxval $ymaxval
		}
	} else {
		if {$::scroll($parentname) == 1} {
			#pack forget $parentname.scrollhort
			set ::xscrollable($parentname) 0
			#pack forget $parentname.scrollvert
			set ::yscrollable($parentname) 0
		}
	}
	#set ::update_tick([winfo parent $name]) 1
    pdtk_canvas_checkgeometry [canvastosym $name]
	pdtk_canvas_draw_scrollbars $name
	pdtk_canvas_update_sticky_tip $name
	#puts stderr "END top-left x:[$name canvasx 0] y:[$name canvasy 0]"
    #update (bad idea--all kinds of unpredictable problems)

}

set key_serial_press 0
set key_serial_release 0
set key_after 0
set autorepeat 0

proc pdtk_canvas_sendkey {name state key iso shift focus serial} {

	# for the sake of efficiency first take care of cancelling key_after on a key press
	global key_after
	global pd_nt
	global ctrl_l_down
	global ctrl_r_down
	global shift_l_down
	global shift_r_down
    global key_serial_press
    global key_serial_release
    global autorepeat

	if { $state == 1 } {
		after cancel $key_after
	}

    #puts stderr "START sendkey $state $key $iso $serial $autorepeat"
	#puts stderr "pdtk_canvas_sendkey $name $state $key <$iso> $shift $focus $serial | $key_serial_press $key_serial_release"

    if { $iso == "null" } { set iso "" }
    if {$iso != ""} {
    	if {$state != -1} {
        	scan $iso %c key
        } else {
        	set key $iso
        }
    }

	# NEW APPROACH
	if { $state == 1} {
		set key_serial_press $serial
		if { $key_serial_press != $key_serial_release } {
			set autorepeat 0
		} else {
			# we need to send one more keypress on before setting it to 1
			if { $autorepeat == 0 } {
				set autorepeat -1
			} else {
				set autorepeat 1
			}
		}
	} else {
		set key_serial_release $serial
		if { $state != -1 && $autorepeat != 0 } {
			after cancel $key_after
			if {$iso != ""} {
	        	scan $iso %c iso
	    	} else {
				set iso "null"
			}
			set key_after [after 50 [concat pdtk_canvas_sendkey $name -1 $key $iso $shift $focus $serial]]
		} else {
			set state 0
			set autorepeat 0
		}
	}

	#puts stderr "got key state=$state key=$key iso=<$iso> serial=$serial autorepeat=$autorepeat"
	#puts stderr "END"
	#return
	# END NEW APPROACH

    # autorepeat logic
	#set autorepeat 1
	#set autorepeat_keyoff 0
	#if { $state == 1 } {
	#	# press
	#	set key_serial_press $serial
	#    if { $key_serial_press != $key_serial_release } {
	#    	#puts stderr NEW_PRESS
	#        set autorepeat 0
	#    } else {
	#    	#puts stderr CANCELLING
	#    	set autorepeat_keyoff 1
	#    }
	#} elseif { $serial == -1 } {
	#	# dorelease
	#	#puts stderr DOING_SCHEDULED_RELEASE
	#    if { $key_serial_release != $key_serial_press } {
	#        set autorepeat 0
	#    }
	#} else {
	#	# schedule release
	#	#puts stderr SCHEDULING_RELEASE
	#	set key_serial_release $serial
	#	if { $key_serial_release != $key_serial_press } {
	#		if {$iso != ""} {
	#        	scan $iso %c iso
	#    	} else {
	#			set iso "null"
	#		}
	#		set key_after [after 50 [concat pdtk_canvas_sendkey $name $state $key $iso $shift $focus -1]]
	#		return
	#	}
	#}

	#puts stderr "autorepeat=$autorepeat"

	if {$key == "BackSpace"} {
		set iso ""
		set key 8
	} elseif {$key == "Tab"} {
       set iso ""
		set key 9
	} elseif {$key == "Return"} {
        set iso ""
		set key 10
	} elseif {$key == "Escape"} {
        set iso ""
		set key 27
	} elseif {$key == "Space"} {
        set iso ""
		set key 32
	} elseif {$key == "Delete" || $key == "KP_Delete"} {
        set iso ""
		set key 127
    }

	if {$key == "Control_L"} {
		if {$state == 1} {
			set ctrl_l_down 1
		} else {
			set ctrl_l_down 0
		}
	}
	if {$key == "Control_R"} {
		if {$state == 1} {
			set ctrl_r_down 1
		} else {
			set ctrl_r_down 0
		}
	}
	if {$key == "Shift_L"} {
		if {$state == 1} {
			set shift_l_down 1
		} else {
			set shift_l_down 0
		}
	}
	if {$key == "Shift_R"} {
		if {$state == 1} {
			set shift_r_down 1
		} else {
			set shift_r_down 0
		}
	}

	if {$ctrl_l_down || $ctrl_r_down} {
		set ctrl 1
	} else {
		set ctrl 0
	}

	if {$shift_l_down || $shift_r_down} {
		set shift 1
	} else {
		set shift 0
	}

	#puts stderr "shift=$shift ctrl=$ctrl key=$key"

	switch -- $key {
		Left -
		Right -
		Up -
		Down -
		Home -
		End -
		Next -
		Prior {
			if {$ctrl == 1 && $shift == 0} {
				set key "Ctrl$key"
				set state 1
			}
			if {$ctrl == 0 && $shift == 1} {
				set key "Shift$key"
				#set state 1 (this results in a double press)
			}
			if {$ctrl == 1 && $shift == 1} {
				set key "CtrlShift$key"
				set state 1
			}
			#puts stderr "outcome=$key"
		}
	}

	#if { $autorepeat_keyoff == 1 } {
	#	#puts stderr "EXTRA key 0 $key $shift $focus $autorepeat"
	#	pd [canvastosym $name] key 0 $key $shift $focus $autorepeat\;	
	#}

	#puts stderr "FINAL key=$key"
	if { $autorepeat == - 1 } {
		#puts stderr "FINAL key $state $key $shift $focus $autorepeat"
		pd [canvastosym $name] key $state $key $shift $focus 0\;
		set autorepeat 1
	} else {
		#puts stderr "FINAL key $state $key $shift $focus $autorepeat"
		pd [canvastosym $name] key $state $key $shift $focus $autorepeat\;
	}
}

# only do actions if this is a canvas.
# if so, invoke edit menu option (which will work
# only if the actual option is currently enabled)
proc pdtk_canvas_edit_menu_actions {name action} {
	# pdtk_post "edit_menu_actions $name $action\n"
	global copytexttocanvas

	if {[string match .x* $name]} {
		$name.m.edit invoke "$action"
	} else {
		set tmp ""
		catch {
			set tmp [clipboard get]
		}
		if { $tmp != "" } {
			set copytexttocanvas 1
			pdtk_canvas_update_paste_menu 1
		}
	}
}

proc pdtk_canvas_ctrlkey {name key shift} {
    global pd_nt k12_mode
	set ignore 0
    # first get rid of ".c" suffix; we'll refer to the toplevel instead
    set topname [string trimright $name .c]
    # puts stderr [concat ctrl-key $key $topname $name]
	# puts stderr [string match .controls* $name] 
	#.printout.frame.text .controls.* .
	# pdtk_post canvas_ctrlkey

	# puts stderr "$name $key $shift"

	if {[string match *.c $name] || [info exists $name.c]} {
		set ignore 0
	} else {
		set ignore 1
	}

	#puts stderr "$name $ignore"

	#if {$name == "." || [string match .printout* $name] || [string match .controls* $name] || [string match .gfxstub* $name]  || [string match .help_browser* $name]} {
	#	set ignore 1	
	#}

	if {!$ignore && $k12_mode == 0} {
		if {$key == "1"} {menu_object $topname 1}
		if {$key == "2"} {menu_message $topname 1}
		if {$key == "3"} {menu_floatatom $topname 1}
		if {$key == "4"} {menu_symbolatom $topname 1}
		if {$key == "5"} {menu_comment $topname 1}
    	if {$key == "Return"} {menu_reselect $topname}
	}
    if {$key == "slash"} {menu_audio 1}
    if {$key == "period"} {menu_audio 0}
    if {$shift == 1} {
        if {$key == "q" || $key == "Q"} {menu_really_quit}
	    if {$key == "l" || $key == "L"} {menu_clear_console}
	    if {$key == "r" || $key == "R"} {menu_toggle_console}
		if { $k12_mode == 0 } {
			if {$key == "E"} {menu_tooltips $topname}
			if {$key == "Return"} {pdtk_zoom_reset $topname}
		}
		if {!$ignore} {
	        if {$key == "w" || $key == "W"} {menu_really_close $topname}
	        if {$key == "s" || $key == "S"} {menu_saveas $topname}
			if { $k12_mode == 0 } {
				if {$key == "b" || $key == "B"} {menu_bng $topname 1}
				if {$key == "n" || $key == "N"} {menu_numbox $topname 1}
				if {$key == "v" || $key == "V"} {menu_vslider $topname 1}
				if {$key == "h" || $key == "H"} {menu_hslider $topname 1}
				if {$key == "i" || $key == "I"} {menu_hradio $topname 1}
				if {$key == "d" || $key == "D"} {menu_vradio $topname 1}
				if {$key == "u" || $key == "U"} {menu_vumeter $topname 1}
				if {$key == "c" || $key == "C"} {menu_mycnv $topname 1}
				if {$key == "t" || $key == "T"} {menu_toggle $topname 1}
			}
		    #if {$key == "z" || $key == "Z"} {menu_redo $topname}
		    if {$key == "z" || $key == "Z"} {pdtk_canvas_edit_menu_actions $topname Redo*}
		}
    } else {
		if { $k12_mode == 0 } {
			#if {$key == "y" || $key == "Y"} {menu_tidyup $name}
			#if {$key == "Up"} {popup_action $name 3}
			if {$key == "Up"} {pdtk_canvas_edit_menu_actions $topname "Bring To Front"}
			#if {$key == "Down"} {popup_action $name 4}
			if {$key == "Down"} {pdtk_canvas_edit_menu_actions $topname "Send To Back"}
        	if {$key == "p" || $key == "P"} {menu_print $topname}
		}
		if {$key == "b" || $key == "B"} {dialog_search::open_helpbrowser .search}
		if {$key == "y" || $key == "Y"} {pdtk_canvas_edit_menu_actions $topname "Tidy Up"}
        if {$key == "q" || $key == "Q"} {menu_quit}
        #if {$key == "z" || $key == "Z"} {menu_undo $topname}
        if {$key == "z" || $key == "Z"} {pdtk_canvas_edit_menu_actions $topname Undo*}
        if {$key == "n" || $key == "N"} {menu_new}
        if {$key == "o" || $key == "O"} {menu_open}
        if {$key == "semicolon"} {menu_raise_console}
        #if {$key == "x" || $key == "X"} {menu_cut $topname}
		if {$key == "x" || $key == "X"} {pdtk_canvas_edit_menu_actions $topname Cut}
        #if {$key == "c" || $key == "C"} {menu_copy $topname}
		if {$key == "c" || $key == "C"} {pdtk_canvas_edit_menu_actions $topname Copy}
        #if {$key == "v" || $key == "V"} {menu_paste $topname}
        if {$key == "v" || $key == "V"} {pdtk_canvas_edit_menu_actions $topname Paste}
		if {$key == "a" || $key == "A"} {menu_selectall $topname}
		if {!$ignore} {
        	if {$key == "w" || $key == "W"} {menu_close $topname}
	        if {$key == "s" || $key == "S"} {menu_save $topname}
        	if {$key == "e"} {menu_editmode $topname}
        	#if {$key == "d" || $key == "D"} {menu_duplicate $topname}
        	if {$key == "d" || $key == "D"} {pdtk_canvas_edit_menu_actions $topname Duplicate}
			if {$key == "r" || $key == "R"} {menu_magicglass $topname}
		}
        if {$pd_nt == 2} { 
			# by default, Cmd-T opens the font panel on Mac OS X
            if {$key == "t" || $key == "T"} {menu_font $topname}
			if {$key == "m" || $key == "M"} {menu_minimize $topname}
        } else {
            # if {$key == "t" || $key == "T"} {menu_texteditor $topname}
			# minimize window on Mac OS X
			if {$key == "m" || $key == "M"} {menu_send}
        }
		if {!$ignore} {		
        	if {$key == "f" || $key == "F"} {menu_findobject $topname}
        	if {$key == "g" || $key == "G"} {menu_findagain $topname}
		}
    }
    if {[info exists ::editmode($topname)]} {
    	pdtk_canvas_editval $topname 1
    }
    #pdtk_post "CTRL: $key\n"
}

proc pdtk_canvas_scroll {canvas xy distance} {
	if {$xy eq "x" && $::xscrollable([winfo parent $canvas]) == 1 || $xy eq "y" && $::yscrollable([winfo parent $canvas]) == 1 } {
		pdtk_canvas_leaveitem $canvas
    	$canvas [list $xy]view scroll $distance units
		pdtk_canvas_draw_scrollbars $canvas
	}
}

proc pdtk_check_scroll_on_motion_ping {name} {
	set wname [string trimright $name .c]
	if {![winfo exists $wname]} {
		set ::drag_tick($wname) 0
		return
	}
	if {$::drag_tick($wname) == 2} {
		set ::drag_tick($wname) 3	
		pdtk_check_scroll_on_motion $name 0
	}
	after 50 [list pdtk_check_scroll_on_motion_ping $name]
}

proc pdtk_check_scroll_on_motion {w threshold} {
    # kludge since this gets called sometimes after a canvas is destroyed
    if {![winfo exists $w]} {return}

	# waiting for refresh
	if {$::drag_tick([winfo parent $w]) == 2} {return}

	# init
	if {$::drag_tick([winfo parent $w]) == 0} {
	 	set ::drag_tick([winfo parent $w]) 1
		pdtk_check_scroll_on_motion_ping $w	
	}

	# update
	if {$::drag_tick([winfo parent $w]) == 1} {
		set ::drag_tick([winfo parent $w]) 2
		return
	}

	set x1 [$w canvasx 0]
	set x2 [expr [$w canvasx 0] + [winfo width $w]]
	set y1 [$w canvasy 0]
	set y2 [expr [$w canvasy 0] + [winfo height $w]]
    set xpointer [expr [$w canvasx 0] + [winfo pointerx $w]-[winfo rootx $w]]
    set ypointer [expr [$w canvasy 0] + [winfo pointery $w]-[winfo rooty $w]]

	#puts stderr "pdtk_boo x1=$x1 x2=$x2 y1=$y1 y2=$y2 xp=$xpointer yp=$ypointer"

	if { $::xscrollable([winfo parent $w]) == 1 } {
		if { $xpointer > [expr $x2 + $threshold] } {
			pdtk_canvas_scroll $w x 1
		}
		if { $xpointer < [expr $x1 - $threshold] } {
			pdtk_canvas_scroll $w x -1
		}
	}
	if { $::yscrollable([winfo parent $w]) == 1 } {
		if { $ypointer > [expr $y2 + $threshold] } {
			pdtk_canvas_scroll $w y 1
		}
		if { $ypointer < [expr $y1 - $threshold] } {
			pdtk_canvas_scroll $w y -1
		}
	}

	set ::drag_tick([winfo parent $w]) 1
}

proc pdtk_canvas_motion {name x y mods} {
	#puts stderr "motion [$name canvasx $x] [$name canvasy $y]"
	global pointer_x_local pointer_y_local pointer_x_global pointer_y_global tooltip_visible
	set pointer_x_local $x
	set pointer_y_local $y
	set pointer_x_global [expr $pointer_x_local + [winfo rootx $name]]
	set pointer_y_global [expr $pointer_y_local + [winfo rooty $name]]
	#puts stderr "motion $pointer_x_global $pointer_y_global"

	set scroll_name [string trimright $name .c]
	if { $::hit_scrollbar($scroll_name) != 0 } { set mods -1 }
 	#puts stderr [concat $pointer_x_local $pointer_y_local $pointer_x_global $pointer_y_global]
    #puts stderr [concat [canvastosym $name] $name $x $y]
    pdtk_canvas_scroll_horizontal_motion $name $x $y 0
	pdtk_canvas_scroll_vertical_motion $name $x $y 0
    pd [canvastosym $name] motion [$name canvasx $x] [$name canvasy $y] $mods \;
}

# "map" event tells us when the canvas becomes visible (arg is "0") or
# invisible (arg is "").  Invisibility means the Window Manager has minimized
# us.  We don't get a final "unmap" event when we destroy the window.
proc pdtk_canvas_map {name} {
    #puts stderr [concat map $name]
    pd [canvastosym $name] map 1 \;
}

proc pdtk_canvas_unmap {name} {
    #puts stderr [concat unmap $name]
    pd [canvastosym $name] map 0 \;
}

proc pdtk_canvas_makeobjs {name files x y} {
	puts stderr pdtk_canvas_makeobjs
    set c 0
    for {set n 0} {$n < [llength $files]} {incr n} {
    	puts stderr "file $n"
        if {[regexp {.*/(.+).pd$} [lindex $files $n] file obj] == 1} {
        	puts stderr "name obj"
            pd $name obj $x [expr $y + ($c * 30)] [pdtk_enquote $obj] \;
            incr c
        }
    } 
}

set saveas_dir nowhere

############ pdtk_canvas_saveas -- run a saveas dialog ##############

proc pdtk_canvas_saveas {name initfile initdir} {
    global pd_nt filetypes untitled_directory
    if { ! [file isdirectory $initdir]} {set initdir $::env(HOME)}
    set filename [tk_getSaveFile -initialfile $initfile -initialdir $initdir \
					  -defaultextension .pd -filetypes $filetypes \
					  -parent $name]
	reset_ctrl_on_popup_window
    if {$filename eq ""} return; # they clicked cancel

    set extension [file extension $filename]
    set oldfilename $filename
    set filename [regsub -- "$extension$" $filename [string tolower $extension]]
    if { ! [regexp -- "\.(pd|pat|mxt)$" $filename]} {
        # we need the file extention even on Mac OS X
        set filename $filename.pd
    }
    # test again after downcasing and maybe adding a ".pd" on the end
    if {$filename ne $oldfilename && [file exists $filename]} {
        set answer [tk_messageBox -type okcancel -icon question -default cancel\
                        -message [_ "\"$filename\" already exists. Do you want to replace it?"]]
        if {$answer eq "cancel"} return; # they clicked cancel
    }

    set directory [file dirname $filename]
    set basename [file tail $filename]
    pd [concat $name savetofile [pdtk_enquote $basename] \
            [pdtk_enquote $directory] \;]
    #       pd [concat $name savetofile $basename $directory \;]
    set untitled_directory $directory
    # add to recentfiles
    ::pd_guiprefs::update_recentfiles "$filename" 1
}

# zooming (a subset of dofont)

#set zoom_fontsize 10

#proc pdtk_zoom_reset {name} {
#	global font_array
#	global zoom_fontsize
#
#	if { $zoom_fontsize == 10 } { return }
#	
#	if { $zoom_fontsize < 10 } {
#		pdtk_zoom $name 1
#	} else {
#		while { $zoom_fontsize != 10 } {
#			pdtk_zoom $name -1
#		}
#	}
#}

#proc pdtk_zoom {name direction} {
#	global font_array
#	global zoom_fontsize
#	global dofont_fontsize
#	global pd_fontlist
#	set index [lsearch $font_array $zoom_fontsize]
#	if { $index == 5 && $direction == 1 || $index == 0 && $direction == -1 } {
#		return
#	} else {
#		set scale [expr {double([lindex $font_array [expr $index + $direction]])/($zoom_fontsize)}]
#		set zoom_fontsize [lindex $font_array [expr $index + $direction]]
#
#		switch -- $zoom_fontsize {
#		    8  { set typeface [lindex $pd_fontlist 0] }
#		    9  { set typeface [lindex $pd_fontlist 1] }
#		    10 { set typeface [lindex $pd_fontlist 2] }
#		    12 { set typeface [lindex $pd_fontlist 3] }
#		    14 { set typeface [lindex $pd_fontlist 4] }
#		    16 { set typeface [lindex $pd_fontlist 5] }
#		    18 { set typeface [lindex $pd_fontlist 6] }
#		    24 { set typeface [lindex $pd_fontlist 7] }
#		    30 { set typeface [lindex $pd_fontlist 8] }
#		    36 { set typeface [lindex $pd_fontlist 9] }
#		}
#
#		foreach item [$name.c find all] {
#			if {[$name.c type $item] == "text"} {
#				$name.c itemconfigure $item -font $typeface
#			}
#		}
#		$name.c scale all 0 0 $scale $scale
#	}
#	pdtk_canvas_getscroll $name.c
#    set cmd [concat $name font 0 [expr {double ($zoom_fontsize)/($dofont_fontsize)}] 0 2 \;]
#    pd $cmd
#}
# end zooming

############ pdtk_canvas_dofont -- run a font and resize dialog #########

set oldfontsize 10
set previewfontsize 10
set font_array { 8 10 12 16 24 36 }
set font_properties 0
set font_canvas 0

# zooming (a subset of dofont)
proc pdtk_zoom {name direction} {

	global font_array oldfontsize previewfontsize font_properties font_canvas

	set index [lsearch $font_array $::font($name)]
	if { $index == 5 && $direction == 1 || $index == 0 && $direction == -1 } {
		return
	} else {
		set previewfontsize $::font($name)
		set ::font($name) [lindex $font_array [expr $index + $direction]]
		if { $font_properties != 0 && $font_canvas == $name } {
			[format "$font_properties.radiof.radio%d" $::font($name)] invoke
		} else {
			dofont_apply $name $::font($name) 0
		}
	}
}

proc dofont_apply {name myfontsize noundo} {
	global oldfontsize
    set cmd [concat $name font $myfontsize $oldfontsize 100 $noundo \;]
    pd $cmd
	set oldfontsize $myfontsize
	set ::font($name) $myfontsize
}

proc dofont_preview {name myfontsize} {
	global previewfontsize
    set cmd [concat $name font $myfontsize 0 100 1 \;]
    pd $cmd
	set previewfontsize $myfontsize
}

proc dofont_close {name} {
	global font_properties font_canvas
    set cmd [concat $name cancel \;]
    pd $cmd
	set font_properties 0
	set font_canvas 0
}

proc dofont_cancel {name} {
    global oldfontsize
    dofont_preview $name $oldfontsize
    set cmd [concat $name cancel \;]
    pd $cmd
	set font_properties 0
	set font_canvas 0
}

proc dofont_ok {name} {
    global previewfontsize font_canvas
    dofont_apply $font_canvas $previewfontsize 0
    dofont_close $name
}

proc pdtk_canvas_dofont {name canvas initsize} {
    global oldfontsize previewfontsize pd_nt font_properties font_canvas
    set oldfontsize $initsize
    set previewfontsize $initsize

	if {[winfo exists $font_properties]} {
		destroy $font_properties
	}

	set font_properties $name
	set font_canvas $canvas
    
    toplevel $name -class [winfo class .]
	match_linux_wm [list $name configure]
	wm resizable $name 0 0
    wm title $name  {Font Settings}
    wm protocol $name WM_DELETE_WINDOW [concat dofont_cancel $name]

    pdtk_panelkeybindings $name dofont
    
    match_linux_wm [list frame $name.buttonframe]
    pack $name.buttonframe -side bottom -fill x -pady 3
	match_linux_wm [list button $name.buttonframe.cancel -text {Cancel}\
	    -command "dofont_cancel $name"]
	match_linux_wm [list button $name.buttonframe.ok -text {OK}\
	    -command "dofont_ok $name"]
    pack $name.buttonframe.cancel -side left -expand 1 -padx 3
    pack $name.buttonframe.ok -side left -expand 1 -padx 3
    
    match_linux_wm [list frame $name.radiof]
    pack $name.radiof -side left
    
    match_linux_wm [list label $name.radiof.label -text {Font Size:}]
    pack $name.radiof.label -side top

    match_linux_wm [list radiobutton $name.radiof.radio8 -value 8 \
		-variable dofont_fontsize -text "8" \
        -command [concat dofont_preview $name 8]]
    match_linux_wm [list radiobutton $name.radiof.radio10 -value 10 \
		-variable dofont_fontsize -text "10" \
        -command [concat dofont_preview $name 10]]
    match_linux_wm [list radiobutton $name.radiof.radio12 -value 12 \
		-variable dofont_fontsize -text "12" \
        -command [concat dofont_preview $name 12]]
    match_linux_wm [list radiobutton $name.radiof.radio16 -value 16 \
		-variable dofont_fontsize -text "16" \
        -command [concat dofont_preview $name 16]]
    match_linux_wm [list radiobutton $name.radiof.radio24 -value 24 \
		-variable dofont_fontsize -text "24" \
        -command [concat dofont_preview $name 24]]
    match_linux_wm [list radiobutton $name.radiof.radio36 -value 36 \
		-variable dofont_fontsize -text "36" \
        -command [concat dofont_preview $name 36]]
    pack $name.radiof.radio8 -side top -anchor w
    pack $name.radiof.radio10 -side top -anchor w
    pack $name.radiof.radio12 -side top -anchor w
    pack $name.radiof.radio16 -side top -anchor w
    pack $name.radiof.radio24 -side top -anchor w
    pack $name.radiof.radio36 -side top -anchor w

    set current_radiobutton [format "$name.radiof.radio%d" $initsize]
	if {[info tclversion] >= 8.5 && $pd_nt == 0} {
	    $current_radiobutton invoke
	} else {
	    $current_radiobutton select
	}
}

############ pdtk_gatom_dialog -- run a gatom dialog #########

proc gatom_escape {sym} {
    if {[string length $sym] == 0} {
        set ret "-"
        #       puts stderr [concat escape1 $sym $ret]
    } else {
        if {[string equal -length 1 $sym "-"]} {
            set ret [string replace $sym 0 0 "--"]
            #       puts stderr [concat escape $sym $ret]
        } else {
        	# "#" was 
            set ret [string map {"$" "#"} $sym]
            #		puts stderr [concat unescape $sym $ret]
        }
    }
    pdtk_unspace $ret
}

proc gatom_unescape {sym} {
    if {[string equal -length 1 $sym "-"]} {
        set ret [string replace $sym 0 0 ""]
        #       puts stderr [concat gatom_unescape 1 $sym $ret]
    } else {
    	# "#" was 
    	set ret $sym
    	set location [string first # $sym 0]
    	#puts stderr "location=$location"
    	while {$location != -1} {
    		set next [string index $sym [expr $location + 1]]
    		#puts stderr "next=$next"
    		if {$next != "" && [string is integer $next]} {
    			set ret [string replace $ret $location $location $]
    		}
    		set location [string first # $sym [expr $location + 1]]
    		#puts stderr "location=$location"
    	}
    	# old limited way now replaced with the one above
        #set ret [string map {"#" "$"} $sym]
        #        puts stderr [concat gatom_unescape 2 $sym $ret]
    }
    concat $ret
}

proc dogatom_apply {id} {
    set vid [string trimleft $id .]

    set cmd [concat $id param \
        $::dialog($vid:width) $::dialog($vid:lo) $::dialog($vid:hi) \
        [gatom_escape $::dialog($vid:label)] $::dialog($vid:wherelabel) \
        [gatom_escape $::dialog($vid:symfrom)] \
        [gatom_escape $::dialog($vid:symto)] \;]

    #    puts stderr $cmd
    pd $cmd
}

proc dogatom_cancel {name} {
    set cmd [concat $name cancel \;]
    #    puts stderr $cmd
    pd $cmd
}

proc dogatom_ok {name} {
    dogatom_apply $name
    dogatom_cancel $name
}

proc pdtk_gatom_dialog {id initwidth initlo inithi \
                            wherelabel label symfrom symto} {
    set vid [string trimleft $id .]
    set ::dialog($vid:width) $initwidth
    set ::dialog($vid:lo) $initlo
    set ::dialog($vid:hi) $inithi
    set ::dialog($vid:wherelabel) $wherelabel
    #puts stderr "pdtk_gatom_dialog $label"
    set ::dialog($vid:label) [gatom_unescape $label]
    set ::dialog($vid:symfrom) [gatom_unescape $symfrom]
    set ::dialog($vid:symto) [gatom_unescape $symto]

    toplevel $id -class [winfo class .]
    wm title $id "Atom Box Properties"
	match_linux_wm [list $id configure] 
    wm resizable $id 0 0
	global tmp_xpix tmp_ypix
	wm geometry $id "+$tmp_xpix+$tmp_ypix"
    wm protocol $id WM_DELETE_WINDOW [concat dogatom_cancel $id]

    pdtk_panelkeybindings $id "dogatom"

    match_linux_wm [list frame $id.params -pady 3]
    pack $id.params -side top
    match_linux_wm [list label $id.params.entryname -text "width"]
    match_linux_wm [list entry $id.params.entry \
		-textvariable ::dialog($vid:width) -width 4]
    pack $id.params.entryname $id.params.entry -side left -pady 3

    match_linux_wm [list labelframe $id.limits -text "limits" \
		-padx 3 -pady 3 -borderwidth 1 \
        -font highlight_font]
    pack $id.limits -side top -fill x -padx 3
    match_linux_wm [list frame $id.limits.lower]
    pack $id.limits.lower -side left
    match_linux_wm [list label $id.limits.lower.entryname -text "lower"]
    match_linux_wm [list entry $id.limits.lower.entry \
		-textvariable ::dialog($vid:lo) -width 8]
    pack $id.limits.lower.entryname $id.limits.lower.entry -side left -padx 3 -pady 3
    match_linux_wm [list frame $id.limits.upper]
    pack $id.limits.upper -side left
    match_linux_wm [list frame $id.limits.upper.spacer -width 20]
    match_linux_wm [list label $id.limits.upper.entryname -text "upper"]
    match_linux_wm [list entry $id.limits.upper.entry \
		-textvariable ::dialog($vid:hi) -width 8]
    pack  $id.limits.upper.spacer $id.limits.upper.entryname \
        $id.limits.upper.entry -side left -padx 3 -pady 3

    match_linux_wm [list frame $id.spacer1 -height 7]
    pack $id.spacer1 -side top

    match_linux_wm [list labelframe $id.label -text "label" \
		-padx 5 -pady 4 -borderwidth 1 \
        -font highlight_font]
    pack $id.label -side top -fill x -padx 3
    match_linux_wm [list frame $id.label.name]
    pack $id.label.name -side top
    match_linux_wm [list entry $id.label.name.entry \
		-textvariable ::dialog($vid:label) -width 35]
    pack $id.label.name.entry -side left
    match_linux_wm [list frame $id.label.radio]
    pack $id.label.radio -side top
    match_linux_wm [list radiobutton $id.label.radio.left -value 0 \
        -variable ::dialog($vid:wherelabel) \
        -text "left   "]
    match_linux_wm [list radiobutton $id.label.radio.right -value 1 \
        -variable ::dialog($vid:wherelabel) \
        -text "right"]
    match_linux_wm [list radiobutton $id.label.radio.top -value 2 \
        -variable ::dialog($vid:wherelabel) \
        -text "top"]
    match_linux_wm [list radiobutton $id.label.radio.bottom -value 3 \
        -variable ::dialog($vid:wherelabel) \
        -text "bottom"]
    pack $id.label.radio.left -side left -anchor w
    pack $id.label.radio.right -side right -anchor w
    pack $id.label.radio.top -side top -anchor w
    pack $id.label.radio.bottom -side bottom -anchor w

    match_linux_wm [list frame $id.spacer2 -height 7]
    pack $id.spacer2 -side top

    match_linux_wm [list labelframe $id.s_r \
		-text "messages" -padx 5 -pady 4 -borderwidth 1 \
        -font highlight_font]
    pack $id.s_r -side top -fill x -padx 3
    match_linux_wm [list frame $id.s_r.paramsymto]
    pack $id.s_r.paramsymto -side top -anchor e
    match_linux_wm [list label $id.s_r.paramsymto.entryname -text "send symbol"]
    match_linux_wm [list entry $id.s_r.paramsymto.entry \
		-textvariable ::dialog($vid:symto) -width 21]
    pack $id.s_r.paramsymto.entry $id.s_r.paramsymto.entryname -side right -pady 3

    match_linux_wm [list frame $id.s_r.paramsymfrom]
    pack $id.s_r.paramsymfrom -side top -anchor e
    match_linux_wm [list label $id.s_r.paramsymfrom.entryname -text "receive symbol"]
    match_linux_wm [list entry $id.s_r.paramsymfrom.entry \
		-textvariable ::dialog($vid:symfrom) -width 21]
    pack $id.s_r.paramsymfrom.entry $id.s_r.paramsymfrom.entryname -side right -pady 3
    
    match_linux_wm [list frame $id.buttonframe -pady 5]
    pack $id.buttonframe -side top -fill x -pady 3
	match_linux_wm [list button $id.buttonframe.cancel -text {Cancel} \
	    -command "dogatom_cancel $id"]
	match_linux_wm [list button $id.buttonframe.apply -text {Apply} \
	    -command "dogatom_apply $id"]
	match_linux_wm [list button $id.buttonframe.ok -text {OK} \
	    -command "dogatom_ok $id"]	
	pack $id.buttonframe.cancel -side left -expand 1 -padx 3
	pack $id.buttonframe.apply -side left -expand 1 -padx 3
    pack $id.buttonframe.ok -side left -expand 1 -padx 3

	if { [info tclversion] < 8.5 } {
		$id.params.entry select from 0
		$id.params.entry select adjust end
	}
    focus $id.params.entry
}

############ pdtk_canvas_popup -- popup menu for canvas #########

proc popup_action {name action} {
    global popup_xpix popup_ypix
    #puts stderr "popup_action $name"
    pdtk_canvas_leaveitem $name.c
	if {[string compare $name .c]} {
		set name [string trimright $name .c]
	}
	set cmd [concat $name done-popup $action $popup_xpix $popup_ypix\;]
	    #puts stderr $cmd
	pd $cmd
}

proc pdtk_canvas_popup {name xpix ypix canprop canopen isobject} {
	focus $name.c
    global popup_xpix popup_ypix k12_mode
	global tmp_xpix tmp_ypix
	set popup_xpix $xpix
	set popup_ypix $ypix
    set tmp_xpix [expr $xpix - [$name.c canvasx 0] + [winfo rootx $name.c]]
	scan $tmp_xpix %d tmp_xpix
    set tmp_ypix [expr $ypix - [$name.c canvasy 0] + [winfo rooty $name.c]]
	scan $tmp_ypix %d tmp_ypix
	#puts stderr $isobject
	if { $k12_mode == 0 } {
		if {$canprop == 0} {$name.popup entryconfigure 0 -state disabled}
		if {$canprop == 1} {$name.popup entryconfigure 0 -state active}
		if {$canopen == 0} {$name.popup entryconfigure 1 -state disabled}
		if {$canopen == 1} {$name.popup entryconfigure 1 -state active}
		if {$isobject == 0} {
			$name.popup entryconfigure 4 -state disabled
			$name.popup entryconfigure 5 -state disabled
		}
		if {$isobject == 1} {
			$name.popup entryconfigure 4 -state active
			$name.popup entryconfigure 5 -state active
		}
	}
	if { $k12_mode == 0 || $isobject == 1 } {
		tk_popup $name.popup $tmp_xpix \
		    $tmp_ypix 0
	}
}

# begin of change "iemlib"
############ pdtk_iemgui_dialog -- dialog window for iem guis #########

set iemgui_define_min_flashhold 50
set iemgui_define_min_flashbreak 10
set iemgui_define_min_fontsize 4

proc iemgui_clip_dim {id} {
    set vid [string trimleft $id .]
    if {$::dialog($vid:wdt) < $::dialog($vid:min_wdt)} {
        set ::dialog($vid:wdt) $::dialog($vid:min_wdt)
        $id.dim.w_ent configure -textvariable ::dialog($vid:wdt)
    }
    if {$::dialog($vid:hgt) < $::dialog($vid:min_hgt)} {
        set ::dialog($vid:hgt) $::dialog($vid:min_hgt)
        $id.dim.h_ent configure -textvariable ::dialog($vid:hgt)
    }
}

proc iemgui_clip_num {id} {
    set vid [string trimleft $id .]
    if {$::dialog($vid:num) > 2000} {
        set ::dialog($vid:num) 2000
        $id.para.num_ent configure -textvariable ::dialog($vid:num)
    }
    if {$::dialog($vid:num) < 1} {
        set ::dialog($vid:num) 1
        $id.para.num_ent configure -textvariable ::dialog($vid:num)
    }
}

proc iemgui_sched_rng {id} {
    set vid [string trimleft $id .]
    global iemgui_define_min_flashhold
    global iemgui_define_min_flashbreak
    
    if {$::dialog($vid:rng_sch) == 2} {
        if {$::dialog($vid:max_rng) < $::dialog($vid:min_rng)} {
            set hhh $::dialog($vid:min_rng)
            set ::dialog($vid:min_rng) $::dialog($vid:max_rng)
            set ::dialog($vid:max_rng) $hhh
            $id.rng.max_ent configure -textvariable ::dialog($vid:max_rng)
            $id.rng.min_ent configure -textvariable ::dialog($vid:min_rng) }
        if {$::dialog($vid:max_rng) < $iemgui_define_min_flashhold} {
            set ::dialog($vid:max_rng) $iemgui_define_min_flashhold
            $id.rng.max_ent configure -textvariable ::dialog($vid:max_rng)
        }
        if {$::dialog($vid:min_rng) < $iemgui_define_min_flashbreak} {
            set ::dialog($vid:min_rng) $iemgui_define_min_flashbreak
            $id.rng.min_ent configure -textvariable ::dialog($vid:min_rng)
        }
    }
    if {$::dialog($vid:rng_sch) == 1} {
        if {$::dialog($vid:min_rng) == 0.0} {
            set ::dialog($vid:min_rng) 1.0
            $id.rng.min_ent configure -textvariable ::dialog($vid:min_rng)
        }
    }
}

proc iemgui_verify_rng {id} {
    set vid [string trimleft $id .]
    if {$::dialog($vid:lin0_log1) == 1} {
        if {$::dialog($vid:max_rng) == 0.0 && $::dialog($vid:min_rng) == 0.0} {
            set ::dialog($vid:max_rng) 1.0
            $id.rng.max_ent configure -textvariable ::dialog($vid:max_rng)
        }
        if {$::dialog($vid:max_rng) > 0} {
            if {$::dialog($vid:min_rng) <= 0} {
                set ::dialog($vid:min_rng) [expr $::dialog($vid:max_rng) * 0.01]
                $id.rng.min_ent configure -textvariable ::dialog($vid:min_rng)
            }
        } else {
            if {$::dialog($vid:min_rng) > 0} {
                set ::dialog($vid:max_rng) [expr $::dialog($vid:min_rng) * 0.01]
                $id.rng.max_ent configure -textvariable ::dialog($vid:max_rng)
            }
        }
    }
}

proc iemgui_clip_fontsize {id} {
    set vid [string trimleft $id .]
    global iemgui_define_min_fontsize
    if {$::dialog($vid:gn_fs) < $iemgui_define_min_fontsize} {
        set ::dialog($vid:gn_fs) $iemgui_define_min_fontsize
        $id.label.fontsize_entry configure -textvariable ::dialog($vid:gn_fs)
    }
}

proc iemgui_set_col_example {id} {
    set vid [string trimleft $id .]

    $id.colors.sections.lb_bk configure \
        -background [format "#%6.6x" $::dialog($vid:bcol)] \
        -activebackground [format "#%6.6x" $::dialog($vid:bcol)] \
        -foreground [format "#%6.6x" $::dialog($vid:lcol)] \
        -activeforeground [format "#%6.6x" $::dialog($vid:lcol)]
    
    if { $::dialog($vid:fcol) >= 0 } {
        $id.colors.sections.fr_bk configure \
            -background [format "#%6.6x" $::dialog($vid:bcol)] \
            -activebackground [format "#%6.6x" $::dialog($vid:bcol)] \
            -foreground [format "#%6.6x" $::dialog($vid:fcol)] \
            -activeforeground [format "#%6.6x" $::dialog($vid:fcol)]
    } else {
        $id.colors.sections.fr_bk configure \
            -background [format "#%6.6x" $::dialog($vid:bcol)] \
            -activebackground [format "#%6.6x" $::dialog($vid:bcol)] \
            -foreground [format "#%6.6x" $::dialog($vid:bcol)] \
            -activeforeground [format "#%6.6x" $::dialog($vid:bcol)]}
}

proc iemgui_preset_col {id presetcol} {
    set vid [string trimleft $id .]
    if { $::dialog($vid:l2_f1_b0) == 0 } { set ::dialog($vid:bcol) $presetcol }
    if { $::dialog($vid:l2_f1_b0) == 1 } { set ::dialog($vid:fcol) $presetcol }
    if { $::dialog($vid:l2_f1_b0) == 2 } { set ::dialog($vid:lcol) $presetcol }
    catch { iemgui_set_col_example $id }
}

proc iemgui_choose_col_bkfrlb {id} {
	global hex_color color_applied pd_nt
    set vid [string trimleft $id .]
	if {[info tclversion] >= 8.5 && $pd_nt == 0} {
		if {$::dialog($vid:l2_f1_b0) == 0} {
		    set ::dialog($vid:bcol) [expr $::dialog($vid:bcol) & 0xFFFFFF]
			set loop [pdtk_pd_color_dlg [format "#%6.6x" \
				$::dialog($vid:bcol)]]
			vwait color_applied
			set color_applied -1
		    set ::dialog($vid:bcol) [string replace $hex_color 0 0 "0x"]
		    set ::dialog($vid:bcol) [expr $::dialog($vid:bcol) & 0xFFFFFF]
		}
	} else {
		if {$::dialog($vid:l2_f1_b0) == 0} {
			set ::dialog($vid:bcol) [expr $::dialog($vid:bcol) & 0xFCFCFC]
			set helpstring [tk_chooseColor -title "Custom Background Color" \
				-initialcolor [format "#%6.6x" $::dialog($vid:bcol)]]
			if { $helpstring != "" } {
			    set ::dialog($vid:bcol) [string replace $helpstring 0 0 "0x"]
			    set ::dialog($vid:bcol) [expr $::dialog($vid:bcol) & 0xFCFCFC] 
			}
		}
    }

	if {[info tclversion] >= 8.5 && $pd_nt == 0} {
		if {$::dialog($vid:l2_f1_b0) == 1} {
		    set ::dialog($vid:fcol) [expr $::dialog($vid:fcol) & 0xFFFFFF]
			set loop [pdtk_pd_color_dlg [format "#%6.6x" \
				$::dialog($vid:fcol)]]
			vwait color_applied
			set color_applied -1
		    set ::dialog($vid:fcol) [string replace $hex_color 0 0 "0x"]
		    set ::dialog($vid:fcol) [expr $::dialog($vid:fcol) & 0xFFFFFF]
		}
	} else {
		if {$::dialog($vid:l2_f1_b0) == 1} {
		    set ::dialog($vid:fcol) [expr $::dialog($vid:fcol) & 0xFCFCFC]
		    set helpstring [tk_chooseColor -title "Custom Foreground Color" \
				-initialcolor [format "#%6.6x" $::dialog($vid:fcol)]]
		    if { $helpstring != "" } {
		        set ::dialog($vid:fcol) [string replace $helpstring 0 0 "0x"]
		        set ::dialog($vid:fcol) [expr $::dialog($vid:fcol) & 0xFCFCFC]
			}
		}
	}

	if {[info tclversion] >= 8.5 && $pd_nt == 0} {
		if {$::dialog($vid:l2_f1_b0) == 2} {
		    set ::dialog($vid:lcol) [expr $::dialog($vid:lcol) & 0xFFFFFF]
			set loop [pdtk_pd_color_dlg [format "#%6.6x" \
				$::dialog($vid:lcol)]]
			vwait color_applied
			set color_applied -1
		    set ::dialog($vid:lcol) [string replace $hex_color 0 0 "0x"]
		    set ::dialog($vid:lcol) [expr $::dialog($vid:lcol) & 0xFFFFFF]
		}
	} else {
		if {$::dialog($vid:l2_f1_b0) == 2} {
		    set ::dialog($vid:lcol) [expr $::dialog($vid:lcol) & 0xFCFCFC]
		    set helpstring [tk_chooseColor -title "Label-Color" \
				-initialcolor [format "#%6.6x" $::dialog($vid:lcol)]]
		    if { $helpstring != "" } {
		        set ::dialog($vid:lcol) [string replace $helpstring 0 0 "0x"]
		        set ::dialog($vid:lcol) [expr $::dialog($vid:lcol) & 0xFCFCFC]
			}
		}
	}

    catch { iemgui_set_col_example $id }
}

proc iemgui_lilo {id} {
    set vid [string trimleft $id .]
    iemgui_sched_rng $id
    if {$::dialog($vid:lin0_log1) == 0} {
        set ::dialog($vid:lin0_log1) 1
        $id.para.lilo configure -text $::dialog($vid:lilo1)
        iemgui_verify_rng $id
        iemgui_sched_rng $id
    } else {
        set ::dialog($vid:lin0_log1) 0
        $id.para.lilo configure -text $::dialog($vid:lilo0)
    }
}

proc iemgui_hide_frame {id} {
    set vid [string trimleft $id .]
    set ::dialog($vid:hide) [expr ($::dialog($vid:hide) + 1) % 4]
	$id.dim.h configure -text [lindex {normal frame arrow none} $::dialog($vid:hide)]
}

proc iemgui_toggle_font {id gn_f} {
    set vid [string trimleft $id .]
    global fontname fontweight
    set ::dialog($vid:gn_f) $gn_f

    switch -- $gn_f {
        0 { set current_font $fontname}
        1 { set current_font "Helvetica" }
        2 { set current_font "Times" }
    }
    set current_font_spec "{$current_font} 9 $fontweight"

    $id.label.fontpopup_label configure -text $current_font \
        -font $current_font_spec
    $id.label.name_entry configure -font $current_font_spec
    $id.colors.sections.fr_bk configure -font $current_font_spec
    $id.colors.sections.lb_bk configure -font $current_font_spec
}

proc iemgui_lb {id} {
    set vid [string trimleft $id .]
    if {$::dialog($vid:loadbang) == 0} {
        set ::dialog($vid:loadbang) 1
        $id.para.lb configure -text "init"
    } else {
        set ::dialog($vid:loadbang) 0
        $id.para.lb configure -text "no init"
    }
}

proc iemgui_stdy_jmp {id} {
    set vid [string trimleft $id .]
    if {$::dialog($vid:steady)} {
        set ::dialog($vid:steady) 0
        $id.para.stdy_jmp configure -text "jump on click"
    } else {
        set ::dialog($vid:steady) 1
        $id.para.stdy_jmp configure -text "steady on click"
    }
}

proc iemgui_apply {id} {
	global color_applied
	if {$color_applied > -1 && [winfo exists .color_dlg]} {
		destroy .color_dlg
		set color_applied -1
	}
	set vid [string trimleft $id .]

	iemgui_clip_dim $id
	iemgui_clip_num $id
	iemgui_sched_rng $id
	iemgui_verify_rng $id
	iemgui_sched_rng $id
	iemgui_clip_fontsize $id
	
	if {$::dialog($vid:snd) == ""} {set hhhsnd "empty"} else {set hhhsnd $::dialog($vid:snd)}
	if {$::dialog($vid:rcv) == ""} {set hhhrcv "empty"} else {set hhhrcv $::dialog($vid:rcv)}
	if {$::dialog($vid:gui_nam) == ""} {set hhhgui_nam "empty"
	} else {
	    set hhhgui_nam $::dialog($vid:gui_nam)}

	# "#" was 
	# Below is a fix this to look for anywhere inside the file
	#if {[string index $hhhsnd 0] == "$"} {
	set temp $hhhsnd
	set hhhsnd [iemgui_d2r $temp]		
	    #set hhhsnd [string replace $hhhsnd 0 0 #]
	#}
	#if {[string index $hhhrcv 0] == "$"} {
	set temp $hhhrcv
	set hhhrcv [iemgui_d2r $temp]
	    #set hhhrcv [string replace $hhhrcv 0 0 #]
	#}
	#if {[string index $hhhgui_nam 0] == "$"} {
	set temp $hhhgui_nam
	set hhhgui_nam [iemgui_d2r $temp]
	    #set hhhgui_nam [string replace $hhhgui_nam 0 0 #]
	#}
	
	set hhhsnd [pdtk_unspace $hhhsnd]
	set hhhrcv [pdtk_unspace $hhhrcv]
	set hhhgui_nam [pdtk_unspace $hhhgui_nam]

	# make sure the offset boxes have a value
    if {$::dialog($vid:gn_dx) eq ""} {set ::dialog($vid:gn_dx) 0}
    if {$::dialog($vid:gn_dy) eq ""} {set ::dialog($vid:gn_dy) 0}

	pd [concat $id dialog \
		$::dialog($vid:wdt) $::dialog($vid:hgt) \
		$::dialog($vid:min_rng) $::dialog($vid:max_rng) \
		$::dialog($vid:lin0_log1) $::dialog($vid:loadbang) \
		$::dialog($vid:num) \
		$hhhsnd $hhhrcv $hhhgui_nam \
		$::dialog($vid:gn_dx) $::dialog($vid:gn_dy) \
		$::dialog($vid:gn_f) $::dialog($vid:gn_fs) \
		$::dialog($vid:bcol) $::dialog($vid:fcol) \
		$::dialog($vid:lcol) \
		$::dialog($vid:steady) $::dialog($vid:hide) \;]
}

proc iemgui_cancel {id} {
	global color_applied
	if {$color_applied > -1 && [winfo exists .color_dlg]} {
		destroy .color_dlg
		set color_applied -1
	}	
	pd [concat $id cancel \;]
}

proc iemgui_ok {id} {
    iemgui_apply $id
    iemgui_cancel $id
}

proc iemgui_d2r {sym} {
	#puts stderr "iemgui_d2r"
	set ret $sym
	set location [string first $ $sym 0]
	#puts stderr "location=$location"
	while {$location != -1} {
		#set next [string index $sym [expr $location + 1]]
		#puts stderr "next=$next"
		#if {$next != "" && [string is integer $next]} {
			set ret [string replace $ret $location $location #]
		#}
		set location [string first $ $sym [expr $location + 1]]
		#puts stderr "location=$location"
	}
	#puts stderr "iemgui_d2r <$sym> <$ret>"
	concat $ret
}

proc iemgui_r2d {sym} {
	#puts stderr "iemgui_r2d"
	set ret $sym
	set location [string first # $sym 0]
	#puts stderr "location=$location"
	while {$location != -1} {
		set next [string index $sym [expr $location + 1]]
		#puts stderr "next=$next"
		if {$next != "" && [string is integer $next]} {
			set ret [string replace $ret $location $location $]
		}
		set location [string first # $sym [expr $location + 1]]
		#puts stderr "location=$location"
	}
	#puts stderr "iemgui_d2r <$sym> <$ret>"
	concat $ret
}

proc pdtk_iemgui_dialog {id mainheader \
  dim_header wdt min_wdt wdt_label hgt min_hgt hgt_label \
  rng_header min_rng min_rng_label max_rng max_rng_label rng_sched \
  lin0_log1 lilo0_label lilo1_label loadbang steady num_label num \
  snd rcv gui_name gn_dx gn_dy gn_f gn_fs bcol fcol lcol} {
    set vid [string trimleft $id .]
    global pd_nt
    global fontname fontweight

    set ::dialog($vid:wdt) $wdt
    set ::dialog($vid:min_wdt) $min_wdt
    set ::dialog($vid:hgt) $hgt
    set ::dialog($vid:min_hgt) $min_hgt
    set ::dialog($vid:min_rng) $min_rng
    set ::dialog($vid:max_rng) $max_rng
	if ([string compare "|nbx|" $mainheader]) {
		set ::dialog($vid:hide) 0
    	set ::dialog($vid:rng_sch) $rng_sched
	} else {
    	set ::dialog($vid:hide) $rng_sched
		set ::dialog($vid:rng_sch) 0
	}
    set ::dialog($vid:lin0_log1) $lin0_log1
    set ::dialog($vid:lilo0) $lilo0_label
    set ::dialog($vid:lilo1) $lilo1_label
    set ::dialog($vid:loadbang) $loadbang
    set ::dialog($vid:num) $num
    set ::dialog($vid:steady) $steady
    if {$snd == "empty" || $snd == "nosndno"} {set ::dialog($vid:snd) [format ""]
    } else {set ::dialog($vid:snd) [format "%s" $snd]}
    if {$rcv == "empty" || $snd == "norcvno"} {set ::dialog($vid:rcv) [format ""]
    } else {set ::dialog($vid:rcv) [format "%s" $rcv]}
    if {$gui_name == "empty"} {set ::dialog($vid:gui_nam) [format ""]
    } else {set ::dialog($vid:gui_nam) [format "%s" $gui_name]}

    # "#" was 
    set temp $::dialog($vid:snd)
	set ::dialog($vid:snd) [iemgui_r2d $temp]
    #if {[string index $::dialog($vid:snd) 0] == "#"} {
	#	set next [string index $::dialog($vid:snd) 1]
	#	if {$next != "" && [string is integer $next]} {
	#		set ::dialog($vid:snd) [string replace $::dialog($vid:snd) 0 0 $]
	#	}
        #set ::dialog($vid:snd) [string replace $::dialog($vid:snd) 0 0 $]
    #}

    set temp $::dialog($vid:rcv)
	set ::dialog($vid:rcv) [iemgui_r2d $temp]
    #if {[string index $::dialog($vid:rcv) 0] == "#"} {
	#	set next [string index $::dialog($vid:rcv) 1]
	#	if {$next != "" && [string is integer $next]} {
	#		set ::dialog($vid:rcv) [string replace $::dialog($vid:rcv) 0 0 $]
	#	}
        #set ::dialog($vid:rcv) [string replace $::dialog($vid:rcv) 0 0 $]
    #}

    set temp $::dialog($vid:gui_nam)
	set ::dialog($vid:gui_nam) [iemgui_r2d $temp]
    #if {[string index $::dialog($vid:gui_nam) 0] == "#"} {
	#	set next [string index $::dialog($vid:gui_nam) 1]
	#	if {$next != "" && [string is integer $next]} {
	#		set ::dialog($vid:gui_nam) [string replace $::dialog($vid:gui_nam) 0 0 $]
	#	}
        #set ::dialog($vid:gui_nam) [string replace $::dialog($vid:gui_nam) 0 0 $]
    #}
    set ::dialog($vid:gn_dx) $gn_dx
    set ::dialog($vid:gn_dy) $gn_dy
    set ::dialog($vid:gn_f) $gn_f
	set ::dialog($vid:gn_fs) $gn_fs 

    set ::dialog($vid:bcol) $bcol
    set ::dialog($vid:fcol) $fcol
    set ::dialog($vid:lcol) $lcol
    
    set ::dialog($vid:l2_f1_b0) 0

    toplevel $id -class [winfo class .]
    wm title $id [format "%s Properties" $mainheader]
	match_linux_wm [list $id configure]
    wm resizable $id 0 0
	global tmp_xpix tmp_ypix
	wm geometry $id "+$tmp_xpix+$tmp_ypix"
    wm protocol $id WM_DELETE_WINDOW [concat iemgui_cancel $id]
    
    pdtk_panelkeybindings $id "iemgui"

    match_linux_wm [list frame $id.dim]
    pack $id.dim -side top
    match_linux_wm [list label $id.dim.head -text $dim_header]
    match_linux_wm [list label $id.dim.w_lab -text $wdt_label -width 6]
    match_linux_wm [list entry $id.dim.w_ent -textvariable ::dialog($vid:wdt) -width 5]
    match_linux_wm [list label $id.dim.h_lab -text $hgt_label -width 6]
    match_linux_wm [list entry $id.dim.h_ent -textvariable ::dialog($vid:hgt) -width 5]
    pack $id.dim.head -side top
	if (![string compare "|nbx|" $mainheader]) {
		if {$::dialog($vid:hide) == 0} {
			match_linux_wm [list button $id.dim.h -text {normal} -width 7 -command "iemgui_hide_frame $id"]
		}
		if {$::dialog($vid:hide) == 1} {
			match_linux_wm [list button $id.dim.h -text {frame} -width 7 -command "iemgui_hide_frame $id"]
		}
		if {$::dialog($vid:hide) == 2} {
			match_linux_wm [list button $id.dim.h -text {arrow} -width 7 -command "iemgui_hide_frame $id"]
		}
		if {$::dialog($vid:hide) == 3} {
			match_linux_wm [list button $id.dim.h -text {none} -width 7 -command "iemgui_hide_frame $id"]
		}
		match_linux_wm [list label $id.dim.dummy1 -text " " -width 1]
		match_linux_wm [list label $id.dim.dummy2 -text " " -width 1]
		pack $id.dim.w_lab $id.dim.w_ent $id.dim.dummy1 $id.dim.h $id.dim.dummy2 -side left
	} else {
		match_linux_wm [list label $id.dim.dummy1 -text " " -width 10]
    	pack $id.dim.w_lab $id.dim.w_ent $id.dim.dummy1 -side left
	}
    if { $hgt_label != "empty" } {
        pack $id.dim.h_lab $id.dim.h_ent -side left}

    match_linux_wm [list frame $id.rng]
    pack $id.rng -side top
    match_linux_wm [list label $id.rng.head -text $rng_header]
    match_linux_wm [list label $id.rng.min_lab -text $min_rng_label -width 6]
    match_linux_wm [list entry $id.rng.min_ent \
		-textvariable ::dialog($vid:min_rng) -width 9]
    match_linux_wm [list label $id.rng.dummy1 -text " " -width 1]
    match_linux_wm [list label $id.rng.max_lab -text $max_rng_label -width 8]
    match_linux_wm [list entry $id.rng.max_ent \
		-textvariable ::dialog($vid:max_rng) -width 9]
    if { $rng_header != "empty" } {
        pack $id.rng.head -side top
        if { $min_rng_label != "empty" } {
            pack $id.rng.min_lab $id.rng.min_ent -side left}
        if { $max_rng_label != "empty" } {
            pack $id.rng.dummy1 \
                $id.rng.max_lab $id.rng.max_ent -side left} }
    
    if { $::dialog($vid:lin0_log1) >= 0 || $::dialog($vid:loadbang) >= 0 || $::dialog($vid:num) > 0 || $::dialog($vid:steady) >= 0 } {
        match_linux_wm [list label $id.space1 -text ""]
        pack $id.space1 -side top }

    match_linux_wm [list frame $id.para]
    pack $id.para -side top
    match_linux_wm [list label $id.para.dummy2 -text "" -width 1]
    match_linux_wm [list label $id.para.dummy3 -text "" -width 1]
    if {$::dialog($vid:lin0_log1) == 0} {
		match_linux_wm [list button $id.para.lilo -text \
			$::dialog($vid:lilo0) -width 7 -command "iemgui_lilo $id"]
	}
    if {$::dialog($vid:lin0_log1) == 1} {
		match_linux_wm [list button $id.para.lilo -text \
			$::dialog($vid:lilo1) -width 7 -command "iemgui_lilo $id"]
	}
    if {$::dialog($vid:loadbang) == 0} {
		match_linux_wm [list button $id.para.lb -text "no init" \
			-width 6 -command "iemgui_lb $id"]
	}
    if {$::dialog($vid:loadbang) == 1} {
		match_linux_wm [list button $id.para.lb -text "init" \
			-width 6 -command "iemgui_lb $id"]
	}
    match_linux_wm [list label $id.para.num_lab -text $num_label -width 9]
    match_linux_wm [list entry $id.para.num_ent \
		-textvariable ::dialog($vid:num) -width 4]
    if {$::dialog($vid:steady) == 0} {
        match_linux_wm [list button $id.para.stdy_jmp \
			-text "jump on click" -width 12 -command "iemgui_stdy_jmp $id"]
	}
    if {$::dialog($vid:steady) == 1} {
        match_linux_wm [list button $id.para.stdy_jmp \
			-text "steady on click" -width 12 -command "iemgui_stdy_jmp $id"]
	}
    if {$::dialog($vid:lin0_log1) >= 0} {
        pack $id.para.lilo -side left -expand 1}
    if {$::dialog($vid:loadbang) >= 0} {
        pack $id.para.dummy2 $id.para.lb -side left -expand 1}
    if {$::dialog($vid:num) > 0} {
        pack $id.para.dummy3 $id.para.num_lab $id.para.num_ent -side left -expand 1}
    if {$::dialog($vid:steady) >= 0} {
        pack $id.para.dummy3 $id.para.stdy_jmp -side left -expand 1}

    match_linux_wm [list frame $id.spacer0 -height 4]
    pack $id.spacer0 -side top
    
    match_linux_wm [list labelframe $id.s_r \
		-borderwidth 1 -pady 3 -padx 3 -text "messages" \
        -font highlight_font]
    pack $id.s_r -side top -fill x -padx 3 -ipadx 3 -ipady 3
    match_linux_wm [list frame $id.s_r.send]
    pack $id.s_r.send -side top
    match_linux_wm [list label $id.s_r.send.lab \
		-text "   send-symbol:" -width 12  -justify right]
    match_linux_wm [list entry $id.s_r.send.ent \
		-textvariable ::dialog($vid:snd) -width 22]
    if { $snd != "nosndno" } {
        pack $id.s_r.send.lab $id.s_r.send.ent -side left -pady 3
	}    
    match_linux_wm [list frame $id.s_r.receive]
    pack $id.s_r.receive -side top
    match_linux_wm [list label $id.s_r.receive.lab \
		-text "receive-symbol:" -width 12 -justify right]
    match_linux_wm [list entry $id.s_r.receive.ent \
		-textvariable ::dialog($vid:rcv) -width 22]
    if { $rcv != "norcvno" } {
        pack $id.s_r.receive.lab $id.s_r.receive.ent -side left
	}    
    # get the current font name from the int given from C-space (gn_f)
    set current_font $fontname
    if {$::dialog($vid:gn_f) == 1} \
        { set current_font "Helvetica" }
    if {$::dialog($vid:gn_f) == 2} \
        { set current_font "Times" }

    match_linux_wm [list frame $id.spacer1 -height 7]
    pack $id.spacer1 -side top
    
    match_linux_wm [list labelframe $id.label \
		-borderwidth 1 -text "label" -pady 3 -padx 3 \
        -font highlight_font]
    pack $id.label -side top -fill x -padx 3 -ipadx 3 -ipady 3
    match_linux_wm [list entry $id.label.name_entry \
		-textvariable ::dialog($vid:gui_nam) -width 30 \
        -font [list $current_font 9 $fontweight]]
    pack $id.label.name_entry -side top -expand yes -fill both -padx 5 -pady 3
    
    match_linux_wm [list frame $id.label.xy -padx 27 -pady 1]
    pack $id.label.xy -side top
    match_linux_wm [list label $id.label.xy.x_lab -text "x offset" -width 6]
    match_linux_wm [list entry $id.label.xy.x_entry \
		-textvariable ::dialog($vid:gn_dx) -width 5]
    match_linux_wm [list label $id.label.xy.dummy1 -text " " -width 2]
    match_linux_wm [list label $id.label.xy.y_lab -text "y offset" -width 6]
    match_linux_wm [list entry $id.label.xy.y_entry \
		-textvariable ::dialog($vid:gn_dy) -width 5]
    pack $id.label.xy.x_lab $id.label.xy.x_entry $id.label.xy.dummy1 \
        $id.label.xy.y_lab $id.label.xy.y_entry -side left -anchor e
    match_linux_wm [list label $id.label.fontpopup_label -text $current_font \
    	-relief groove -font [list $current_font 9 $fontweight]]
    pack $id.label.fontpopup_label -side left -anchor w -expand yes -fill x -padx 3
    match_linux_wm [list label $id.label.fontsize_label -text "size" -width 4]
    match_linux_wm [list entry $id.label.fontsize_entry \
		-textvariable ::dialog($vid:gn_fs) -width 5]
    pack $id.label.fontsize_entry $id.label.fontsize_label \
        -side right -anchor e -padx 5 -pady 3
    match_linux_wm [list menu $id.popup -tearoff 0]
    $id.popup add command \
        -label $fontname \
        -font [format {{%s} 9 %s} $fontname $fontweight] \
        -command "iemgui_toggle_font $id 0"
    $id.popup add command \
        -label "Helvetica" \
        -font [format {Helvetica 9 %s} $fontweight] \
        -command "iemgui_toggle_font $id 1" 
    $id.popup add command \
        -label "Times" \
        -font [format {Times 9 %s} $fontweight] \
        -command "iemgui_toggle_font $id 2" 
    bind $id.label.fontpopup_label <Button> \
        [list tk_popup $id.popup %X %Y]

    match_linux_wm [list frame $id.spacer2 -height 7]
    pack $id.spacer2 -side top
    
    match_linux_wm [list labelframe $id.colors -borderwidth 1 \
		-text "colors" -font highlight_font -padx 3]
    pack $id.colors -fill x -padx 3 -pady 3 -ipadx 3 -ipady 3
    
    match_linux_wm [list frame $id.colors.select]
    pack $id.colors.select -side top
    match_linux_wm [list radiobutton $id.colors.select.radio0 -value 0 -variable \
        ::dialog($vid:l2_f1_b0) -text "background" -width 10]
    match_linux_wm [list radiobutton $id.colors.select.radio1 -value 1 -variable \
        ::dialog($vid:l2_f1_b0) -text "front" -width 5]
    match_linux_wm [list radiobutton $id.colors.select.radio2 -value 2 -variable \
        ::dialog($vid:l2_f1_b0) -text "label" -width 5]
    if { $::dialog($vid:fcol) >= 0 } {
        pack $id.colors.select.radio0 $id.colors.select.radio1 \
            $id.colors.select.radio2 -side left
    } else {
        pack $id.colors.select.radio0 $id.colors.select.radio2 -side left \
        }
    
    match_linux_wm [list frame $id.colors.sections]
    pack $id.colors.sections -side top
	# disabled until we can get themeable chooseColor dialog    
	match_linux_wm [list button $id.colors.sections.but -text "Compose Color" \
		-width 12 -command "iemgui_choose_col_bkfrlb $id" -underline 5]
    pack $id.colors.sections.but -side left -anchor w -padx 3 -pady 5 \
        -expand yes -fill x
	bind $id <Alt-KeyPress-s> [format "iemgui_choose_col_bkfrlb %s" $id]
    if { $::dialog($vid:fcol) >= 0 } {
        match_linux_wm [list label $id.colors.sections.fr_bk -text "o=||=o" -width 6 \
            -background [format "#%6.6x" $::dialog($vid:bcol)] \
            -activebackground [format "#%6.6x" $::dialog($vid:bcol)] \
            -foreground [format "#%6.6x" $::dialog($vid:fcol)] \
            -activeforeground [format "#%6.6x" $::dialog($vid:fcol)] \
            -font [list $current_font 9 $fontweight] -padx 2 -pady 2 -relief ridge]
    } else {
        match_linux_wm [list label $id.colors.sections.fr_bk -text "o=||=o" -width 6 \
            -background [format "#%6.6x" $::dialog($vid:bcol)] \
            -activebackground [format "#%6.6x" $::dialog($vid:bcol)] \
            -foreground [format "#%6.6x" $::dialog($vid:bcol)] \
            -activeforeground [format "#%6.6x" $::dialog($vid:bcol)] \
            -font [list $current_font 9 $fontweight] -padx 2 -pady 2 -relief ridge]
    }
    match_linux_wm [list label $id.colors.sections.lb_bk -text "testlabel" -width 9 \
        -background [format "#%6.6x" $::dialog($vid:bcol)] \
        -activebackground [format "#%6.6x" $::dialog($vid:bcol)] \
        -foreground [format "#%6.6x" $::dialog($vid:lcol)] \
        -activeforeground [format "#%6.6x" $::dialog($vid:lcol)] \
        -font [list $current_font 9 $fontweight] -padx 2 -pady 2 -relief ridge]
    pack $id.colors.sections.lb_bk $id.colors.sections.fr_bk \
        -side right -anchor e -expand yes -fill both -pady 7 -padx 3

    # color scheme by Mary Ann Benedetto http://piR2.org
    match_linux_wm [list frame $id.colors.r1]
    pack $id.colors.r1 -side top
    foreach i { 0 1 2 3 4 5 6 7 8 9 } \
        hexcol { 0xFFFFFF 0xDFDFDF 0xBBBBBB 0xFFC7C6 0xFFE3C6 \
                     0xFEFFC6 0xC6FFC7 0xc6FEFF 0xC7C6FF 0xE3C6FF } \
        {
            label $id.colors.r1.c$i \
				-background [format "#%6.6x" $hexcol] \
                -activebackground [format "#%6.6x" $hexcol] -relief ridge \
                -padx 7 -pady 0
            bind $id.colors.r1.c$i <Button> [format "iemgui_preset_col %s %d" $id $hexcol] 
        }
    pack $id.colors.r1.c0 $id.colors.r1.c1 $id.colors.r1.c2 $id.colors.r1.c3 \
        $id.colors.r1.c4 $id.colors.r1.c5 $id.colors.r1.c6 $id.colors.r1.c7 \
        $id.colors.r1.c8 $id.colors.r1.c9 -side left
    
    match_linux_wm [list frame $id.colors.r2]
    pack $id.colors.r2 -side top
    foreach i { 0 1 2 3 4 5 6 7 8 9 } \
        hexcol { 0x9F9F9F 0x7C7C7C 0x606060 0xFF0400 0xFF8300 \
                     0xFAFF00 0x00FF04 0x00FAFF 0x0400FF 0x9C00FF } \
        {
            label $id.colors.r2.c$i \
				-background [format "#%6.6x" $hexcol] \
                -activebackground [format "#%6.6x" $hexcol] -relief ridge \
                -padx 7 -pady 0
            bind  $id.colors.r2.c$i <Button> \
                [format "iemgui_preset_col %s %d" $id $hexcol] 
        }
    pack $id.colors.r2.c0 $id.colors.r2.c1 $id.colors.r2.c2 $id.colors.r2.c3 \
        $id.colors.r2.c4 $id.colors.r2.c5 $id.colors.r2.c6 $id.colors.r2.c7 \
        $id.colors.r2.c8 $id.colors.r2.c9 -side left
    
    match_linux_wm [list frame $id.colors.r3]
    pack $id.colors.r3 -side top
    foreach i { 0 1 2 3 4 5 6 7 8 9 } \
        hexcol { 0x404040 0x202020 0x000000 0x551312 0x553512 \
                     0x535512 0x0F4710 0x0E4345 0x131255 0x2F004D } \
        {
            label $id.colors.r3.c$i \
				-background [format "#%6.6x" $hexcol] \
                -activebackground [format "#%6.6x" $hexcol] -relief ridge \
                -padx 7 -pady 0
            bind  $id.colors.r3.c$i <Button> \
                [format "iemgui_preset_col %s %d" $id $hexcol] 
        }
    pack $id.colors.r3.c0 $id.colors.r3.c1 $id.colors.r3.c2 $id.colors.r3.c3 \
        $id.colors.r3.c4 $id.colors.r3.c5 $id.colors.r3.c6 $id.colors.r3.c7 \
        $id.colors.r3.c8 $id.colors.r3.c9 -side left
    
    match_linux_wm [list frame $id.cao -pady 3]
    pack $id.cao -side top
    match_linux_wm [list button $id.cao.cancel -text {Cancel} -width 6 \
        -command "iemgui_cancel $id"]
    match_linux_wm [list label $id.cao.dummy1 -text "" -width 3]
    match_linux_wm [list button $id.cao.apply -text {Apply} \
		-width 6 -command "iemgui_apply $id"]
    match_linux_wm [list label $id.cao.dummy2 -text "" -width 3]
    match_linux_wm [list button $id.cao.ok -text {OK} -width 6 \
        -command "iemgui_ok $id"]
    
    pack $id.cao.cancel $id.cao.dummy1 -side left
    pack $id.cao.apply $id.cao.dummy2 -side left
    pack $id.cao.ok -side left

    if {[info tclversion] < 8.4} {
        bind $id <Key-Tab> {tkTabToWindow [tk_focusNext %W]}
        bind $id <<PrevWindow>> {tkTabToWindow [tk_focusPrev %W]}
    } else {
        bind $id <Key-Tab> {tk::TabToWindow [tk_focusNext %W]}
        bind $id <<PrevWindow>> {tk::TabToWindow [tk_focusPrev %W]}
    }

	if { [info tclversion] < 8.5 } {
    	$id.dim.w_ent select from 0
    	$id.dim.w_ent select adjust end  
	}
	focus $id.dim.w_ent
}
# end of change "iemlib"

############ pdtk_array_dialog -- dialog window for arrays #########
# see comments above (pdtk_gatom_dialog) about variable name handling 

proc array_apply {id canvas} {
    # strip "." from the TK id to make a variable name suffix 
    set vid [string trimleft $id .]
    set mofo $::dialog($vid:name)
    # "#" was 
    # below we take into account any place inside the string
    #if {[string index $mofo 0] == "$"} {
    #    set mofo [string replace $mofo 0 0 #]
    # }
    set mofo [string map {"$" "#"} $mofo]

    set saveit $::dialog($vid:saveit)
    set drawasrects $::dialog($vid:drawasrects)
    set joc $::dialog($vid:joc)
    set fill $::dialog($vid:fill)
    set outline $::dialog($vid:outline)

	# puts stderr "...[expr $saveit + 2 * $drawasrects + 16 * $joc]"
	# puts stderr "tk drawasrects=$drawasrects"

	set xdraw [expr int([$canvas.c canvasx 0])]
	set ydraw [expr int([$canvas.c canvasy 0])]

    pd [concat $id arraydialog $mofo \
            $::dialog($vid:n) \
            [expr $saveit + 2 * $drawasrects + 16 * $joc] \
            $::dialog($vid:otherflag) \
			$xdraw \
			$ydraw \
            $fill $outline \
            \;]
}

# jsarlo
proc array_viewlist {id arraydialogwindow} {
    canvas_cancel $arraydialogwindow
    pd [concat $id arrayviewlistnew\;]
}
# end jsarlo

proc array_cancel {id} {
    set cmd [concat $id cancel \;]
    pd $cmd
}

proc array_ok {id canvas} {
    array_apply $id $canvas
    array_cancel $id
}

proc array_choosecolor {widget mytoplevel colorvar} {
#    set colorp [format "::pd_array_%scolor(%s)" $type $mytoplevel]
#    if {[info exists $colorp]} {
#        set initcolor [set $colorp]
#    } else {
#        set initcolor "black"}
    set tmp [tk_chooseColor -parent $mytoplevel -initialcolor [set $colorvar]]
    if {$tmp eq ""} {
        return
    } else {
        set $colorvar $tmp
        $widget configure -background $tmp -activebackground $tmp
    }
}

proc array_update_drawas {style fillframe outlineframe outlinelabel} {
    if {$style == 3} {
        $outlinelabel configure -text "outline color"
        pack $fillframe -after $outlineframe -side top -anchor w
    } else {
        pack forget $fillframe
        $outlinelabel configure -text "trace color"
    }
}

proc pdtk_array_dialog {gfxstub name n flags newone canvas fill outline} {
    # A little complex:
    # 1) When an array is created from the "Put" menu, there is
    #    no associated canvas dialog.  The array dialog creates its
    #    own toplevel.
    # 2) When an array is changed from the "Properties" dialog,
    #    the array dialog is created as a frame in a ttk::notebook
    #    within the graph's canvas dialog window.  The canvas_properties
    #    method always creates a canvas dialog _before_ any array dialogs,
    #    so we use a global variable-- ::pd_canvasdialog_current-- to
    #    give this array dialog a reference to it's parent window. (But
    #    remember that there can be multiple dialogs open at once, so
    #    pd_canvasdialog_current is only "fresh" for the duration of this
    #    proc...)
    #
    # Variables
    # ---------
    # $gfxstub                   - callback address understood by Pd
    #                              to refer to _this_ array
    #
    # $::pd_canvasdialog_current - as long as this isn't a new array
    #                              (i.e., $newone == 0) this is the
    #                              address of the toplevel that holds
    #                              the ttk::notebook for the array and
    #                              graph dialogs
    #
    # $vid                       - $gfxstub without the "." (probably
    #                              should be replaced with tcl arrays)
    # $id                        - abstracted widget parent (may be a
    #                              notebook, toplevel, etc.)
    # $mytoplevel                - toplevel window for this dialog
    #
    ##################################################################



if {[catch {
    set vid [string trimleft $gfxstub .]
    set ::dialog($vid:canvas) $canvas
    set ::dialog($vid:name) $name
    set ::dialog($vid:n) $n
    set ::dialog($vid:saveit) [expr ( $flags & 1 ) != 0]
    set ::dialog($vid:drawasrects) [expr ( $flags & 6 ) >> 1]
    set ::dialog($vid:joc) [expr ( $flags & 16 ) != 0]
    set ::dialog($vid:otherflag) 0
    set ::dialog($vid:fill) $fill
    set ::dialog($vid:outline) $outline

    set multiarray_graph 0

    set id {}
    set mytoplevel {}

    if {$newone} {
        set id $gfxstub
        set mytoplevel $id

        toplevel $id -class [winfo class .]
        wm title $id {New Array}
        match_linux_wm [list $id configure]
        wm resizable $id 0 0
        global pointer_x_global pointer_y_global
        wm geometry $id \
            "+[expr $pointer_x_global+50]+[expr $pointer_y_global-12]"
        wm attributes $id -topmost 1
        wm protocol $id WM_DELETE_WINDOW [concat array_cancel $id]
    } else {
        set id $::pd_canvasdialog_current
        # if we're the first array, then get rid of
        # stupid options in the graph tab that are of
        # no use
        if {[$id.n index end] == 1} {
            pack forget $id.n.canvasdialog.x.f2.label4
            pack forget $id.n.canvasdialog.x.f2.entry4
            pack forget $id.n.canvasdialog.y.f2.label4
            pack forget $id.n.canvasdialog.y.f2.entry4
            pack configure $id.n.canvasdialog.x.f2.label3 -expand 0
            pack configure $id.n.canvasdialog.x.f2.entry3 -expand 0
            pack configure $id.n.canvasdialog.y.f2.label3 -expand 0
            pack configure $id.n.canvasdialog.y.f2.entry3 -expand 0
            foreach slave [pack slaves $id.n.canvasdialog] {
                if {[string match *scale $slave] ||
                    [string match *graphme $slave]} {
                    pack forget $slave
                }
            }
        }
        set mytoplevel $id
        set arrayno [$id.n index end]
        set multiarray_graph [expr {$arrayno-1 != 0}]
        set title [format "Array #%d" $arrayno]
        if {$arrayno == 1} {
            set title "Array"
        } else {
            $id.n tab 0 -text "Array #1"
        }
        $id.n insert \
            [expr {[$id.n index end]-1}] [match_linux_wm [list frame $id.n$gfxstub]] -text $title -padding 6
        $id.n configure -style TNotebook
        $id.n select 0
        wm title $id {Array Properties}
        set id $id.n$gfxstub
    }

    pdtk_panelkeybindings $id "array"
    global pd_nt ctrl_key
    pdtk_standardkeybindings $id
	#override panelkeybindings with an unusual ok/apply format

    if {$newone} {
        bind $id <KeyPress-Return> [format "array_ok $id $canvas"]
    } else {
        bind $id <KeyPress-Return> [format "canvas_ok $mytoplevel"]
    }

    match_linux_wm [list frame $id.name]
    pack $id.name -side top -pady 3
    match_linux_wm [list label $id.name.label -text "name"]
    # replace # with $ if it is followed by a number, otherwise treat as string
    set temp $::dialog($vid:name)
	set ::dialog($vid:name) [iemgui_r2d $temp]
    #if {[string index $::dialog($vid:name) 0] == "#"} {
	#	set next [string index $::dialog($vid:name) 1]
	#	if {$next != "" && [string is integer $next]} {
	#		set ::dialog($vid:name) [string replace $::dialog($vid:name) 0 0 $]
	#	}
    #}
    match_linux_wm [list entry $id.name.entry -textvariable ::dialog($vid:name)]
    pack $id.name.label $id.name.entry -side left -padx 3 -pady 3

    match_linux_wm [list frame $id.n]
    pack $id.n -side top
    match_linux_wm [list label $id.n.label -text "   size"]
    match_linux_wm [list entry $id.n.entry -textvariable ::dialog($vid:n)]
    pack $id.n.label $id.n.entry -side left -padx 3 -pady 6

    # hack so I don't have to rename everything
    set old_id $id
    set id [match_linux_wm [list frame $id.settings]]
    pack $id

    match_linux_wm [list checkbutton $id.saveme -text {save contents} \
	-variable ::dialog($vid:saveit)]
    pack $id.saveme -side top -pady 1 -anchor w
    match_linux_wm [list checkbutton $id.joc -text {jump on click} \
        -variable ::dialog($vid:joc)]
    pack $id.joc -side top -pady 1 -anchor w

    set ffr $id.fillframe
    set ofr $id.outlineframe
    set olabel $id.outlineframe.l

    match_linux_wm [list frame $id.drawasrects]
    pack $id.drawasrects -side top -pady 3 -anchor w
    match_linux_wm [list label $id.drawasrects.l -text "draw as:"]
    pack $id.drawasrects.l -side top -pady 3 -anchor w
    match_linux_wm [list radiobutton $id.drawasrects.drawasrects0 -value 1 \
        -variable ::dialog($vid:drawasrects) \
        -text "points" \
        -command "array_update_drawas 1 $ffr $ofr $olabel"]
    match_linux_wm [list radiobutton $id.drawasrects.drawasrects1 -value 0 \
        -variable ::dialog($vid:drawasrects) \
        -text "polygon" \
        -command "array_update_drawas 0 $ffr $ofr $olabel"]
    #match_linux_wm [list radiobutton $id.drawasrects.drawasrects2 -value 2 \
    #    -variable ::dialog($vid:drawasrects) \
    #    -text "bezier curve" \
    #    -command "array_update_drawas 2 $ffr $ofr $olabel"]
    match_linux_wm [list radiobutton $id.drawasrects.drawasrects3 -value 3 \
        -variable ::dialog($vid:drawasrects) \
        -text "bar graph" \
        -command "array_update_drawas 3 $ffr $ofr $olabel"]
    pack $id.drawasrects.drawasrects0 -side top -anchor w
    pack $id.drawasrects.drawasrects1 -side top -anchor w
    #pack $id.drawasrects.drawasrects2 -side top -anchor w
    pack $id.drawasrects.drawasrects3 -side top -anchor w

    foreach attr {outline fill} {
        set f [match_linux_wm [list frame $id.${attr}frame]]
        pack $f -pady 5 -anchor w
        button $f.b -relief raised -padx 7 -pady 0 \
            -background [set $attr] -activebackground [set $attr] \
            -command \
                "array_choosecolor $f.b $mytoplevel ::dialog($vid:$attr)"
        pack $f.b -side left -anchor w
        match_linux_wm [list label $f.l -text "$attr color"]
        pack $f.l -side left -anchor w
        bind $f.l <Enter> "$f.l configure -foreground blue"
        bind $f.l <Leave> "$f.l configure -foreground black"
        bind $f.l <1> "$f.b invoke"
    }
    array_update_drawas [set ::dialog($vid:drawasrects)] $ffr $ofr $olabel

    if {$newone != 0} { 
        match_linux_wm [list frame $id.radio]
        pack $id.radio -side top -pady 3 -anchor w
        match_linux_wm [list radiobutton $id.radio.radio0 -value 0 \
            -variable ::dialog($vid:otherflag) \
            -text "in new graph"]
        match_linux_wm [list radiobutton $id.radio.radio1 -value 1 \
            -variable ::dialog($vid:otherflag) \
            -text "in last graph"]
        pack $id.radio.radio0 -side top -anchor w
        pack $id.radio.radio1 -side top -anchor w
    }

    set id $old_id

    # jsarlo
    if {$newone == 0} {
        match_linux_wm [list button $id.listview -text {View list}\
           -command "array_viewlist $gfxstub $mytoplevel"]
        pack $id.listview -side right -padx 3 -pady 3
        match_linux_wm [list checkbutton $id.deleteme -text {delete me} \
            -variable ::dialog($vid:otherflag)]
        if {$multiarray_graph} {
            pack $id.deleteme -side left
        }
        # end jsarlo
    } else {
    match_linux_wm [list frame $id.buttonframe]
    pack $id.buttonframe -side bottom -fill x
    match_linux_wm [list button $id.buttonframe.cancel -text {Cancel}\
        -command "array_cancel $id"]
#    if {$newone == 0} {
#		match_linux_wm [list button \
#		$id.buttonframe.apply -text {Apply} \
#           -command "array_apply $id $canvas"]
#	}
    match_linux_wm [list button $id.buttonframe.ok -text {OK} \
        -command "array_ok $id $canvas"]
    pack $id.buttonframe.cancel -side left -expand 1 -pady 3 -padx 3
    if {$newone == 0} {
        pack $id.buttonframe.apply -side left -expand 1 -pady 3 -padx 3
    }
    if {$newone} {pack $id.buttonframe.ok -side left -expand 1 -pady 3 -padx 3}
}
    
	if { [info tclversion] < 8.5 } {
    	$id.name.entry select from 0
    	$id.name.entry select adjust end
	}
    focus $id.name.entry
}]} {pdtk_post "array dialog error: $::errorInfo\n"}
}

############ pdtk_canvas_dialog -- dialog window for canvass #########
# see comments above (pdtk_gatom_dialog) about variable name handling 

proc canvas_apply {id} {
	# puts stderr pdtk_canvas_apply
    # strip "." from the TK id to make a variable name suffix 
    set vid [string trimleft $id .]
    # for each variable, make a local variable to hold its name...
    foreach tab [$id.n tabs] {
        set arraytab ""
        if {[regexp [list $id\.n(\.gfxstub.+)] $tab - arrayid]} {
            set arrayvid [string trimleft $arrayid .]
            array_apply $arrayid [set ::dialog($arrayvid:canvas)]
        }
    }
    pd [concat $id donecanvasdialog \
            $::dialog($vid:xscale) \
            $::dialog($vid:yscale) \
            [expr $::dialog($vid:graphme)+2*$::dialog($vid:hidetext)] \
            $::dialog($vid:x1) \
            $::dialog($vid:y1) \
            $::dialog($vid:x2) \
            $::dialog($vid:y2) \
            $::dialog($vid:xpix) \
            $::dialog($vid:ypix) \
            $::dialog($vid:xmargin) \
            $::dialog($vid:ymargin) \
            \;]
}

proc canvas_cancel {id} {
    set cmd [concat $id cancel \;]
    pd $cmd
}

proc canvas_ok {id} {
    canvas_apply $id
    canvas_cancel $id
}

proc canvas_checkcommand {id} {
    set vid [string trimleft $id .]
    set id $id.n.canvasdialog
    if { $::dialog($vid:graphme) != 0 } {
        $id.hidetext configure -state normal
        $id.x.f1.entry1 configure -state normal
        $id.x.f1.entry2 configure -state normal
        $id.x.f2.entry3 configure -state normal
        $id.x.f2.entry4 configure -state normal
        $id.y.f1.entry1 configure -state normal
        $id.y.f1.entry2 configure -state normal
        $id.y.f2.entry3 configure -state normal
        $id.y.f2.entry4 configure -state normal
        $id.xscale.entry configure -state disabled
        $id.yscale.entry configure -state disabled
        set x1 $::dialog($vid:x1)
        set y1 $::dialog($vid:y1)
        set x2 $::dialog($vid:x2)
        set y2 $::dialog($vid:y2)
        if { $::dialog($vid:x1) == 0 && \
                 $::dialog($vid:y1) == 0 && \
                 $::dialog($vid:x2) == 0 && \
                 $::dialog($vid:y2) == 0 } {
            set ::dialog($vid:x2) 1
            set ::dialog($vid:y2) 1
        }
        if { $::dialog($vid:xpix) == 0 } {
            set ::dialog($vid:xpix) 85
            set ::dialog($vid:xmargin) 100
        }
        if { $::dialog($vid:ypix) == 0 } {
            set ::dialog($vid:ypix) 60
            set ::dialog($vid:ymargin) 100
        }
    } else {
        $id.hidetext configure -state disabled
        $id.x.f1.entry1 configure -state disabled
        $id.x.f1.entry2 configure -state disabled
        $id.x.f2.entry3 configure -state disabled
        $id.x.f2.entry4 configure -state disabled
        $id.y.f1.entry1 configure -state disabled
        $id.y.f1.entry2 configure -state disabled
        $id.y.f2.entry3 configure -state disabled
        $id.y.f2.entry4 configure -state disabled
        $id.xscale.entry configure -state normal
        $id.yscale.entry configure -state normal
        if { $::dialog($vid:xscale) == 0 } {
            set ::dialog($vid:xscale) 1
        }
        if { $::dialog($vid:yscale) == 0 } {
            set ::dialog($vid:yscale) -1
        }
        if { $::dialog($vid:hidetext) == 1 } {
            set ::dialog($vid:hidetext) 0
        }
    }
}

proc pdtk_canvas_dialog_undo_update {name x y} {
	if {$x==0} {
		$name.graphme instate {selected} {
			$name.graphme invoke
		}
	} elseif {$x==1} {
		$name.graphme instate {!selected} {
			$name.graphme invoke
		}
	}

	if {$y==0} {
		$name.hidetext instate {selected} {
			$name.hidetext invoke
		}
	} elseif {$y==1} {
		$name.hidetext instate {!selected} {
			$name.hidetext invoke
		}
	}
}

proc pdtk_canvas_dialog {id xscale yscale graphme x1 y1 x2 y2 \
                             xpix ypix xmargin ymargin} {
    set vid [string trimleft $id .]
    set ::dialog($vid:xscale) $xscale
    set ::dialog($vid:yscale) $yscale
    set ::dialog($vid:graphme) [expr ($graphme!=0)?1:0]
    set ::dialog($vid:hidetext) [expr ($graphme&2)?1:0]
    set ::dialog($vid:x1) $x1
    set ::dialog($vid:y1) $y1
    set ::dialog($vid:x2) $x2
    set ::dialog($vid:y2) $y2
    set ::dialog($vid:xpix) $xpix
    set ::dialog($vid:ypix) $ypix
    set ::dialog($vid:xmargin) $xmargin
    set ::dialog($vid:ymargin) $ymargin

    toplevel $id -class [winfo class .]
    wm title $id {Canvas Properties}
	match_linux_wm [list $id configure]
	wm resizable $id 0 0
	global tmp_xpix tmp_ypix
	wm geometry $id "+$tmp_xpix+$tmp_ypix"
    wm protocol $id WM_DELETE_WINDOW [concat canvas_cancel $id]

    ttk::style layout Plain.TNotebook.Tab {Notebook.tab -side left}
    #ttk::notebook $id.n -style Plain.TNotebook
    ttk::notebook $id.n -style TNotebook
    $id.n add [match_linux_wm [list frame $id.n.canvasdialog]] \
        -text "Graph" -sticky nsew -padding 6

    pack $id.n -fill x -padx 3 -pady 3
    # store the current canvas_dialog gfxstub id
    # in a global variable.  This will be fetched by
    # pdtk_array_dialog so that it can append
    # itself to the canvas dialog, rather than spawning
    # multiple dialogs on top of each other. We can
    # do this because canvas_properties creates a
    # canvas dialog _before_ calling garray_properties--
    # that will guarantee that the global id set here
    # is "fresh".
    set ::pd_canvasdialog_current $id

    pdtk_panelkeybindings $id "canvas"
    set wid $id
    set id $id.n.canvasdialog

	#superfluous repetition of window title information
	#match_linux_wm [list label $id.toplabel -text "Canvas Properties"]
    #pack $id.toplabel -side top
    
    match_linux_wm [list frame $id.xscale]
    pack $id.xscale -side top -pady 3
    match_linux_wm [list label $id.xscale.label -text "X units per pixel"]
    match_linux_wm [list entry $id.xscale.entry \
		-textvariable ::dialog($vid:xscale) -width 10]
    pack $id.xscale.label $id.xscale.entry -side left -pady 3 -padx 3

    match_linux_wm [list frame $id.yscale]
    pack $id.yscale -side top
    match_linux_wm [list label $id.yscale.label -text "Y units per pixel"]
    match_linux_wm [list entry $id.yscale.entry \
		-textvariable ::dialog($vid:yscale) -width 10]
    pack $id.yscale.label $id.yscale.entry -side left -padx 3

    match_linux_wm [list checkbutton $id.graphme -text {graph on parent} \
        -variable ::dialog($vid:graphme) \
        -command [concat canvas_checkcommand $wid]]
    pack $id.graphme -side top

    match_linux_wm [list checkbutton $id.hidetext \
		-text {hide object name and arguments} \
        -variable ::dialog($vid:hidetext) \
        -command [concat canvas_checkcommand $wid]]
    pack $id.hidetext -side top

    match_linux_wm [list labelframe $id.x -text "X-axis"]
    match_linux_wm [list frame $id.x.f1]
    match_linux_wm [list frame $id.x.f2]
    pack $id.x -side top -pady 6
    pack $id.x.f1 -side top -fill x
    pack $id.x.f2 -side top -fill x
    match_linux_wm [list label $id.x.f1.label1 -text "from"]
    match_linux_wm [list entry $id.x.f1.entry1 \
		-textvariable ::dialog($vid:x1) -width 6]
    match_linux_wm [list label $id.x.f1.label2 -text "to"]
    match_linux_wm [list entry $id.x.f1.entry2 \
		-textvariable ::dialog($vid:x2) -width 6]
    match_linux_wm [list label $id.x.f2.label3 -text "size"]
    match_linux_wm [list entry $id.x.f2.entry3 \
		-textvariable ::dialog($vid:xpix) -width 4]
    match_linux_wm [list label $id.x.f2.label4 -text "margin"]
    match_linux_wm [list entry $id.x.f2.entry4 \
		-textvariable ::dialog($vid:xmargin) -width 4]
    pack $id.x.f1.label1 $id.x.f1.entry1 \
        $id.x.f1.label2 $id.x.f1.entry2 \
        -side left -pady 3 -padx 3 -expand 1
    pack $id.x.f2.label3 $id.x.f2.entry3 \
        $id.x.f2.label4 $id.x.f2.entry4 \
        -side left -pady 3 -padx 3 -expand 1

    match_linux_wm [list labelframe $id.y -text "Y-axis"]

    match_linux_wm [list frame $id.y.f1]
    match_linux_wm [list frame $id.y.f2]
    pack $id.y -side top -pady 6
    pack $id.y.f1 -side top -fill x
    pack $id.y.f2 -side top -fill x


    pack $id.y -side top
    match_linux_wm [list label $id.y.f1.label1 -text "from"]
    match_linux_wm [list entry $id.y.f1.entry1 \
		-textvariable ::dialog($vid:y1) -width 6]
    match_linux_wm [list label $id.y.f1.label2 -text "to"]
    match_linux_wm [list entry $id.y.f1.entry2 \
		-textvariable ::dialog($vid:y2) -width 6]
    match_linux_wm [list label $id.y.f2.label3 -text "size"]
    match_linux_wm [list entry $id.y.f2.entry3 \
		-textvariable ::dialog($vid:ypix) -width 4]
    match_linux_wm [list label $id.y.f2.label4 -text "margin"]
    match_linux_wm [list entry $id.y.f2.entry4 \
		-textvariable ::dialog($vid:ymargin) -width 4]
    pack $id.y.f1.label1 $id.y.f1.entry1 \
        $id.y.f1.label2 $id.y.f1.entry2 \
        -side left -pady 3 -padx 3 -expand 1
    pack $id.y.f2.label3 $id.y.f2.entry3 \
        $id.y.f2.label4 $id.y.f2.entry4 \
        -side left -pady 3 -padx 3 -expand 1

    match_linux_wm [list frame $wid.buttonframe]
    pack $wid.buttonframe -side bottom -fill x
    match_linux_wm [list button $wid.buttonframe.cancel -text {Cancel}\
        -command "canvas_cancel $wid"]
    match_linux_wm [list button $wid.buttonframe.apply -text {Apply}\
        -command "canvas_apply $wid"]
    match_linux_wm [list button $wid.buttonframe.ok -text {OK}\
        -command "canvas_ok $wid"]
    pack $wid.buttonframe.cancel -side left -expand 1 -pady 3 -padx 3
    pack $wid.buttonframe.apply -side left -expand 1 -pady 3 -padx 3
    pack $wid.buttonframe.ok -side left -expand 1 -pady 3 -padx 3

    if { [info tclversion] < 8.5 } {
		$id.xscale.entry select from 0
		$id.xscale.entry select adjust end
	}
    focus $id.xscale.entry
    canvas_checkcommand $wid
}

############ pdtk_data_dialog -- run a data dialog #########
proc dodata_send {name} {
    #    puts stderr [$name.text get 0.0 end]

    for {set i 1} {[$name.text compare [concat $i.0 + 3 chars] < end]} \
        {incr i 1} {
            #       puts stderr [concat it's [$name.text get $i.0 [expr $i + 1].0]]
            set cmd [concat $name data [$name.text get $i.0 [expr $i + 1].0] \;]
            #       puts stderr $cmd
            pd $cmd
        }
    set cmd [concat $name end \;]
    #    puts stderr $cmd
    pd $cmd
}

proc dodata_cancel {name} {
    set cmd [concat $name cancel \;]
    #    puts stderr $cmd
    pd $cmd
}

proc dodata_ok {name} {
    dodata_send $name
    dodata_cancel $name
}

proc pdtk_data_dialog {name stuff} {
    global pd_deffont
	global pd_nt
    toplevel $name -class [winfo class .]
    match_linux_wm [list $name configure]
    wm title $name {Atom}
    wm protocol $name WM_DELETE_WINDOW [concat dodata_cancel $name]

    pdtk_panelkeybindings $name "dodata"
    bind $name <Control-t> [concat dodata_ok $name]
    bind $name <Control-s> [concat dodata_send $name]

    match_linux_wm [list frame $name.buttonframe]
    pack $name.buttonframe -side bottom -fill x -pady 3
	match_linux_wm [list button $name.buttonframe.send -text {Send (Ctrl+s)}\
    	-command [concat dodata_send $name]]
	match_linux_wm [list button $name.buttonframe.ok -text {OK (Ctrl+t)}\
    	-command [concat dodata_ok $name]]
    pack $name.buttonframe.ok -side right -expand 0 -pady 3 -padx 3
    pack $name.buttonframe.send -side right -expand 0 -pady 3 -padx 3

    match_linux_wm [list text $name.text -relief sunken -bd 1 -height 40 -width 60 \
        -yscrollcommand "$name.scroll set" -font $pd_deffont \
		-highlightthickness 0 -takefocus 0]
    match_linux_wm [list scrollbar $name.scroll -command "$name.text yview"]
    pack $name.scroll -side right -fill y
    pack $name.text -side left -fill both -expand 1
    $name.text insert end $stuff
    focus $name.text
}

############ check or uncheck the "edit" menu item ##############
#####################iemlib#######################
proc pdtk_canvas_editval {name value} {
	global k12_mode
	set ::editmode($name) $value
	#if {[winfo exists $name]} {
		if { $value } {
		    $name.m.edit entryconfigure "Edit mode" -indicatoron false -background "#7dd37d" -foreground black
			if { $k12_mode == 1 } { $name.k12frame.edit.b configure -image i.edit }
		} else {                          
		    $name.m.edit entryconfigure "Edit mode" -indicatoron false -background {} -foreground "#dddddd"
			if { $k12_mode == 1 } { $name.k12frame.edit.b configure -image i.perform }
		}
	#}
	pdtk_canvas_recolor $name $value
	#pdtk_post "pdtk_canvas_editval $value\n"                                             
}

proc pdtk_canvas_tooltips {name value} {
	variable autotips
	global k12_mode
	#global colors
	#if {[winfo exists $name]} {
		if { $value } {
			if { $k12_mode == 0 } {
		   		$name.m.edit entryconfigure "Autotips" -indicatoron false -background "#7dd37d" -foreground black
			}
			set autotips 1
		} else {      
			if { $k12_mode == 0 } {                    
		    	$name.m.edit entryconfigure "Autotips" -indicatoron false -background {} -foreground "#dddddd"
			}
			set autotips 0
		}
	#}                                             
}
#####################iemlib#######################

proc pdtk_canvas_magicglassval {name value} {
	#variable magicglass
	#global colors

    if { $value } {
		$name.m.edit entryconfigure "Cord Inspector" -indicatoron false -background "#7dd37d" -foreground black
		#set magicglass 1
    } else {                          
        $name.m.edit entryconfigure "Cord Inspector" -indicatoron false -background {} -foreground "#dddddd"
		#set magicglass 0
    }                                                 
}

proc pdtk_canvas_update_edit_menu {name value} {
	global global_selection global_clipboard k12_mode

	if {![winfo exists $name]} {return}
	# pdtk_post "update_edit_menu value=$value clipboard=$global_clipboard\n"

	set global_selection $value

    if { $value } {
		$name.m.edit entryconfigure "Cut" -state normal
		$name.m.edit entryconfigure "Copy" -state normal
		$name.m.edit entryconfigure "Duplicate" -state normal
		if { $k12_mode == 0 } {
			$name.m.edit entryconfigure "Reselect" -state normal
			$name.m.edit entryconfigure "Bring To Front" -state normal
			$name.m.edit entryconfigure "Send To Back" -state normal
		}
		$name.m.edit entryconfigure "Tidy Up" -state normal

    } else {                          
		$name.m.edit entryconfigure "Cut" -state disabled
		$name.m.edit entryconfigure "Copy" -state disabled
		$name.m.edit entryconfigure "Duplicate" -state disabled
		if { $k12_mode == 0 } {
			$name.m.edit entryconfigure "Reselect" -state disabled
			$name.m.edit entryconfigure "Bring To Front" -state disabled
			$name.m.edit entryconfigure "Send To Back" -state disabled
		}
		$name.m.edit entryconfigure "Tidy Up" -state disabled
    }

	if {!$global_clipboard} {
		$name.m.edit entryconfigure "Paste" -state disabled
	} else {
		$name.m.edit entryconfigure "Paste" -state normal
	}
}

proc pdtk_canvas_update_paste_menu {value} {
	# pdtk_post "paste_menu $value\n"
	global global_clipboard
	# global menu_windowlist

	set global_clipboard $value                                         
}

############ pdtk_text_new -- create a new text object #2###########
proc pdtk_text_new {canvasname myname x y text font color} {
    #    if {$font < 13} {set fontname [format -*-courier-bold----%d-* $font]}
    #    if {$font >= 13} {set fontname [format -*-courier-----%d-* $font]}
    global pd_fontlist pd_nt
#    switch -- $font {
#        8  { set typeface [lindex $pd_fontlist 0] }
#        9  { set typeface [lindex $pd_fontlist 1] }
#        10 { set typeface [lindex $pd_fontlist 2] }
#        12 { set typeface [lindex $pd_fontlist 3] }
#        14 { set typeface [lindex $pd_fontlist 4] }
#        16 { set typeface [lindex $pd_fontlist 5] }
#        18 { set typeface [lindex $pd_fontlist 6] }
#        24 { set typeface [lindex $pd_fontlist 7] }
#        30 { set typeface [lindex $pd_fontlist 8] }
#        36 { set typeface [lindex $pd_fontlist 9] }
#    }
	#[encoding convertfrom utf-8 $text]
	set print_text [string map { \v \n } $text]
    $canvasname create text $x $y -font [get_font_for_size $font] \
        -tags $myname -text $print_text -fill $color -anchor nw
    #    -tags $myname -text [encoding convertfrom utf-8 $print_text] -fill $color -anchor nw
	$canvasname addtag text withtag $myname
	#$canvasname bind $myname <Home> [concat $canvasname icursor $myname 0]
	#$canvasname bind $myname <End> [concat $canvasname icursor $myname end]
	if {$pd_nt == 2} { # emacs bindings for Mac OS X
		$canvasname bind $myname <Control-a> \
			[concat $canvasname icursor $myname 0]
		$canvasname bind $myname <Control-e> \
			[concat $canvasname icursor $myname end]
	}
    #    pd [concat $myname size [$canvasname bbox $myname] \;]
}

################ pdtk_text_set -- change the text ##################
proc pdtk_text_set {canvasname myname text} {
    set print_text [string map { \v \n } $text]
    # catch {$canvasname itemconfig $myname -text [encoding convertfrom utf-8 $print_text]}
    catch {$canvasname itemconfig $myname -text $print_text}
    #    pd [concat $myname size [$canvasname bbox $myname] \;]
}

############### event binding procedures for Pd window ################

proc pdtk_pd_ctrlkey {name key shift} {
	global pd_nt
    #    puts stderr [concat key $key shift $shift]
    #    .dummy itemconfig goo -text [concat ---> control-key event $key];
    if {$shift == 1} {
        if {$key == "l" || $key == "L"} {menu_clear_console}
        if {$key == "q" || $key == "Q"} {menu_really_quit}
        if {$key == "r" || $key == "R"} {menu_toggle_console}
    } else {
        if {$key == "b" || $key == "B"} {::dialog_search::open_helpbrowser .search}
        if {$key == "n" || $key == "N"} {menu_new}
        if {$key == "o" || $key == "O"} {menu_open}
        if {$key == "q" || $key == "Q"} {menu_quit}
        if {$key == "semicolon"} {menu_raise_console}
        if {$pd_nt != 2} {
            # Cmd-m is minimize window on Mac OS X
            if {$key == "m" || $key == "M"} {menu_send}
		} else {
            if {$key == "m" || $key == "M"} {menu_minimize}
		}
        if {$key == "slash"} {menu_audio 1}
        if {$key == "period"} {menu_audio 0}
	}
}

set font_family "courier"
set font_weight "normal"

set font_fixed_metrics {
    8 5 11
    9 6 12
    10 6 13
    12 7 16
    14 8 17
    16 10 19
    18 11 22
    24 14 29
    30 18 37
    36 22 44
}
set font_measured_metrics {}

# creates all the base fonts (i.e. pd_font_8 thru pd_font_36) so that they fit
# into the metrics given by $::font_fixed_metrics for any given font/weight
proc fit_font_into_metrics {} {
# TODO the fonts picked seem too small, probably on fixed width
    foreach {size width height} $::font_fixed_metrics {
        set myfont [get_font_for_size $size]
        font create $myfont -family $::font_family -weight $::font_weight \
            -size [expr {-$height}]
        set height2 $height
        set giveup 0
        while {[font measure $myfont M] > $width || \
            [font metrics $myfont -linespace] > $height} {
            incr height2 -1
            font configure $myfont -size [expr {-$height2}]
            if {$height2 * 3 <= $height} {
                set giveup 1
                set ::font_measured_metrics $::font_fixed_metrics
                break
            }
        }
        set ::font_measured_metrics \
            "$::font_measured_metrics  $size\
                [font measure $myfont M] [font metrics $myfont -linespace]"
        if {$giveup} {
            pdtk_post [format \
    [_ "WARNING: %s failed to find font size (%s) that fits into %sx%s!\n"]\
               [lindex [info level 0] 0] $size $width $height]
            continue
        }
    }
}

proc get_font_for_size {size} {
    return "::pd_font_${size}"
}

proc find_default_font {} {
    set testfonts {"DejaVu Sans Mono" "Bitstream Vera Sans Mono" \
        "Inconsolata" "Courier 10 Pitch" "Andale Mono" "Droid Sans Mono"}
    foreach family $testfonts {
        if {[lsearch -exact -nocase [font families] $family] > -1} {
            set ::font_family $family
            break
        }
    }
    # ::pdwindow::verbose 0 "Default font: $::font_family\n"
}

proc set_base_font {family weight} {
    if {[lsearch -exact [font families] $family] > -1} {
        set ::font_family $family
    }
    if {[lsearch -exact {bold normal} $weight] > -1} {
        set ::font_weight $weight
        set using_defaults 0
    }
}

######### startup function.  ##############
# Tell pd the current directory; this is used in case the command line
# asked pd to open something.  Also, get character width and height for
# seven "useful" font sizes.

# tb: user defined typefaces
proc pdtk_pd_startup {version apilist midiapilist fontname_from_pd fontweight_from_pd} {
    #    puts stderr [concat $version $apilist $fontname]
    global pd_myversion pd_apilist pd_midiapilist pd_nt
    set pd_myversion $version
    set pd_apilist $apilist
    set pd_midiapilist $midiapilist
    global fontname fontweight
    set fontname $fontname_from_pd
    set fontweight $fontweight_from_pd
    global pd_fontlist
    set pd_fontlist {}
	
	# on Mac OS X, lower the Pd window to the background so patches open on top
	if {$pd_nt == 2} { lower . }
	# on Windows, raise the Pd window so that it has focused when launched
	if {$pd_nt == 1} { raise . }

    set fontlist ""
	if {[info tclversion] >= 8.5} {find_default_font}
	set_base_font $fontname_from_pd $fontweight_from_pd
	fit_font_into_metrics

    # UBUNTU MONO 6 6 8 10 11 14 14 19 22 30
	# DEJAVU SANS MONO 6 6 8 9 10 12 14 18 22 29
#    foreach i {6 6 8 10 11 14 14 19 22 30} {
#        set font [format {{%s} %d %s} $fontname_from_pd $i $fontweight_from_pd]
#        set pd_fontlist [linsert $pd_fontlist 100000 $font] 
#        set width0 [font measure  $font x]
#        set height0 [lindex [font metrics $font] 5]
#        set fontlist [concat $fontlist $i [font measure  $font x] \
#                          [lindex [font metrics $font] 5]]
#    }

    set tclpatch [info patchlevel]
    if {$tclpatch == "8.3.0" || \
            $tclpatch == "8.3.1" || \
            $tclpatch == "8.3.2" || \
            $tclpatch == "8.3.3" } {
        set oldtclversion 1
    } else {
        set oldtclversion 0
    }
    pd [concat pd init [pdtk_enquote [pwd]] $oldtclversion $::font_fixed_metrics \;];

    # add the audio and help menus to the Pd window.  We delayed this
    # so that we'd know the value of "apilist".
    menu_addstd .mbar 

    global pd_nt
    if {$pd_nt == 2} {
        global pd_macdropped pd_macready
        set pd_macready 1
        foreach file $pd_macdropped {
            pd [concat pd open [pdtk_enquote [file tail $file]] \
                    [pdtk_enquote  [file dirname $file]] \;]
            menu_doc_open [file dirname $file] [file tail $file]
        }
    }
}

##################### DSP ON/OFF, METERS, DIO ERROR ###################
proc pdtk_pd_dsp {value} {
    global ctrls_audio_on
    if {$value == "ON"} {set ctrls_audio_on 1} else {set ctrls_audio_on 0}
    #    puts stderr [concat its $ctrls_audio_on]
}

proc pdtk_pd_meters {indb outdb inclip outclip} {
    #    puts stderr [concat meters $indb $outdb $inclip $outclip]
    global ctrls_inlevel ctrls_outlevel
    set ctrls_inlevel $indb
    if {$inclip == 1} {
        .controls.inout.in.clip configure -style IOErrorOn.TButton
    } else {
        .controls.inout.in.clip configure -style IOErrorOff.TButton
    }
    set ctrls_outlevel $outdb
    if {$outclip == 1} {
        .controls.inout.out.clip configure -style IOErrorOn.TButton
    } else {
        .controls.inout.out.clip configure -style IOErrorOff.TButton
    }
    
}

set sched_dio_off 0

proc pdtk_pd_dio {red} {
    #puts stderr [concat dio $red]
	global pd_nt
	global sched_dio_off
    if {$red == 1} {
		#puts stderr on
		after cancel $sched_dio_off
		set sched_dio_off [after 1000 pdtk_pd_dio 0]
		if {[info tclversion] >= 8.5 && $pd_nt == 0} {
			.controls.dio configure -style IOErrorOn.TButton
		} else {
	        .controls.dio configure -background red -activebackground red
		}
    } else {
		#puts stderr off
		if {[info tclversion] >= 8.5 && $pd_nt == 0} {
			.controls.dio configure -style IOErrorOff.TButton
		} else {
	        .controls.dio configure -background grey -activebackground lightgrey
		}		
    }
        
}

############# text editing from the "edit" menu ###################

proc texteditor_send {name} {
    set topname [string trimright $name .text]
    for {set i 0} \
        {[$name compare [concat 0.0 + [expr $i + 1] chars] < end]} \
            {incr i 1} {
        set cha [$name get [concat 0.0 + $i chars]]
        scan $cha %c keynum
        pd [concat pd key 1 $keynum 0 \;]
    }
}

proc texteditor_ok {name} {
    set topname [string trimright $name .text]
    texteditor_send $name
    destroy $topname
}

proc pdtk_pd_texteditor {stuff} {
    global pd_deffont
	global pd_nt
    if { [winfo exists .texteditor.text] } {
        raise .texteditor
    } else {
		set name .texteditor

		toplevel $name -class [winfo class .]
		match_linux_wm [list $name configure]
		wm title $name {Text Editor}

		pdtk_standardkeybindings $name
		bind $name <Control-t> {texteditor_ok %W}
		bind $name <Control-s> {texteditor_send %W}

		match_linux_wm [list frame $name.buttons]
		pack $name.buttons -side bottom -fill x  
		match_linux_wm [list button $name.buttons.send -text {Send (Ctrl s)}\
			-command "texteditor_send $name.text"]
		match_linux_wm [list button $name.buttons.ok -text {OK (Ctrl t)}\
			-command "texteditor_ok $name.text"]
		pack $name.buttons.ok -side right -expand 0 -padx 3 -pady 3
		pack $name.buttons.send -side right -expand 0 -padx 3 -pady 3

		match_linux_wm [list text $name.text -relief sunken -bd 1 -height 12 -width 60 \
		    -yscrollcommand "$name.scroll set" -font $pd_deffont \
			-highlightthickness 0 -takefocus 0]
		match_linux_wm [list scrollbar $name.scroll -command "$name.text yview"]
		pack $name.scroll -side right -fill y
		pack $name.text -side left -fill both -expand 1
		$name.text insert end $stuff
		focus $name.text
	}
}

#  paste text into a text box
proc pdtk_pastetext {} {
    global pdtk_pastebuffer
    set pdtk_pastebuffer ""
    catch {global pdtk_pastebuffer; set pdtk_pastebuffer [clipboard get]}
	#puts stderr "paste <$pdtk_pastebuffer>"
    for {set i 0} {$i < [string length $pdtk_pastebuffer]} {incr i 1} {
        set cha [string index $pdtk_pastebuffer $i]
        scan $cha %c keynum
        #puts stderr "keynum=<$keynum>"
        #if { $keynum == 11 } {
        #	set keynum 15
        #}
		if {$i == [expr [string length $pdtk_pastebuffer] - 1]} {
			# unlike key command which would be pd [concat pd key 1 $keynum 0\;]
			# we add first digit to ask for force getscroll as we limit the number of 
			# getscrolls we can get per second so last one is likely to be eaten up
			# in the process
        	pd [concat pd pastetext 1 1 $keynum 0 0 0\;]
		} else {
        	pd [concat pd pastetext 0 1 $keynum 0 0 0\;]
		}
    }
}

############# open and save dialogs for objects in Pd ##########

proc pdtk_openpanel {target localdir} {
    global pd_opendir
    if {$localdir == ""} {
      set localdir $pd_opendir
    }
    set filename [tk_getOpenFile -initialdir $localdir]
    if {$filename != ""} {
        set directory [string range $filename 0 \
            [expr [string last / $filename ] - 1]]
        set pd_opendir $directory

        pd [concat $target callback [pdtk_enquote $filename] \;]
    }
}

proc pdtk_savepanel {target localdir} {
    global pd_savedir
    if {$localdir == ""} {
      set localdir $pd_savedir
    }
    set filename [tk_getSaveFile -initialdir $localdir]
    if {$filename != ""} {
        pd [concat $target callback [pdtk_enquote $filename] \;]
    }
}

########################### comport hack ########################

set com1 0
set com2 0
set com3 0
set com4 0

proc com1_open {} {
    global com1
    set com1 [open com1 w]
    .dummy itemconfig goo -text $com1
    fconfigure $com1 -buffering none
    fconfigure $com1 -mode 19200,e,8,2
}

proc com1_send {str} {
    global com1
    puts -nonewline $com1 $str
}


############# start a polling process to watch the socket ##############
# this is needed for nt, and presumably for Mac as well.
# in UNIX this is handled by a tcl callback (set up in t_tkcmd.c)

if {$pd_nt == 1} {
    proc polleofloop {} {
        pd_pollsocket
        after 20 polleofloop
    }

    polleofloop
}

####################### audio dialog ##################3

proc audio_apply {id} {
    global audio_indev1 audio_indev2 audio_indev3 audio_indev4 
    global audio_inchan1 audio_inchan2 audio_inchan3 audio_inchan4
    global audio_inenable1 audio_inenable2 audio_inenable3 audio_inenable4
    global audio_outdev1 audio_outdev2 audio_outdev3 audio_outdev4 
    global audio_outchan1 audio_outchan2 audio_outchan3 audio_outchan4
    global audio_outenable1 audio_outenable2 audio_outenable3 audio_outenable4
    global audio_sr audio_advance audio_callback

    pd [concat pd audio-dialog \
        $audio_indev1 \
        $audio_indev2 \
        $audio_indev3 \
        $audio_indev4 \
        [expr $audio_inchan1 * ( $audio_inenable1 ? 1 : -1 ) ]\
        [expr $audio_inchan2 * ( $audio_inenable2 ? 1 : -1 ) ]\
        [expr $audio_inchan3 * ( $audio_inenable3 ? 1 : -1 ) ]\
        [expr $audio_inchan4 * ( $audio_inenable4 ? 1 : -1 ) ]\
        $audio_outdev1 \
        $audio_outdev2 \
        $audio_outdev3 \
        $audio_outdev4 \
        [expr $audio_outchan1 * ( $audio_outenable1 ? 1 : -1 ) ]\
        [expr $audio_outchan2 * ( $audio_outenable2 ? 1 : -1 ) ]\
        [expr $audio_outchan3 * ( $audio_outenable3 ? 1 : -1 ) ]\
        [expr $audio_outchan4 * ( $audio_outenable4 ? 1 : -1 ) ]\
        $audio_sr \
        $audio_advance \
        $audio_callback \
        \;]
}

proc audio_cancel {id} {
    pd [concat $id cancel \;]
}

proc audio_ok {id} {
    audio_apply $id
    audio_cancel $id
}

# callback from popup menu
proc audio_popup_action {buttonname varname devlist index} {
    global audio_indevlist audio_outdevlist $varname
    $buttonname configure -text [lindex $devlist $index]
#    puts stderr [concat popup_action $buttonname $varname $index]
    set $varname $index
}

# create a popup menu
proc audio_popup {name buttonname varname devlist} {
    global pd_nt
    if [winfo exists $name.popup] {destroy $name.popup}
    menu $name.popup -tearoff false
    if {$pd_nt == 1} {
    $name.popup configure -font menuFont
    }
#    puts stderr [concat $devlist ]
    for {set x 0} {$x<[llength $devlist]} {incr x} {
        $name.popup add command -label [lindex $devlist $x] \
            -command [list audio_popup_action \
                $buttonname $varname $devlist $x] 
    }
    tk_popup $name.popup [winfo pointerx $name] [winfo pointery $name] 0
}

####################### midi dialog ##################

proc midi_apply {id} {
    global midi_indev1 midi_indev2 midi_indev3 midi_indev4 
    global midi_outdev1 midi_outdev2 midi_outdev3 midi_outdev4
    global midi_alsain midi_alsaout

    pd [concat pd midi-dialog \
        $midi_indev1 \
        $midi_indev2 \
        $midi_indev3 \
        $midi_indev4 \
        $midi_outdev1 \
        $midi_outdev2 \
        $midi_outdev3 \
        $midi_outdev4 \
        $midi_alsain \
        $midi_alsaout \
        \;]
}

proc midi_cancel {id} {
    pd [concat $id cancel \;]
}

proc midi_ok {id} {
    midi_apply $id
    midi_cancel $id
}

# callback from popup menu
proc midi_popup_action {buttonname varname devlist index} {
    global midi_indevlist midi_outdevlist $varname
    $buttonname configure -text [lindex $devlist $index]
#    puts stderr [concat popup_action $buttonname $varname $index]
    set $varname $index
}

# create a popup menu
proc midi_popup {name buttonname varname devlist} {
    global pd_nt
    if [winfo exists $name.popup] {destroy $name.popup}
    match_linux_wm [list menu $name.popup -tearoff false]
    if {$pd_nt == 1} {
    $name.popup configure -font menuFont
    }
#    puts stderr [concat $devlist ]
    for {set x 0} {$x<[llength $devlist]} {incr x} {
        $name.popup add command -label [lindex $devlist $x] \
            -command [list midi_popup_action \
                $buttonname $varname $devlist $x] 
    }
    tk_popup $name.popup [winfo pointerx $name] [winfo pointery $name] 0
}

############ namespace ScrollBox -- utility scrollbar with default bindings #########
# This ScrollBox is used in the Path and Startup dialogs to edit lists of options

namespace eval ScrollBox {
    # This variable keeps track of the last list element we clicked on,
    # used to implement drag-drop reordering of list items
    variable lastIdx 0

    proc get_curidx { id } {
        set idx [$id.listbox.box index active]
        if {$idx < 0 || \
            $idx == [$id.listbox.box index end]} {
            return [expr {[$id.listbox.box index end] + 1}]
        }
        return [expr $idx]
    }

    proc insert_item { id idx name } {
        if {$name != ""} {
            $id.listbox.box insert $idx $name
            set activeIdx [expr {[$id.listbox.box index active] + 1}]
            $id.listbox.box see $activeIdx
            $id.listbox.box activate $activeIdx
            $id.listbox.box selection clear 0 end
            $id.listbox.box selection set active
            focus $id.listbox.box
        }
    }

    proc add_item { id add_method } {
        set dir [$add_method]
        insert_item $id [expr {[get_curidx $id] + 1}] $dir
    }

    proc edit_item { id edit_method } {
        set idx [expr {[get_curidx $id]}]
        set initialValue [$id.listbox.box get $idx]
        if {$initialValue != ""} {
            set dir [$edit_method $initialValue]

            if {$dir != ""} {
                $id.listbox.box delete $idx
                insert_item $id $idx $dir
            }
            $id.listbox.box activate $idx
            $id.listbox.box selection clear 0 end
            $id.listbox.box selection set active
            focus $id.listbox.box
        }
    }

    proc delete_item { id } {
        set cursel [$id.listbox.box curselection]
        foreach idx $cursel {
            $id.listbox.box delete $idx
        }
    }

    # Double-clicking on the listbox should edit the current item,
    # or add a new one if there is no current
    proc dbl_click { id edit_method add_method x y } {
        if { $x == "" || $y == "" } {
            return
        }

        set curBB [$id.listbox.box bbox @$x,$y]

        # listbox bbox returns an array of 4 items in the order:
        # left, top, width, height
        set height [lindex $curBB 3]
        set top [lindex $curBB 1]
        if { $height == "" || $top == "" } {
            # If for some reason we didn't get valid bbox info,
            # we want to default to adding a new item
            set height 0
            set top 0
            set y 1
        }

        set bottom [expr {$height + $top}]

        if {$y > $bottom} {
            add_item $id $add_method
        } else {
            edit_item $id $edit_method
        }
    }

    proc click { id x y } {
        # record the index of the current element being
        # clicked on
        set ::lastIdx [$id.listbox.box index @$x,$y]

        focus $id.listbox.box
    }

    # For drag-and-drop reordering, recall the last-clicked index
    # and move it to the position of the item currently under the mouse
    proc release { id x y } {
        set curIdx [$id.listbox.box index @$x,$y]

        if { $curIdx != $::lastIdx } {
            # clear any current selection
            $id.listbox.box selection clear 0 end

            set oldIdx $::lastIdx
            set newIdx [expr {$curIdx+1}]
            set selIdx $curIdx

            if { $curIdx < $::lastIdx } {
                set oldIdx [expr {$::lastIdx + 1}]
                set newIdx $curIdx
                set selIdx $newIdx
            }

            $id.listbox.box insert $newIdx [$id.listbox.box get $::lastIdx]
            $id.listbox.box delete $oldIdx
            $id.listbox.box activate $newIdx
            $id.listbox.box selection set $selIdx
        }
    }

    # Make a ScrollBox widget in a given window and set of data.
    #
    # id - the parent window for the scrollbox
    # listdata - array of data to populate the scrollbox
    # add_method - method to be called when we add a new item
    # edit_method - method to be called when we edit an existing item
    proc make { id listdata add_method edit_method } {
        global pd_nt
        match_linux_wm [list frame $id.listbox]
        match_linux_wm [list listbox $id.listbox.box \
            -selectmode browse -activestyle dotbox \
            -yscrollcommand [list "$id.listbox.scrollbar" set] \
			-relief sunken -bd 1 -highlightthickness 0 -takefocus 0]

        # Create a scrollbar and keep it in sync with the current
        # listbox view
        pack $id.listbox.box [match_linux_wm [list scrollbar "$id.listbox.scrollbar" \
                -command [list $id.listbox.box yview]]] \
                -side left -fill y -anchor w -pady 3

        # Populate the listbox widget
        foreach item $listdata {
            $id.listbox.box insert end $item
        }

        # Standard listbox key/mouse bindings
        event add <<Delete>> <Delete>
        if { $pd_nt == 2 } { event add <<Delete>> <BackSpace> }

        bind $id.listbox.box <ButtonPress> "ScrollBox::click $id %x %y"
        bind $id.listbox.box <Double-1> "ScrollBox::dbl_click $id $edit_method $add_method %x %y"
        bind $id.listbox.box <ButtonRelease> "ScrollBox::release $id %x %y"
        bind $id.listbox.box <Return> "ScrollBox::edit_item $id $edit_method"
        bind $id.listbox.box <<Delete>> "ScrollBox::delete_item $id"

        # <Configure> is called when the user modifies the window
        # We use it to capture resize events, to make sure the
        # currently selected item in the listbox is always visible
        bind $id <Configure> "$id.listbox.box see active"

        # The listbox should expand to fill its containing window
        # the "-fill" option specifies which direction (x, y or both) to fill, while
        # the "-expand" option (false by default) specifies whether the widget
        # should fill
        pack $id.listbox.box -side left -fill both -expand 1
        pack $id.listbox -side top -pady 2m -padx 2m -fill both -expand 1

        # All widget interactions can be performed without buttons, but
        # we still need a "New..." button since the currently visible window
        # might be full (even though the user can still expand it)
        match_linux_wm [list frame $id.actions] 
        pack $id.actions -side top -padx 2m -fill x
		if { [info tclversion] >= 8.5 && $pd_nt == 0} {
			ttk::button $id.actions.add_path -text {New...} \
			    -command "ScrollBox::add_item $id $add_method"
			ttk::button $id.actions.edit_path -text {Edit...} \
			    -command "ScrollBox::edit_item $id $edit_method"
			ttk::button $id.actions.delete_path -text {Delete} \
			    -command "ScrollBox::delete_item $id"
		} else {
			button $id.actions.add_path -text {New...} \
			    -command "ScrollBox::add_item $id $add_method"
			button $id.actions.edit_path -text {Edit...} \
			    -command "ScrollBox::edit_item $id $edit_method"
			button $id.actions.delete_path -text {Delete} \
			    -command "ScrollBox::delete_item $id"
		}
        pack $id.actions.delete_path -side right -pady 2m -padx 3
        pack $id.actions.edit_path -side right -pady 2m -padx 3
        pack $id.actions.add_path -side right -pady 2m -padx 3

        $id.listbox.box activate end
        $id.listbox.box selection set end
        focus $id.listbox.box
    }
}



############ namespace dlg_ScrollBoxWindow -- scrollbox window with default bindings #########
## This is the base dialog behind the Path and Startup dialogs
## This namespace specifies everything the two dialogs have in common,
## with arguments specifying the differences
##
## By default, this creates a dialog centered on the viewing area of the screen
## with cancel, apply, and OK buttons
## which contains a ScrollBox widget populated with the given data
namespace eval dlg_ScrollBoxWindow {
    proc get_listdata { id } {
        return [$id.listbox.box get 0 end]
    }

    proc do_apply { id commit_method listdata } {
        $commit_method [pdtk_encode $listdata]
        pd "pd save-preferences \;"
    }

    # Cancel button action
    proc cancel { id } {
        pd [concat $id cancel \;]
    }

    # Apply button action
    proc apply { id commit_method } {
        do_apply $id $commit_method [get_listdata $id]
    }

    # OK button action
    # The "commit" action can take a second or more,
    # long enough to be noticeable, so we only write
    # the changes after closing the dialog
    proc ok { id commit_method } {
        set listdata [get_listdata $id]
        cancel $id
        do_apply $id $commit_method $listdata
    }

    # "Constructor" function for building the window
    # id -- the window id to use
    # listdata -- the data used to populate the scrollbox
    # add_method -- a reference to a proc to be called when the user adds a new item
    # edit_method -- same as above, for editing and existing item
    # commit_method -- same as above, to commit during the "apply" action
    # title -- top-level title for the dialog
    # width, height -- initial width and height dimensions for the window, also minimum size
    proc make { id listdata add_method edit_method commit_method title width height } {
		global pd_nt
 
		toplevel $id -class [winfo class .]
		match_linux_wm [list $id configure]
        wm title $id $title
		
        wm protocol $id WM_DELETE_WINDOW [concat dlg_ScrollBoxWindow::cancel $id]

        # Enforce a minimum size for the window
        wm minsize $id $width $height

        # Set the current dimensions of the window
        wm geometry $id "${width}x${height}"
		
        # Center the window on the screen
        after idle "center_window $id"

        # Add the scrollbox widget
        ScrollBox::make $id $listdata $add_method $edit_method

        # Use two frames for the buttons, since we want them both
        # bottom and right
        match_linux_wm [list frame $id.nb]
        pack $id.nb -side bottom -fill x -pady 2m

        match_linux_wm [list frame $id.nb.buttonframe]
        pack $id.nb.buttonframe -side right -padx 2m

		if { [info tclversion] >= 8.5 && $pd_nt == 0} {
			ttk::button $id.nb.buttonframe.cancel \
				-text {Cancel} \
			    -command "dlg_ScrollBoxWindow::cancel $id"
		   	ttk::button $id.nb.buttonframe.apply \
				-text {Apply} \
			    -command "dlg_ScrollBoxWindow::apply $id $commit_method"
			ttk::button $id.nb.buttonframe.ok \
				-text {OK} \
			    -command "dlg_ScrollBoxWindow::ok $id $commit_method"
		} else {
			button $id.nb.buttonframe.cancel \
				-text {Cancel} \
			    -command "dlg_ScrollBoxWindow::cancel $id"
		   	button $id.nb.buttonframe.apply \
				-text {Apply} \
			    -command "dlg_ScrollBoxWindow::apply $id $commit_method"
			button $id.nb.buttonframe.ok \
				-text {OK} \
			    -command "dlg_ScrollBoxWindow::ok $id $commit_method"
		}

        pack $id.nb.buttonframe.cancel -side left -expand 1 -padx 3
        pack $id.nb.buttonframe.apply -side left -expand 1 -padx 3
        pack $id.nb.buttonframe.ok -side left -expand 1 -padx 3
   }
}


############ pdtk_path_dialog -- dialog window for search path #########
namespace eval dlg_Path {
    proc choosePath { curValue title } {
        if {$curValue == ""} {
            set curValue "~"
        }
        return [tk_chooseDirectory -initialdir $curValue -title $title]
    }

    proc add {} {
        return [dlg_Path::choosePath "" {Add a new path}]
    }

    proc edit { curValue } {
        return [dlg_Path::choosePath $curValue "Edit existing path \[$curValue\]"]
    }

    proc commit { new_path } {
        global pd_extrapath pd_verbose
        global pd_path
        set pd_path $new_path

        pd [concat pd path-dialog $pd_extrapath $pd_verbose $pd_path \;]
    }

    proc init { id extrapath verbose } {
        global pd_extrapath pd_verbose
        global pd_path
		global pd_nt

        set pd_extrapath $extrapath
        set pd_verbose $verbose

        dlg_ScrollBoxWindow::make $id $pd_path \
            dlg_Path::add dlg_Path::edit dlg_Path::commit \
            {Pd Search Path for Patches and Other Files} \
            400 300 

        match_linux_wm [list frame $id.extraframe]
        pack $id.extraframe -side bottom -pady 3
        match_linux_wm [list checkbutton $id.extraframe.extra \
			-text {use standard extensions} \
            -variable pd_extrapath]
        match_linux_wm [list checkbutton $id.extraframe.verbose \
			-text {verbose} \
            -variable pd_verbose] 
        pack $id.extraframe.extra $id.extraframe.verbose \
            -side left -expand 1
    }
}

proc pdtk_path_dialog { id extrapath verbose } {
    dlg_Path::init $id $extrapath $verbose
}


########## pdtk_startup_dialog -- dialog window for startup options #########
namespace eval dlg_Startup {
    # Create a simple modal window with an entry widget
    # for editing/adding a startup command 
    # (the next-best-thing to in-place editing)
    proc chooseCommand { prompt initialValue } {
        global cmd
        set cmd $initialValue

        toplevel .inputBox -class [winfo class .]
        wm title .inputBox $prompt
        wm minsize .inputBox 450 30
        wm resizable .inputBox 1 0
        wm geom .inputBox "450x30"
        after idle { center_window .inputBox 10 50 }

        match_linux_wm [list button .inputBox.cmdOK -text "OK" -command { destroy .inputBox } ]

        match_linux_wm [list entry .inputBox.txtInput -width 50 -textvariable cmd ]
        pdtk_standardkeybindings .inputBox.txtInput
        bind .inputBox.txtInput <KeyPress-Return> { destroy .inputBox }
        bind .inputBox.txtInput <KeyPress-Escape> { destroy .inputBox }
        pack .inputBox.txtInput -side left -expand 1 -fill x -padx 3 -pady 3
        pack .inputBox.cmdOK -side left -padx 3 -pady 3

        focus .inputBox.txtInput

        grab .inputBox
        raise .inputBox
        wm transient .inputBox
        tkwait window .inputBox

        return $cmd
    }

    proc add {} {
        return [chooseCommand {Add new startup command} ""]
    }

    proc edit { curValue } {
        return [chooseCommand {Edit startup command} $curValue]
    }

    proc commit { new_startup } {
        global pd_nort pd_flags
        global pd_startup
        set pd_startup $new_startup

        pd [concat pd startup-dialog $pd_nort [pdtk_encodedialog $pd_flags] $pd_startup \;]
    }

    proc init { id nort flags } {
        global pd_nort pd_nt pd_flags
        global pd_startup

        set pd_nort $nort
        set pd_flags $flags

        dlg_ScrollBoxWindow::make $id $pd_startup \
            dlg_Startup::add dlg_Startup::edit dlg_Startup::commit \
            {Pd Binaries to Load (on Next Startup)} \
            400 300

		match_linux_wm [list frame $id.startup]
		pack $id.startup -padx 5
        match_linux_wm [list label $id.startup.entryname -text {startup flags:}]
        match_linux_wm [list entry $id.startup.entry -textvariable pd_flags -width 60]
        pdtk_standardkeybindings $id.startup.entry
        pack $id.startup.entryname $id.startup.entry -side left -padx 3
        pack $id.startup.entry -side right -fill x -expand 1 -padx 3

        match_linux_wm [list frame $id.nortframe]
        pack $id.nortframe -fill x -padx 5
        if {$pd_nt != 1} {
            match_linux_wm [list checkbutton $id.nortframe.nort \
				-text {defeat real-time scheduling} \
                -variable pd_nort]
			pack $id.nortframe.nort -side right -padx 3
        }

   }
}

proc pdtk_startup_dialog {id nort flags} {
    dlg_Startup::init $id $nort $flags
}

################## define custom'n'purty linux color picker ##################
# by Ivica Ico Bukvic

# color_applied must be exposed for iem apply and cancel 
set color_applied -1

if { [info tclversion] >= 8.5 && $pd_nt == 0 } {

	set rgb_r 0
	set rgb_g 0
	set rgb_b 0

	set hex_color "#000000"

	set saved_color_1 "#999999"
	set saved_color_2 "#777777"
	set saved_color_3 "#555555"

	proc set_color_channel {id input channel value} {
		global rgb_r rgb_g rgb_b hex_color
		if {$input == 1} {
			#using scale (we will reserve input var for future widget expansion)
			set target [expr int($value*255+0.5)]
			switch $channel {
				r { set rgb_r $target }
				g { set rgb_g $target }
				b { set rgb_b $target }
			}		
			$id.settings.rgb.$channel.label configure -text $target
			
		}
		#prepare hex version
		if {$rgb_r < 16} {
			set hex_r "0[format %x $rgb_r]"
		} else {
			set hex_r [format %x $rgb_r]
		}
		if {$rgb_g < 16} {
			set hex_g "0[format %x $rgb_g]"
		} else {
			set hex_g [format %x $rgb_g]
		}
		if {$rgb_b < 16} {
			set hex_b "0[format %x $rgb_b]"
		} else {
			set hex_b [format %x $rgb_b]
		}
		set hex_color "#$hex_r$hex_g$hex_b"
		$id.settings.rgb.hex.entry delete 0 end
		$id.settings.rgb.hex.entry insert 0 $hex_color
		$id.settings.preview.view configure -bg $hex_color

		#the following is way too inefficient
		#ttk::style configure preview.TLabel -background "$hex_color"
	}

	proc pdtk_pd_color_dlg {color} {
		global rgb_r rgb_g rgb_b hex_color color_applied
		global saved_color_1 saved_color_2 saved_color_3
		global ctrl_key

		if { [winfo exists .color_dlg.settings] } {
			destroy .color_dlg
		}
		set color_applied 0

		set name .color_dlg

		#parse out incoming color
		set hex_color $color

		set char_list [split $color {}]
		set hex_rgb_r [lindex $char_list 1][lindex $char_list 2]
		set hex_rgb_g [lindex $char_list 3][lindex $char_list 4]
		set hex_rgb_b [lindex $char_list 5][lindex $char_list 6]
		set rgb_r [expr 0x$hex_rgb_r]
		set rgb_g [expr 0x$hex_rgb_g]
		set rgb_b [expr 0x$hex_rgb_b]

		toplevel $name -class [winfo class .]

		wm resizable $name 0 0
		#global tmp_xpix tmp_ypix
		#wm geometry $name "+$tmp_xpix+$tmp_ypix"
		match_linux_wm [list $name configure]
		wm title $name {Compose Custom Color}

		bind $name <Control-t> {texteditor_ok %W}
		bind $name <Control-s> {texteditor_send %W}

		match_linux_wm [list frame $name.settings]
		pack $name.settings -side top

		match_linux_wm [list frame $name.settings.rgb]
		pack $name.settings.rgb -side left -fill y -padx 3 -pady 3
		ttk::label $name.settings.rgb.title -text {color channels}

		match_linux_wm [list frame $name.settings.rgb.r]
		ttk::label $name.settings.rgb.r.title -text {R} -width 1
		ttk::scale $name.settings.rgb.r.scale -length 285 \
			-command "set_color_channel $name 1 r" \
			-value [expr $rgb_r/255.0]
		ttk::label $name.settings.rgb.r.label -width 3 -text $rgb_r -relief sunken
		pack $name.settings.rgb.r.label $name.settings.rgb.r.scale \
			$name.settings.rgb.r.title -side left -padx 2

		match_linux_wm [list frame $name.settings.rgb.g]
		ttk::label $name.settings.rgb.g.title -text {G} -width 1
		ttk::scale $name.settings.rgb.g.scale -length 285 \
			-command "set_color_channel $name 1 g" \
			-value [expr $rgb_g/255.0]
		ttk::label $name.settings.rgb.g.label -width 3 -text $rgb_g -relief sunken
		pack $name.settings.rgb.g.label \
			$name.settings.rgb.g.scale \
			$name.settings.rgb.g.title \
			-side left -padx 2

		match_linux_wm [list frame $name.settings.rgb.b]
		ttk::label $name.settings.rgb.b.title -text {B} -width 1
		ttk::scale $name.settings.rgb.b.scale -length 285 \
			-command "set_color_channel $name 1 b" \
			-value [expr $rgb_b/255.0]
		ttk::label $name.settings.rgb.b.label -width 3 -text $rgb_b -relief sunken
		pack $name.settings.rgb.b.label $name.settings.rgb.b.scale \
			$name.settings.rgb.b.title -side left -padx 2

		match_linux_wm [list frame $name.settings.rgb.hex]
		ttk::label $name.settings.rgb.hex.label -text {hex value:}
		ttk::entry $name.settings.rgb.hex.entry -width 8 -validate focusout \
			-validatecommand "pdtk_pd_color_from_hex $name %P"
		$name.settings.rgb.hex.entry insert 0 $color
		ttk::label $name.settings.rgb.hex.saved -text {recall presets:}
		label $name.settings.rgb.hex.saved1 \
			-text " 1 " -relief sunken -bd 1 -bg $saved_color_1
		bind $name.settings.rgb.hex.saved1 \
			<Button> "pdtk_pd_color_dialog_recall $name 1"
		label $name.settings.rgb.hex.saved2 \
			-text " 2 " -relief sunken -bd 1 -bg $saved_color_2
		bind $name.settings.rgb.hex.saved2 \
			<Button> "pdtk_pd_color_dialog_recall $name 2"
		label $name.settings.rgb.hex.saved3 \
			-text " 3 " -relief sunken -bd 1 -bg $saved_color_3
		bind $name.settings.rgb.hex.saved3 \
			<Button> "pdtk_pd_color_dialog_recall $name 3"
		pack $name.settings.rgb.hex.label \
			$name.settings.rgb.hex.entry \
			$name.settings.rgb.hex.saved \
			$name.settings.rgb.hex.saved1 \
			$name.settings.rgb.hex.saved2 \
			$name.settings.rgb.hex.saved3 \
			-side left -padx 2

		pack $name.settings.rgb.title $name.settings.rgb.r \
			$name.settings.rgb.g $name.settings.rgb.b \
			$name.settings.rgb.hex -side top -pady 3

		match_linux_wm [list frame $name.settings.preview]
		pack $name.settings.preview -side right -fill both \
			-ipadx 3 -padx 3 -pady 3 -expand 1
		ttk::label $name.settings.preview.title -text {preview}
		label $name.settings.preview.view -bg $color -relief sunken -bd 1 \
			-text "                         \n\n\n\n\n"
		pack $name.settings.preview.title $name.settings.preview.view \
			-side top -pady 3

		ttk::separator $name.eyecandy
		pack $name.eyecandy -fill x -expand 0 -pady 3

		match_linux_wm [list frame $name.buttons]
		pack $name.buttons -padx 3 -pady 3
		ttk::button $name.buttons.cancel -text {Cancel} \
			-command "pdtk_pd_color_dialog_cancel $name $color"
		ttk::label $name.buttons.saveto -text {save to preset:}
		ttk::button $name.buttons.save1 -text {1} -width 2 \
			-command "pdtk_pd_color_dialog_save $name 1"
		ttk::button $name.buttons.save2 -text {2} -width 2 \
			-command "pdtk_pd_color_dialog_save $name 2"
		ttk::button $name.buttons.save3 -text {3} -width 2 \
			-command "pdtk_pd_color_dialog_save $name 3"
		ttk::button $name.buttons.apply -text {Select Color} \
			-command "pdtk_pd_color_dialog_ok $name"

		pack $name.buttons.cancel \
			$name.buttons.saveto \
			$name.buttons.save1 \
			$name.buttons.save2 \
			$name.buttons.save3 \
			$name.buttons.apply -side left -padx 3

    	bind $name <KeyPress-Return> \
			[format "pdtk_pd_color_dialog_ok %s" $name]
    	bind $name <$ctrl_key-Key-w> \
			[format "pdtk_pd_color_dialog_cancel %s %s" $name $color]
		bind $name <KeyPress-Escape> \
			[format "pdtk_pd_color_dialog_cancel %s %s" $name $color]

		bind $name.settings.rgb.hex.entry <$ctrl_key-Key-x> \
			[format "menu_cut %s" $name.settings.rgb.hex.entry]
		bind $name.settings.rgb.hex.entry <$ctrl_key-Key-c> \
			[format "menu_copy %s" $name.settings.rgb.hex.entry]
		bind $name.settings.rgb.hex.entry <$ctrl_key-Key-v> \
			[format "menu_paste %s" $name.settings.rgb.hex.entry]
		bind $name.settings.rgb.hex.entry <$ctrl_key-Key-a> \
			[format "menu_selectall %s" $name.settings.rgb.hex.entry]

		pdtk_standardkeybindings $name

		return $name
	}

	proc pdtk_pd_color_dialog_save {id num} {
		global saved_color_1 saved_color_2 saved_color_3 hex_color
		[concat $id.settings.rgb.hex.saved$num] configure -bg $hex_color
		set [concat saved_color_$num] $hex_color
	}

	proc pdtk_pd_color_dialog_recall {id num} {
		global saved_color_1 saved_color_2 saved_color_3 hex_color
		global rgb_r rgb_g rgb_b
		switch -- $num {
			1	{set hex_color $saved_color_1}
			2	{set hex_color $saved_color_2}
			3	{set hex_color $saved_color_3}
		}
		set char_list [split $hex_color {}]
		set hex_rgb_r [lindex $char_list 1][lindex $char_list 2]
		set hex_rgb_g [lindex $char_list 3][lindex $char_list 4]
		set hex_rgb_b [lindex $char_list 5][lindex $char_list 6]
		set rgb_r [expr 0x$hex_rgb_r]
		set rgb_g [expr 0x$hex_rgb_g]
		set rgb_b [expr 0x$hex_rgb_b]

		#reset widgets
		$id.settings.rgb.r.scale configure -value [expr $rgb_r/255.0]
		$id.settings.rgb.g.scale configure -value [expr $rgb_g/255.0]
		$id.settings.rgb.b.scale configure -value [expr $rgb_b/255.0]
		$id.settings.rgb.r.label configure -text $rgb_r
		$id.settings.rgb.g.label configure -text $rgb_g
		$id.settings.rgb.b.label configure -text $rgb_b
		$id.settings.rgb.hex.entry delete 0 end
		$id.settings.rgb.hex.entry insert 0 $hex_color
		$id.settings.preview.view configure -bg $hex_color
	}	

	proc pdtk_pd_color_dialog_cancel {id color} {
		global hex_color color_applied
		set hex_color $color
		destroy $id
		set color_applied 1
	}

	proc pdtk_pd_color_dialog_ok {id} {
		global hex_color color_applied
		if ([string compare $hex_color [$id.settings.rgb.hex.entry get]]) {
			pdtk_pd_color_from_hex $id [$id.settings.rgb.hex.entry get]
		}
		destroy $id;
		set color_applied 1
	}

	proc pdtk_pd_color_from_hex {id color} {
		global rgb_r rgb_g rgb_b hex_color

		set hex_color $color

		set char_list [split $hex_color {}]
		set hex_rgb_r [lindex $char_list 1][lindex $char_list 2]
		set hex_rgb_g [lindex $char_list 3][lindex $char_list 4]
		set hex_rgb_b [lindex $char_list 5][lindex $char_list 6]

		if { [catch {expr 0x$hex_rgb_r} fid] } {
			set rgb_r 0
			set hex_rgb_r "00"
		} else {
			set rgb_r [expr 0x$hex_rgb_r]
		}

		if { [catch {expr 0x$hex_rgb_g} fid] } {
			set rgb_g 0
			set hex_rgb_g "00"
		} else {
			set rgb_g [expr 0x$hex_rgb_g]
		}

		if { [catch {expr 0x$hex_rgb_b} fid] } {
			set rgb_b 0
			set hex_rgb_b "00"
		} else {
			set rgb_b [expr 0x$hex_rgb_b]
		}

		if {[string length $hex_rgb_r] < 2} {
			set hex_rgb_r "0$hex_rgb_r"
		}
		if {[string length $hex_rgb_g] < 2} {
			set hex_rgb_g "0$hex_rgb_g"
		}
		if {[string length $hex_rgb_b] < 2} {
			set hex_rgb_b "0$hex_rgb_b"
		}

		set hex_color "#$hex_rgb_r$hex_rgb_g$hex_rgb_b"

		#set widgets
		$id.settings.rgb.r.scale configure -value [expr $rgb_r/255.0]
		$id.settings.rgb.g.scale configure -value [expr $rgb_g/255.0]
		$id.settings.rgb.b.scale configure -value [expr $rgb_b/255.0]
		$id.settings.rgb.r.label configure -text $rgb_r
		$id.settings.rgb.g.label configure -text $rgb_g
		$id.settings.rgb.b.label configure -text $rgb_b
		$id.settings.rgb.hex.entry delete 0 end
		$id.settings.rgb.hex.entry insert 0 $hex_color
		$id.settings.preview.view configure -bg $hex_color
		return 0
	}
}

################# Autotips ######################

proc pdtk_canvas_enteritem_gettags {tkcanvas x y item} {
	#puts stderr "gettags $tkcanvas $x $y $item"
	variable nlet_color
    if {[winfo exists $tkcanvas]} {
        set mytoplevel [winfo toplevel $tkcanvas]
        set tags [$tkcanvas gettags $item]
        set xletno -1 
		set object text
        foreach tag $tags {
			if {[regexp "(\[io\])(\[0-9\]+)$" $tag -- type xletno] } {
			    if {$type=="i"} {set object inlet}
			    if {$type=="o"} {set object outlet}
			    break
			}
		}
		#puts stderr "gettags $tags $object $xletno [$tkcanvas canvasx $x] [$tkcanvas canvasy $y]"
		if { $xletno == -1 && $object ne "text" } { return }
		if { $object ne "text" } {
			set nlet_color [$tkcanvas itemcget [lindex $tags 0] -stroke]
		} else {
			set nlet_color $::pd_colors(selection)
		}
        pd [concat $mytoplevel enter $object $x $y $xletno \;]
    }
}

proc pdtk_canvas_enteritem {tkcanvas x y item enterid} {
	variable pointer_x_local
	variable pointer_y_local
    variable afterid
    variable duplicate_tags
    variable current_window
	variable autotips
	#puts stderr "enteritem $tkcanvas $x $y $item $enterid $pointer_x_local $pointer_y_local"
    if {$autotips == 0} {return}
    if {$enterid != $duplicate_tags || $enterid == -1} {
		#puts stderr "pdtk_canvas_enteritem $tkcanvas"
	    set duplicate_tags $enterid
		if {$current_window eq $tkcanvas} {
			after cancel $afterid
		}
		set current_window $tkcanvas
		
		set afterid [after 250 pdtk_canvas_enteritem_gettags \
			$tkcanvas $x $y $item]
	}
}

# update sticky tooltip when scrolling
proc pdtk_canvas_update_sticky_tip {w} {
	#puts stderr "update_sticky_tip $w [lsearch -exact [$w gettags $w.tipwindow] \"sticky\"] [winfo exists $w.tiplabel]"
	#catch {
		if {[winfo exists $w.tiplabel]} {
			#puts stderr "got it"
			#set yreal [expr [$w canvasy 0] * -1 + \
			#	[winfo pointery $w]-[winfo rooty $w]]
			set yoffset 0
			#if {$yreal < [expr [winfo height $w] - \
			#	[winfo reqheight $w.tiplabel]] - 5} {
			#		set yoffset [winfo height $w]
			#		set anchor "sw"
			#} else {
			#	set anchor "nw"
			#}
			if {[$w itemcget $w.tipwindow -anchor] == "sw"} {
				set yoffset [winfo height $w]
			}
			set x [$w canvasx 0]
			set y [expr [$w canvasy 0] + $yoffset]
			$w coords $w.tipwindow $x $y
			#$w itemconfigure $w.tipwindow -anchor $anchor
			#puts stderr "[winfo pointery $w] [winfo rooty $w] $yreal $anchor"
		}
	#}
}
    # move normal selected items and add (dx, dy) to selected scalars' matrices
proc pdtk_canvas_displace_withtag {w dx dy} {
	#puts stderr "pdtk_canvas_displace_withtag $dx $dy"
    $w move selected $dx $dy
    foreach item [$w find withtag scalar_selected] {
        set matrix [lindex [$w itemconfigure $item -matrix] 4]
        #puts stderr "A:$matrix"
        set newx [expr {[lindex $matrix 2 0] + $dx}]
        set newy [expr {[lindex $matrix 2 1] + $dy}]
        set matrix [lreplace $matrix 2 2 [list $newx $newy]]
        #puts stderr "B:$matrix"
        $w itemconfigure $item -matrix $matrix
    }
}

# move activewidth to toggle on editmode?
proc pdtk_canvas_leaveitem {w} {
	#puts stderr "pdtk_canvas_leaveitem $w"
    variable afterid
    variable current_window
	variable duplicate_tags
	variable autotips
    if {$autotips == 0} {return}
    after cancel $afterid
	set afterid 0
    if {[lsearch -exact [$w gettags $w.tipwindow] "sticky"] == -1} {
		#puts stderr "pdtk_canvas_leaveitem $w"
		if {[winfo exists $w.tiplabel]} {
            #set afterid [after 50 "pdtk_tip $w 0 0"]
			pdtk_tip $w 0 0
            set current_window $w
		}
    }
	set duplicate_tags -1;
}

proc pdtk_tip_delete {w} {
	variable tooltip_visible
	destroy $w.tiplabel
	$w delete tiparrow
	$w delete $w.tipwindow
	set tooltip_visible 0
}

proc pdtk_tip {w fromc show args} {
	#puts stderr "$w $fromc $show $args"
	variable nlet_color
	variable tooltip_visible
    global pd_fontlist
#    switch -- $::font([string trimright $w .c]) {
#        8  { set typeface [lindex $pd_fontlist 0] }
#        9  { set typeface [lindex $pd_fontlist 1] }
#        10 { set typeface [lindex $pd_fontlist 2] }
#        12 { set typeface [lindex $pd_fontlist 3] }
#        14 { set typeface [lindex $pd_fontlist 4] }
#        16 { set typeface [lindex $pd_fontlist 5] }
#        18 { set typeface [lindex $pd_fontlist 6] }
#        24 { set typeface [lindex $pd_fontlist 7] }
#        30 { set typeface [lindex $pd_fontlist 8] }
#        36 { set typeface [lindex $pd_fontlist 9] }
#    }
	set typeface [get_font_for_size $::font([string trimright $w .c])]
	set exists [winfo exists $w.tiplabel]
    if {$show == 0} {
    	if {$tooltip_visible == 1} {
        	after idle [concat pdtk_tip_delete $w]
		}
    } else {
		set tooltip_visible 1
		if { $nlet_color == 0 } { set nlet_color $::pd_colors(selection) }
		if { $nlet_color ne $::pd_colors(selection) } {
			set fg "#ffffff"
		} else {
			set fg "#000000"
		}
		if {$exists} {    	
			$w.tiplabel configure -text [join $args] -fg $fg -bg $nlet_color \
				-font $typeface
        	$w itemconfigure tiparrow -fill $nlet_color
	    	$w dtag $w.tipwindow "sticky"
	    	if {$fromc == 1} {
				$w addtag "sticky" withtag $w.tipwindow
	    	}  
		} else {
            label $w.tiplabel -text [join $args] -bd 1 \
	        -wraplength [winfo width $w] -bg $nlet_color -fg $fg -bd 1 \
	        -padx 2 -pady 2 -relief flat -font $typeface
		}

		if {$fromc == 1} {
			set yreal [expr [$w canvasy 0] + \
				[winfo pointery $w]-[winfo rooty $w]]
			set yoffset 0
			if {$yreal < [expr [winfo height $w] - \
				[winfo reqheight $w.tiplabel]] - 5} {
					set yoffset [winfo height $w]
					set anchor "sw"
			} else {
				set anchor "nw"
			}
			#puts stderr "$yreal [winfo height $w] [winfo reqheight $w.tiplabel]"
			set x [$w canvasx 0]
			set y [expr [$w canvasy 0] + $yoffset]
		} else {
		    set xreal [expr [$w canvasx 0] + [winfo pointerx $w]-[winfo rootx $w]]
		    set yreal [expr [$w canvasy 0] + [winfo pointery $w]-[winfo rooty $w]]

			# first figure out default behavior for above/below
			if { [string match "\{Inlet*" $args] } {
		    	set yoffset 0
				set anchor "nw"
				set top_bottom [expr -15 - [winfo reqheight $w.tiplabel]]
				set yreal_offset -10
				set xreal_offset 0
		    } else {
				set yoffset [winfo height $w]
		    	set anchor "sw"
				set top_bottom [expr 20 + [winfo reqheight $w.tiplabel]]
				set yreal_offset 14
				set xreal_offset 0
		    }
			set x [expr $xreal - 10] 
			set y [expr $yreal + $top_bottom]

			# now check if there is enough room to do the default above/below (if not redo behavior)
			if { $top_bottom < 0 && $y < [expr [$w canvasy 0] + $yoffset] } {
				set yoffset [winfo height $w]
		    	set anchor "sw"
				set top_bottom [expr 25 + [winfo reqheight $w.tiplabel]]
				set yreal_offset 20
				set xreal_offset 0
			}
			if { $top_bottom > 0 && $y > [expr [$w canvasy 0] + $yoffset] } {
		    	set yoffset 0
				set anchor "nw"
				set top_bottom [expr -20 - [winfo reqheight $w.tiplabel]]
				set yreal_offset -15
				set xreal_offset 0
			}
			set x [expr $xreal - 10] 
			set y [expr $yreal + $top_bottom]

			# if we still cannot fit things, let's now stick them as close to the side we selected last
			if { $top_bottom < 0 && $y < [expr [$w canvasy 0] + $yoffset] } { set y [expr [$w canvasy 0] + $yoffset] }
			if { $top_bottom > 0 && $y > [expr [$w canvasy 0] + $yoffset] } { set y [expr [$w canvasy 0] + $yoffset] }

			# now check the width
			set right 0
			set xarrow [expr $x + 5]

			if { [expr $x + [winfo reqwidth $w.tiplabel]] > [expr [$w canvasx 0] + [winfo width $w]] } {
				set tmp1 [expr $x - (($x + [winfo reqwidth $w.tiplabel]) - ([$w canvasx 0] + [winfo width $w]))]
				set x $tmp1
				set right 1
			}
			if { $x < [$w canvasx 0] } {
				set x [$w canvasx 0]
			}

			#now do the arrow
			if { $right } {
				if { $xarrow > [expr [$w canvasx 0] + [winfo width $w] - 10] } {
					set xarrow [expr [$w canvasx 0] + [winfo width $w] - 10]
				}
			} else {
				if { $xarrow < [$w canvasx 0] } {
					set xarrow [$w canvasx 0]
				}
			}

			if { $top_bottom < 0 } {
				set yarrow [expr $y + [winfo reqheight $w.tiplabel] - 1]
			} else {
				set yarrow [expr $y - [winfo reqheight $w.tiplabel] + 0]
			}

			if {$exists} {
				#$w coords tiparrow [expr $xreal+$xreal_offset] [expr $yreal+$yreal_offset] $xarrow $yarrow [expr $xarrow+10] $yarrow
				$w coords tiparrow [expr $xarrow+5] [expr $yreal+$yreal_offset] $xarrow $yarrow [expr $xarrow+10] $yarrow
			} else {
				#$w create polygon [expr $xreal+$xreal_offset] [expr $yreal+$yreal_offset] $xarrow $yarrow [expr $xarrow+10] $yarrow -fill $nlet_color -width 4 -tags tiparrow
				$w create ppolygon [expr $xarrow+5] [expr $yreal+$yreal_offset] $xarrow $yarrow [expr $xarrow+10] $yarrow -stroke $nlet_color -fill $nlet_color -strokewidth 1 -tags tiparrow
				#update (bad idea--avoid this)
			}
		}

		set tags $w.tipwindow
		if {$fromc == 1} {
			lappend tags "sticky"
		} 
		if {$exists} {
			$w coords $w.tipwindow $x $y
			$w itemconfigure $w.tipwindow -anchor $anchor
		} else {
	       	$w create window $x $y -window $w.tiplabel -anchor $anchor \
		    -tags $tags
			if {$fromc == 1} {
				#$w bind $w.tiplabel <Enter> "pdtk_tip_mouseover $w"
				bind $w.tiplabel <Motion> "pdtk_tip_mouseover $w"
				#update -- bad idea, don't do it
			}
		}
    }
}

set ::tip_mouseover_ping 0

# move the tip if the user happens to mouse over it
proc pdtk_tip_mouseover {w} {
	if {$::tip_mouseover_ping == 1} { return }
	#puts stderr "pdtk_tip_mouseover $w"
	if {[$w itemcget $w.tipwindow -anchor] == "sw"} {
		set yoffset 0
		set anchor "nw"
	} else {
		set yoffset [winfo height $w]
		set anchor "sw"
	}
	set x [$w canvasx 0]
	set y [expr [$w canvasy 0] + $yoffset]
	$w coords $w.tipwindow $x $y
	$w itemconfigure $w.tipwindow -anchor $anchor
	after 50 {set ::tip_mouseover_ping 0}
}

proc pdtk_gettip { w item xletno name helpname dir } {
	# puts stderr "pdtk_gettip $w $item $xletno $name $helpname $dir"
	variable k12_mode
	if {$name eq "preset_hub" && $k12_mode == 1} {
		return
	}
    if {$dir eq {}} {
		set dir $::sys_libdir/doc/5.reference
    }
    # trim off trailing ".pd" for abstractions
    regexp {^(.*)(?:\.pd)} $name -- name
    # use $varxlet to see if an object has a 
    # variable xlet (marked in the docs as
    # "INLET_N" or "OUTLET_N") 
    set varxlet {}
    set metatag description
    if {$item eq "inlet" ||
	$item eq "outlet"} {
		set varxlet [join [list $item "n"] "_"]
        set metatag [join [list $item $xletno] "_"]
		set msg "[string toupper [string map {_ " "} $metatag] 0 0] of $name"
    } elseif {$item eq "text"} {
		set metatag "description"
        set msg $name
    }
    set filefound 0
    if {![catch {set fp [open [file join $dir \
	    "$name-help.pd"]]}] ||
        ![catch {set fp [open [file join $dir \
	"$helpname-help.pd"]]}] } {
        set filefound 1
    }
    if {$filefound} {
    	# puts stderr filefound
		set filecontents [read $fp]
		close $fp
		# leave in pd's linebreaks-- serendipitously it
		# makes the tipwindow more compact/easier to read
		regsub -all {[{}]} $filecontents "" filecontents
		# turn escaped semicolons into linebreaks
		regsub -all {[\n\s]\\;[\n\s]} $filecontents "\n" filecontents
		set match {}
		# if $varxlet ne {} then the $item is an inlet or outlet
		if { $varxlet ne {}  &&
		    [regexp -nocase \
		    "#X text \[0-9\]+ \[0-9\]+ $varxlet (\[^;\]+)" \
		    $filecontents] } {
		    set match "(variable inlet)"
		}
    	    regexp -nocase \
		    "#X text \[0-9\]+ \[0-9\]+ $metatag (\[^;\]+)" \
		    $filecontents -- match
		if { $match ne {} } {
		    set msg [string trim "$msg: $match"]
		}
    }
    # make Pd's comma atoms look pretty
    # puts stderr $msg
    regsub -all {\\,} $msg {,} msg
    regsub -all { ,} $msg {,} msg
    regsub -all {\n} $msg { } msg
    regsub -all {  } $msg { } msg
    #regsub -all {\n\\,} $msg ",\n" msg
    pdtk_tip $w 0 1 $msg
}

# ---------------- allow for unique instance ---------------------

proc pdtk_open_files_via_unique {filenames} {
	#puts stderr "pdtk_open_files_via_unique $filenames"
	if { $filenames != 0 } {
		foreach file $filenames {
			#puts stderr "open_file $file"
			open_file $file
		}
	}
}

proc pdtk_check_unique {unique filenames} {
	#puts stderr "pdtk_check_unique $unique $filenames"
	global appname
	set startup_dir [pwd]
	if { $unique == 0 } {
		foreach file $filenames {
			#puts stderr "$file [file dirname $file] $startup_dir"
			catch {cd [file dirname $file]}
			set dir [pwd]
			set name [file tail $file]
			#puts stderr "********DIR:$dir FILE:$name COMBINED:[file join $dir $name]"
			lappend final_filenames [file join $dir $name]
			cd $startup_dir
		}
		#puts stderr "send pd-l2ork pdtk_open_files_via_unique $final_filenames"
		set outcome [catch {send pd-l2ork pdtk_open_files_via_unique \{$final_filenames\}}]
		#puts stderr "outcome = $outcome"
		if { $outcome == 0 } {
			menu_really_quit
			exit
		}
	}
	tk appname $appname
	#puts stderr "this is unique instance [tk appname]"
}

# Search plugin
source [file join [file dirname [info script]] search-plugin.tcl]

# Tcl/tk code for drawimage and drawsprite
source [file join [file dirname [info script]] pdtk_drawimage.tcl]

# Ugly, ugly hack to send off to procs in dialog_audio.tcl and
# dialog_midi.tcl.  Should just load the packages properly instead...

proc pdtk_audio_dialog {mytoplevel indev1 indev2 indev3 indev4 \
        inchan1 inchan2 inchan3 inchan4 \
        outdev1 outdev2 outdev3 outdev4 \
        outchan1 outchan2 outchan3 outchan4 sr advance multi callback \
        longform blocksize} {
    ::dialog_audio::pdtk_audio_dialog \
        $mytoplevel $indev1 $indev2 $indev3 $indev4 \
        $inchan1 $inchan2 $inchan3 $inchan4 \
        $outdev1 $outdev2 $outdev3 $outdev4 \
        $outchan1 $outchan2 $outchan3 $outchan4 $sr $advance $multi $callback \
        $longform $blocksize
}

proc pdtk_midi_dialog {id indev1 indev2 indev3 indev4 \
        outdev1 outdev2 outdev3 outdev4 longform} {
    ::dialog_midi::pdtk_midi_dialog \
        $id $indev1 $indev2 $indev3 $indev4 \
        $outdev1 $outdev2 $outdev3 $outdev4 $longform
}

proc pdtk_alsa_midi_dialog {id indev1 indev2 indev3 indev4 \
        outdev1 outdev2 outdev3 outdev4 longform alsa} {
    ::dialog_midi::pdtk_alsa_midi_dialog \
        $id $indev1 $indev2 $indev3 $indev4 \
        $outdev1 $outdev2 $outdev3 $outdev4 $longform $alsa
}

set ::sc_entered ""

proc scalar_mouseover_after {canvas sendsym state} {
    pd [concat $canvas scalar_mouseover $sendsym $state \;]
    set ::sc_entered {}
}

proc scalar_mouseover {scalar canvas sendsym state} {
    if {$state == 0} {
        after cancel "scalar_mouseover_after $canvas $sendsym 1"
        if {$scalar ne $::sc_entered} {
            pd [concat $canvas scalar_mouseover $sendsym 0 \;]
        }
        set ::sc_entered $scalar
    } else {
        after 0 "scalar_mouseover_after $canvas $sendsym 1"
    }
}

proc pdtk_bind_scalar_mouseover {canvas scalar sendsym} {
    $canvas bind $scalar <Enter> \
        "scalar_mouseover $scalar [canvastosym $canvas] $sendsym 0"
    $canvas bind $scalar <Leave> \
        "scalar_mouseover $scalar [canvastosym $canvas] $sendsym 1"
}

proc AT {p} {}

